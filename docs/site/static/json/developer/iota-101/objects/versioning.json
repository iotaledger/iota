[
    {
        "questionText": "What happens when a transaction modifies an object in IOTA?",
        "answerOptions": [
            { "answerText": "It creates a new object with a new ID and resets the version.", "isCorrect": false },
            { "answerText": "It updates the object in place, keeping the same version.", "isCorrect": false },
            { "answerText": "It creates a new version of the object with the same ID, incrementing the version.", "isCorrect": true },
            { "answerText": "It deletes the old object and creates a new object with a different ID.", "isCorrect": false }
        ]
    },
    {
        "questionText": "What is the purpose of using Lamport timestamps in IOTA's versioning algorithm for objects?",
        "answerOptions": [
            { "answerText": "To synchronize clocks across the network.", "isCorrect": false },
            { "answerText": "To ensure versions are never reused and maintain a linear history.", "isCorrect": true },
            { "answerText": "To generate random versions for security purposes.", "isCorrect": false },
            { "answerText": "To allow multiple transactions to modify an object simultaneously.", "isCorrect": false }
        ]
    },
    {
        "questionText": "How are immutable objects in IOTA referenced in transactions?",
        "answerOptions": [
            { "answerText": "By their ID and version, and they need to be locked.", "isCorrect": false },
            { "answerText": "Only by their ID, since their version doesn't matter.", "isCorrect": false },
            { "answerText": "By their ID and version, but they do not need to be locked.", "isCorrect": true },
            { "answerText": "By their owner's address.", "isCorrect": false }
        ]
    },
    {
        "questionText": "What happens when a wrapped object is unwrapped in IOTA?",
        "answerOptions": [
            { "answerText": "It is deleted permanently from the blockchain.", "isCorrect": false },
            { "answerText": "It becomes accessible again by its original ID.", "isCorrect": true },
            { "answerText": "It gets a new ID and version.", "isCorrect": false },
            { "answerText": "It remains inaccessible.", "isCorrect": false }
        ]
    },
    {
        "questionText": "Which of the following statements is true about dynamic fields in IOTA?",
        "answerOptions": [
            { "answerText": "Dynamic fields are accessed directly by their ID.", "isCorrect": false },
            { "answerText": "Dynamic fields are accessible only through their parent object.", "isCorrect": true },
            { "answerText": "Dynamic fields do not increment their version when modified.", "isCorrect": false },
            { "answerText": "Dynamic fields cannot store object types.", "isCorrect": false }
        ]
    },
    {
        "questionText": "What is unique about framework packages in IOTA compared to user packages?",
        "answerOptions": [
            { "answerText": "Framework packages cannot be upgraded.", "isCorrect": false },
            { "answerText": "Framework packages have IDs that remain consistent across upgrades.", "isCorrect": true },
            { "answerText": "Framework packages are deleted after use.", "isCorrect": false },
            { "answerText": "Framework packages do not have versions.", "isCorrect": false }
        ]
    },
    {
        "questionText": "When upgrading a user package in IOTA, what happens to the package ID?",
        "answerOptions": [
            { "answerText": "It remains the same.", "isCorrect": false },
            { "answerText": "It changes to a new ID generated by IOTA.", "isCorrect": true },
            { "answerText": "It becomes undefined.", "isCorrect": false },
            { "answerText": "It merges with the previous version's ID.", "isCorrect": false }
        ]
    },
    {
        "questionText": "Why might validators reject transactions that directly reference wrapped objects in IOTA?",
        "answerOptions": [
            { "answerText": "Because wrapped objects do not have IDs.", "isCorrect": false },
            { "answerText": "Because wrapped objects are only accessible through their wrapping object.", "isCorrect": true },
            { "answerText": "Because wrapped objects cannot be unwrapped.", "isCorrect": false },
            { "answerText": "Because referencing wrapped objects requires special permissions.", "isCorrect": false }
        ]
    },
    {
        "questionText": "How does IOTA ensure that (ID, version) pairs are not reused when dealing with dynamic fields?",
        "answerOptions": [
            { "answerText": "By deleting old versions of dynamic fields.", "isCorrect": false },
            { "answerText": "By using the same ID but incrementing the version only on the parent object.", "isCorrect": false },
            { "answerText": "By using Lamport timestamp-based versioning.", "isCorrect": true },
            { "answerText": "By preventing the addition of new fields with the same name.", "isCorrect": false }
        ]
    },
    {
        "questionText": "What is the role of the package version specified in the manifest file during publishing or upgrading in IOTA?",
        "answerOptions": [
            { "answerText": "It is used by the publish and upgrade commands to manage versions on-chain.", "isCorrect": false },
            { "answerText": "It is for user-level documentation and not used by publish and upgrade commands.", "isCorrect": true },
            { "answerText": "It determines the package's on-chain ID.", "isCorrect": false },
            { "answerText": "It prevents the package from being overridden.", "isCorrect": false }
        ]
    }
]
