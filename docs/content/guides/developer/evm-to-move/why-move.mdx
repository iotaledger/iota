---
title: Why Move?
---

While EVM/Solidity is the most significant right now when it comes to Smart Contract development, it definitely has some less desired properties, among which:

 - **Performance, scaling, and cost**: EVM builds on top of a global shared state, which is practical but doesn't scale well. This results in limitations in throughput, which is directly reflected in the fees you must pay to interact with these networks. The more congested the network, the more expensive it gets. This is worked around with additional extra execution layers (L2's on top of L1's) or rollup solutions, which also have their own downsides and limitations.
 - **Security:** As the first well-used smart contract language, Solidity did not have much to go by in terms of learnings around secure practices (there was no existing ecosystem yet), and it had to develop over the years with that legacy and backward compatibility in mind. Many of the issues from the past have been mitigated with workarounds. Still, given the nature of things, there are some limitations and annoyances we currently can't get around, like the security issues it has with both the code and infamous design patterns like the `approve()` method in the ERC standards.
 - **Tokens:** Assets like ERC20 tokens and ERC721/1155 NFTs are not part of the EVM and are purely standards for smart contracts deployed on an EVM chain interpreted as tokens by clients. While this works and allows much flexibility, it also has its downsides. Due to the nature of tokens being contracts and the state of your balance being stored with those contracts, it's not trivial to find all tokens in your account without knowing all token contract addresses and manually adding them, unlike the Ethereum balance itself, which is a different kind of token which can be found directly but works differently over an ERC20 token. This makes discovering your assets difficult and adds additional complexity to applications to close the gap between the native asset (ETH) and ERC20 tokens with workarounds like wrapped tokens, which is not ideal.
 - **Developer experience:** While Solidity is not so hard to get started with (the language is influenced by popular and well-known languages like C++ and Javascript), it's notoriously hard to write safe code for it. On the other hand, it's quite easy to write something that works at first glance, making this a dangerous property resulting in billions lost in the ecosystem due to coding mistakes and a lot of money spent on audits by expensive external parties that don't give any guarantee about the code actually being safe after the audit has passed. Due to this and other factors like the strange quirks in Solidity, the limited implementation of static-typing, and too much abstraction to libraries, Solidity has gained a reputation of being a bit of a minefield to work with - where the status quo is copying code that has been battle tested over true innovation. Not many developers enjoy writing Solidity, and the fear of making a mistake is often quite high, especially when there's big value at stake. 

IOTA Move is here to learn from these downsides and come up with a better alternative addressing these issues:

* **Performance, scaling, and cost:** Given that IOTA Move is based on the object model (similar to UTXO's) and not a globally shared state, transactions can be executed in parallel, resulting in a much higher (potential) throughput over a traditional blockchain with shared state. This results in a lot less congestion and, thus, lower fees on an actively used network. 
* **Security:** Move was designed with security in mind. The language itself is based on Rust and is very strict regarding its typing system. You really have to try to make a mistake that the compiler won't catch before deploying. There's no such thing as re-entry, and given the object-based approach of Move, Assets residing in your account can't be touched at all by the smart contract itself without access to your account keys. 
* **Tokens:** In IOTA Move, there is no difference between the IOTA token (`Coin<IOTA>`) and a custom token (`Coin<YOUR_NAME_HERE>`), not in terms of use or implementation. These objects reside in your own account and can thus easily be found without needing to know a Smart Contract address (this goes for any other type of owned object as well). There's no strange `approve()` functionality, and you keep control over your own owned assets.
* **Developer Experience:** While Move is more challenging to get started with over Solidity, the safety of the language and excellent developer experience when it comes to finding and resolving issues in your code make up for that. With Move, it's not so scary anymore to write complex logic from scratch, given most mistakes (apart from obvious implementation logic, doing things 'as intended') are caught directly by the compiler. This allows for more innovation, fewer value-destroying bugs, and a more excellent developer experience, fueling the next generation of smart contracts.


To sum this up:

| EVM/Solidity                               | Move                                                   |
| ------------------------------------------ | ------------------------------------------------------ |
| State as part of contracts                 | State as objects                                       |
| Global shared state                        | Owned and Shared objects                               |
| Transactions executed one by one           | Parallel execution                                     |
| No enforced security for standards         | Strict type system for standards, assurances           |
| Easy to get started with, hard to do right | Harder to get started with, but less room for mistakes |

