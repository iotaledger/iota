import AlphaNet from "../../../_snippets/alphanet.mdx";

# Some extended examples

For these examples, assume you have the following data and functions available:

<AlphaNet />

```typescript
// a constant for my type.
const myType = `${packageId}::my_module::MyStruct<${packageId}::my_coin_module::MyCoin>`;
// a constant for another type.
const otherType = `${packageId}::other_module::OtherStruct<${packageId}::other_coin_module::OtherCoin>`;

// initialize a kioskClient.
const kioskClient = new KioskClient({
    client: new IotaClient({
        url: getFullnodeUrl('mainnet'),
    }),
    network: Network.MAINNET,
});
```

## Minting a MyCoin

This example demonstrates how to mint a MyCoin.

```typescript
async function mintFren(address: string) {
    const { kioskOwnerCaps } = await kioskClient.getOwnedKiosks({ address });

    // Choose the first kiosk for simplicity. We could have extra logic here (e.g. let the user choose, pick a personal one, etc).
    const cap = kioskOwnerCaps[0];

    const txb = new TransactionBlock();
    const kioskTx = new KioskTransaction({ transactionBlock: txb, kioskClient, cap });

    // We're mixing the logic here. If the cap is undefined, we create a new kiosk.
    if (!cap) kioskTx.create();

    // Let's mint a MyCoin here into the kiosk (either a new or an existing one).
    txb.moveCall({
        target: `${packageId}::my_module::mint_app::mint`,
        arguments: [kioskTx.getKiosk(), kioskTx.getKioskCap()],
        typeArguments: [myType],
    });

    // If we don't have a cap, that means we create a new kiosk for the user in this flow.
    if (!cap) kioskTx.shareAndTransferCap(address);

    kioskTx.finalize();

    // sign and execute transaction block.
    await signAndExecuteTransactionBlock({ tx: txb });
}
```

## Mixing two MyCoins

This example demonstrates how to use the Kiosk SDK to mix two `bullsharks`.

```typescript
// We're mixing two frens.
async function mixFrens(firstFrenObjectId: string, secondFrenObjectId: string, cap: KioskOwnerCap) {
    const txb = new TransactionBlock();
    const kioskTx = new KioskTransaction({ transactionBlock: txb, kioskClient, cap });

    // borrow both frens.
    const [fren1, promise1] = kioskTx.borrow({
        itemType: bullsharkType,
        itemId: firstFrenObjectId.
    });

    const [fren2, promise2] = kioskTx.borrow({
        itemType: bullsharkType,
        itemId: secondFrenObjectId.
    });

    // Let's call the mix function. We skip any payment related stuff here.
    txb.moveCall({
        target: `${packageId}::mix_app::mix`,
        arguments: [
            fren1,
            fren2,
            kioskTx.getKiosk(),
            kioskTx.getKioskCap(),
        ]
        typeArguments: [bullsharkType],
    });

    kioskTx.return({
        itemType: bullsharkType,
        item: fren1,
        promise: promise1
    })
    .return({
        itemType: bullsharkType,
        item: fren2,
        promise: promise2
    }).finalize();

    // sign and execute transaction block.
    await signAndExecuteTransactionBlock({ tx: txb });
}
```
