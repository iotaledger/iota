---
title: Collections
description: The IOTA framework provides several modules you can use to work with groups of data.
---

Collections provide a convenient way to work with groups of data. The IOTA framework provides several modules that provide collection logic:

## bag

A bag is a heterogeneous map-like collection. The collection is similar to `iota::table` in that its keys and values are not stored within the Bag value, but instead are stored using IOTA's object system. The Bag struct acts only as a handle into the object system to retrieve those keys and values. This means that Bag values with exactly the same key-value mapping will not be equal, with ==, at runtime.

To learn more, see [Table and Bag](../objects/dynamic-fields/tables-bags.mdx) or the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/bag.md) on GitHub.

## dynamic_field

In addition to the fields declared in its type definition, a IOTA object can have dynamic fields that can be added after the object has been constructed. Unlike ordinary field names (which are always statically declared identifiers) a dynamic field name can be any value with the copy, drop, and store abilities (for example, an integer, a boolean, or a string). This gives IOTA programmers the flexibility to extend objects on-the-fly, and it also serves as a building block for core collection types.

To learn more, see [Dynamic Fields](../objects/dynamic-fields/dynamic-fields.mdx) or the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/dynamic_field.md) on GitHub.

## dynamic_object_field

Similar to `iota::dynamic_field`, this module allows for the access of dynamic fields. But unlike, `iota::dynamic_field` the values bound to these dynamic fields must be objects themselves. This allows for the objects to still exist within storage, which may be important for external tools. The difference is otherwise not observable from within Move.

To learn more, see [Dynamic Fields](../objects/dynamic-fields/dynamic-fields.mdx) or the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/dynamic_object_field.md) on GitHub.

## linked_table

Similar to `iota::table` but the values are linked together, allowing for ordered insertion and removal.

To learn more, see the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/linked_table.md) on GitHub.

## object_bag

Similar to `iota::bag`, an `ObjectBag` is a heterogeneous map-like collection. But unlike `iota::bag`, the values bound to these dynamic fields must be objects themselves. This allows for the objects to still exist in storage, which might be important for external tools. The difference is otherwise not observable from within Move.

To learn more, see [Table and Bag](../objects/dynamic-fields/tables-bags.mdx) or the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/object_bag.md) on GitHub.

## object_table

Similar to `iota::table`, an `ObjectTable<K, V>` is a map-like collection. But unlike `iota::table`, the values bound to these dynamic fields must be objects themselves. This allows for the objects to still exist within in storage, which may be important for external tools. The difference is otherwise not observable from within Move.

To learn more, see [Table and Bag](../objects/dynamic-fields/tables-bags.mdx) or the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/object_table.md) on GitHub.

## priority_queue

Priority queue implemented using a max heap.

To learn more, see the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/priority_queue.md) on GitHub.

## table

A table is a map-like collection. But unlike a traditional collection, its keys and values are not stored within the Table value, but instead are stored using IOTA's object system. The Table struct acts only as a handle into the object system to retrieve those keys and values. Note that this means that Table values with exactly the same key-value mapping will not be equal, with ==, at runtime.

To learn more, see [Table and Bag](../objects/dynamic-fields/tables-bags.mdx) or the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/table.md) on GitHub.

## table_vec

A basic scalable vector library implemented using Table.

To learn more, see the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/table_vec.md) on GitHub.

## vec_map

A map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries are not sorted by key--entries are included in insertion order. All operations are O(N) in the size of the map--the intention of this data structure is only to provide the convenience of programming against a map API. Large maps should use handwritten parent/child relationships instead. Maps that need sorted iteration rather than insertion order iteration should also be handwritten.

To learn more, see the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/vec_map.md) on GitHub.

## vec_set

The main object for `vec_set` is a set data structure backed by a vector. The set is guaranteed not to contain duplicate keys. All operations are O(N) in the size of the set. The intention of this data structure is only to provide the convenience of programming against a set API. Sets that need sorted iteration rather than insertion order iteration should be handwritten.

To learn more, see the [framework definition](https://github.com/iotaledger/iota/blob/develop/crates/iota-framework/docs/iota-framework/vec_set.md) on GitHub.


