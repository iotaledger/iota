---
 title: Claiming Alias Outputs
---

An address can own `AliasOutput` objects only if before the migration it was set as the Alias Governor Address. 
In this case, the `AliasOutput` object is an owned object in the ledger and its owner is the Governor address.
Such address can be directly controlled by a user or by another object (either an `Alias` or `Nft` object). For the latter use case, check the [`Claiming an Output unlockable by an Alias/Nft Address`](address-unlock-condition.mdx) example.

## Claim of an Alias Output

A Governor address can claim the `AliasOutput` assets at any time:

1. The first step is to fetch an `AliasOutput` object needed to be claimed.

<Tabs groupId="code-language">
<TabItem value="rust" label="Rust">

```rust file=<rootDir>/docs/examples/rust/stardust/alias-output-claim.rs#L56-L81
```

</TabItem>
<TabItem value="typescript"  label="TypeScript">

</TabItem>
</Tabs>


2. Then we check the native tokens that were possibly held by this output.
A [`Bag`](../../../references/framework/iota-framework/bag) is used for holding these tokens, so in this step we are interested in obtaining the dynamic field keys that are bag indexes.
In the case of the native tokens, the keys are strings representing the [`OTW`](../../iota-101/iota-move-concepts/one-time-witness.mdx) used for the native token declaration.

<Tabs groupId="code-language">
<TabItem value="rust" label="Rust">

```rust file=<rootDir>/docs/examples/rust/stardust/alias-output-claim.rs#L83-L110
```

</TabItem>
<TabItem value="typescript"  label="TypeScript">

</TabItem>
</Tabs>

3. Finally, a PTB can be created using the `alias_output_object_ref` as input and the native token keys.
An `AliasOutput` is different from an `NftOutput` or a `BasicOutput` as it contains the `Alias` object.
In fact, the main purpose of claiming is extracting the `Alias` object from the `AliasOutput`.

<Tabs groupId="code-language">
<TabItem value="rust" label="Rust">

```rust file=<rootDir>/docs/examples/rust/stardust/alias-output-claim.rs#L112-L180
```

</TabItem>
<TabItem value="typescript"  label="TypeScript">

</TabItem>
</Tabs>

## Conversion of an Alias Output into a custom Object

We need to have a custom package prepared that contains a logic for converting an `Alias` into a new entity usable for your project. 

In Stardust, an alias can be used for different purposes. One of them is acting as an NFT collection controller.
In the following, an example of the process of converting a Stardust `Alias` into a `CollectionControllerCap` is outlined.

The following example extends the one described in the [Conversion of an Nft Output into a custom Nft](nft.mdx#conversion-of-an-nft-output-into-a-custom-nft) documentation:

<Tabs groupId="code-language">
<TabItem value="move" label="Move">

The `collection.move` module extends the `custom_nft` package to make it possible to work with NFT collections:

```move file=<rootDir>/docs/examples/move/custom_nft/sources/collection.move
```

Also, the `nft.move` module was extended with the following function:

```move file=<rootDir>/docs/examples/move/custom_nft/sources/nft.move#L82-L97
```

</TabItem>

</Tabs>

Once the package is prepared, we can extract and use a Stardust `Alias` in a single transaction to create a `CollectionControllerCap`.
This capability is then used in later transactions for managing new collections.

<Tabs groupId="code-language">
<TabItem value="rust" label="Rust">

```rust file=<rootDir>/docs/examples/rust/stardust/alias-migration.rs#L119-L244
```

</TabItem>
<TabItem value="typescript"  label="TypeScript">

</TabItem>
</Tabs>

