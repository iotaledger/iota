---
title: Create Review Rating DAO with Multisig Tutorial
---

## Introduction

The example illustrates the creation of a review rating platform for the food service industry, utilizing multisignature functionality on IOTA. Unlike conventional review platforms, which frequently conceal the algorithms used to rate reviews, this model leverages a transparent, on-chain algorithm that anyone can access and verify. IOTA's low transaction costs make it economically viable to submit, evaluate, and rank all reviews directly on-chain.

**Multisig Setup for Moderators**: The platform uses a multisig account to ensure that key actions like removing inappropriate reviews or approving reward distributions are authorized by multiple trusted moderators.

## Personas

There are four actors in the typical workflow of the Reviews Rating example.

- Service: Review requester.
- Dashboard: Review hub.
- Reviewer: Review creator.
- Moderator: Review list editor.

```mermaid
sequenceDiagram
  Service ->> Dashboard: Add service to dashboard
  Service ->> Reviewer: Send proof of experience
  Reviewer ->> Service: Send review
  Service ->> Reviewer: Send reward
  Review reader ->> Service: Vote on review
  Moderator (multisig) ->> Service: Remove abused review
```

### Service Owners

Service owners, such as restaurants, list their offerings on the platform with the goal of attracting more customers through positive reviews. To incentivize this, they set aside a specific amount of IOTA in a reward pool. This pool is used to reward reviewers who provide high-rated feedback. A proof of experience (PoE) NFT serves as confirmation that a reviewer has used the service, and this NFT can later be burned to submit a verified review. Service owners issue unique identifiers, possibly through QR codes, to link reviews to individual customers.

### Reviewers

Reviewers are customers who utilize the platform to share their experiences. They provide feedback through comments that highlight particular aspects of the service, along with a star rating to guide others. Reviews are evaluated, with the most helpful ones receiving the highest ratings. The top 10 highest-rated reviews for each service receive rewards from the service owner. The frequency of reward distribution is determined by the service owner, such as weekly or monthly disbursements.

### Review Readers

Review readers use the platform to access feedback, helping them make informed decisions when choosing services. They contribute by voting on reviews, and these votes influence the algorithm that ranks the reviews. Authors of the highest-rated reviews are rewarded based on this ranking. Although not part of this guide, the system could be expanded to reward readers for participating by casting votes on reviews.

### Moderators (Multisig)

Moderators operate within a multisignature setup, ensuring that significant actions, such as removing reviews or distributing rewards, require authorization from multiple parties. This approach enhances security and transparency, as decisions are made collectively, promoting accountability in the moderation process. Moderators review the content and have the authority to remove reviews containing inappropriate material.

While this guide does not include an incentive mechanism for moderators, service owners could contribute to a pool that compensates moderators on a rolling basis. Additionally, a staking system could be introduced where individuals stake tokens to influence the distribution of rewards among moderators, similar to how validators are staked on-chain. Moderator decisions would be based on a quorum determined by the weight of the staked tokens, creating incentives for moderators to carry out their duties effectively.

Moderators operate within a multisig setup, ensuring key actions like removing inappropriate reviews or distributing rewards require authorization from multiple parties. This enhances platform security, promotes collective decision-making, and provides transparency.

#### Creating a Multisig for Moderators

To implement multisig for moderators, follow these steps:

**Step 1: Create Keys for Each Moderator**
Each moderator needs a unique key. To generate these keys, use the following commands to create an IOTA address and corresponding key for each moderator:

```shell
iota client new-address ed25519
iota client new-address secp256k1
iota client new-address secp256r1
```
**Step 2: Add Keys to IOTA Keystore**

```shell
iota keytool list
```
This command will list the generated keys with their corresponding addresses and public keys.

**Step 3: Create a Multisig Address**
Create the multisig address by combining the public keys of all moderators and setting their weights and a threshold:

```shell
iota keytool multi-sig-address --pks <PUBLIC-KEY-1> <PUBLIC-KEY-2> <PUBLIC-KEY-3> --weights 1 1 1 --threshold 2
```
This command sets up a multisig address where at least two out of the three keys must sign to authorize a transaction.

**Step 4: Moderator Multisig Transaction Workflow**
To remove a review, moderators must sign a transaction using the multisig setup. The transaction will require signatures from two out of the three moderators to be executed.

**Step 5: Serialize a Transaction**
Serialize the transaction to be signed by the multisig account:

```shell
iota client transfer --to <IOTA-ADDRESS> --object-id <OBJECT-ID> --gas-budget <GAS-AMOUNT> --serialize-unsigned-transaction
```

**Step 6: Sign the Transaction**
Each moderator signs the serialized transaction:

```shell
iota keytool sign --address <IOTA-ADDRESS> --data <TX_BYTES>
```

**Step 7: Combine Signatures**
Once two moderators have signed, combine their signatures into a single multisig signature:

```shell
iota keytool multi-sig-combine-partial-sig --pks <PUBLIC-KEY-1> <PUBLIC-KEY-2> --weights 1 1 1 --threshold 2 --sigs <SIGNATURE-1> <SIGNATURE-2>
```
**Step 8: Execute the Multisig Transaction**
Finally, execute the multisig transaction using the combined signatures:

```shell
iota client execute-signed-tx --tx-bytes <TX_BYTES> --signatures <SERIALIZED-MULTISIG>
```
The transaction will now be processed, and the review will be removed from the platform.
This multisig setup ensures that no single moderator can act unilaterally, thus maintaining fairness and accountability on the platform.

:::info

See how to create a [Multisig](../cryptography/transaction-auth/multisig.mdx) transactions.
:::

## How reviews are scored

The reviews are scored on chain using the following criteria:

- Intrinsic score (IS): Length of review content.
- Extrinsic score (ES): Number of votes a review receives.
- Verification multiplier (VM): Reviews with PoE receive a multiplier to improve rating.

```
Total Score = (IS + ES) * VM
```

## Smart Contracts

There are several modules that create the backend logic for the example.

### Dashboard.move

The `dashboard.move` module defines the `Dashboard` struct that groups services.

```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/dashboard.move#L11-L15
```


The services are grouped by attributes, which can be cuisine type, geographical location, operating hours, Google Maps ID, and so on. To keep it basic, the example stores only `service_type` (for example, fast food, Chinese, Italian).

```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/dashboard.move#L17-L27

```

A `Dashboard` is a [shared object](../iota-101/objects/object-ownership/shared.mdx), so any service owner can register their service to a dashboard.
A service owner should look for dashboards that best match their service attribute and register.
A [dynamic field](../iota-101/objects/dynamic-fields/dynamic-fields.mdx) stores the list of services that are registered to a dashboard.
A service may be registered to multiple dashboards at the same time. For example, a Chinese-Italian fusion restaurant may be registered to both the Chinese and Italian dashboards.

#### Code Explanation

`create_dashboard` Function:
- **Purpose**: This function creates a new `Dashboard` for a specific service type.
- **Parameters**:
    - **`service_type: String`**: A string representing the type of service the dashboard is created for.
    - **`ctx: &mut TxContext`**: A mutable reference to the transaction context, used to generate unique IDs and manage the transaction environment.
- **Process**:
    - A new `Dashboard` is created with an ID generated by `object::new(ctx)`, and the `service_type` is stored.
    - The `Dashboard` object is then shared with others using `transfer::share_object(db)`, making it accessible for further use.

`register_service` Function:
- **Purpose**: This function registers a service to an existing `Dashboard`.
- **Parameters**:
    - **`db: &mut Dashboard`**: A mutable reference to the `Dashboard` to which the service is being registered.
    - **`service_id: ID`**: The unique identifier of the service being registered.
- **Process**:
    - The function adds the `service_id` to the `Dashboard`'s list of services by invoking `df::add(&mut db.id, service_id, service_id)`.
    - The `df::add` function associates the `service_id` with the dashboard's `id`, effectively linking the service to the dashboard.


:::info

See [Shared versus Owned Objects](../iota-101/objects/object-ownership/shared.mdx) for more information on the differences between object types.

:::

### Review.move

This module defines the `Review` struct.

```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/review.move#L16-L33
```
```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/review.move#L81-L84
```
```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/review.move#L72-L79
```

In addition to the content of a review, all the elements that are required to compute total score are stored in a `Review` object.

A `Review` is a [shared object](../iota-101/objects/object-ownership/shared.mdx), so anyone can cast a vote on a review and update its `total_score` field.
After `total_score` is updated, the [`update_top_reviews`](#casting-votes) function can be called to update the `top_reviews` field of the `Service` object.

#### Code Explanation

`Review` Struct:

- **`id: UID`**: Unique identifier for the review.
- **`owner: address`**: Address of the review owner.
- **`service_id: ID`**: Identifier of the reviewed service.
- **`content: String`**: The content of the review.
- **`len: u64`**: Represents the length of the review content, considered the *intrinsic score*.
- **`votes: u64`**: Number of upvotes or endorsements for the review, considered the *extrinsic score*.
- **`time_issued: u64`**: Timestamp when the review was written.
- **`has_poe: bool`**: A boolean flag indicating if the reviewer has proof of experience (PoE), which can affect the review's weight.
- **`total_score: u64`**: The overall calculated score of the review.
- **`overall_rate: u8`**: The overall rating given in the review.

`update_total_score` Function:

- This function updates the `total_score` of the review by calling the `calculate_total_score` function.

`calculate_total_score` Function:

- This function calculates the `total_score` based on both intrinsic and extrinsic factors.
    - **`intrinsic_score`**: The score based on the length of the review (`len`). It is capped at 150 using `math::min`.
    - **`extrinsic_score`**: The score based on the number of votes, with each vote contributing 10 points.
    - **VM (Vote Multiplier)**: If the reviewer has proof of experience (`has_poe` is `true`), the score is multiplied by 2; otherwise, it's multiplied by 1.
- The total score is the sum of the intrinsic and extrinsic scores, multiplied by the VM factor.

### Service.move

This module defines the `Service` struct that service owners manage.

```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/service.move#L31-L39
```

### Reward Distribution

The same amount is rewarded to top reviewers, and the reward is distributed to 10 participants at most.
The pool of `IOTA` tokens to be distributed to reviewers is stored in the `reward_pool` field, and the amount of `IOTA` tokens awarded to each participant is configured in `reward` field.

### Storage for Reviews

Because anyone can submit a review for a service, `Service` is defined as a shared object. All the reviews are stored in the `reviews` field, which has [ObjectTable](../iota-101/move-overview/collections.mdx)`<ID, Review>` type. The `reviews` are stored as children of the shared object, but they are still accessible by their `ID`.
In other words, anyone can go to a transaction explorer and find a review object by its object ID, but they won't be able to use a review as an input to a transaction by its object ID.


The top rated reviews are stored in `top_reviews` field, which has `vector<ID>` type. A simple vector can store the top rated reviews because the maximum number of reviews that can be rewarded is 10.
The elements of `top_reviews` are sorted by the `total_score` of the reviews, with the highest rated reviews coming first. The vector contains the `ID` of the reviews, which can be used to retrieve content and vote count from the relevant `reviews`.

### Casting Votes

A reader can cast a vote on a review to rate it as follows:

```move file=<rootDir>/docs/examples/move/review_rating_dao_with_multisig/sources/service.move#L82-L132
```

#### Code Explanation

`upvote` Function:
- **Purpose**: This function upvotes a review and reorders the top reviews list.
- **Parameters**:
    - **`service: &mut Service`**: A mutable reference to the `Service` that contains the reviews.
    - **`review_id: ID`**: The unique identifier of the review being upvoted.
- **Process**:
    - Retrieves the review from `service.reviews` using the `review_id`.
    - Calls the `upvote()` method on the review to increment its upvote count.
    - Calls `service.reorder(review_id, review.get_total_score())` to reorder the list of top reviews based on the updated total score of the review.

`reorder` Function:
- **Purpose**: This function reorders the `top_reviews` list after a review is updated.
- **Parameters**:
    - **`service: &mut Service`**: A mutable reference to the `Service` whose `top_reviews` list is being reordered.
    - **`review_id: ID`**: The unique identifier of the review being reordered.
    - **`total_score: u64`**: The updated total score of the review.
- **Process**:
    - Checks if the `review_id` is already in the `top_reviews` list by calling `service.top_reviews.index_of(&review_id)`, which returns whether the review is present (`contains`) and its index (`idx`).
    - If the review is not in `top_reviews`, it calls `service.update_top_reviews(review_id, total_score)` to add the review if it qualifies.
    - If the review is already in `top_reviews`, it removes the review from its current position, finds the new correct position using `service.find_idx(total_score)`, and reinserts it at the correct position.

`update_top_reviews` Function:
- **Purpose**: This function updates the `top_reviews` list by inserting a review if it qualifies for the top 10.
- **Parameters**:
    - **`service: &mut Service`**: A mutable reference to the `Service`.
    - **`review_id: ID`**: The unique identifier of the review to be added.
    - **`total_score: u64`**: The total score of the review.
- **Process**:
    - Checks if the review should be added to `top_reviews` by calling `service.should_update_top_reviews(total_score)`.
    - If it qualifies, the appropriate insertion index is found by calling `service.find_idx(total_score)`.
    - The review is inserted at the calculated index, and `service.prune_top_reviews()` is called to ensure the list doesn’t exceed the maximum allowed number of top reviews.

`find_idx` Function:
- **Purpose**: This function finds the correct index to insert a review into the `top_reviews` list based on its total score.
- **Parameters**:
    - **`service: &Service`**: A reference to the `Service` that contains the `top_reviews`.
    - **`total_score: u64`**: The total score of the review.
- **Process**:
    - Loops through the `top_reviews` list in reverse order (from highest score to lowest) and compares the `total_score` of the current review with those already in the list.
    - The loop stops when it finds a review in the list with a higher score than the new review. The appropriate index (`i`) for insertion is then returned.

`prune_top_reviews` Function:
- **Purpose**: This function ensures that the `top_reviews` list does not exceed the allowed number of reviews to reward.
- **Parameters**:
    - **`service: &mut Service`**: A mutable reference to the `Service`.
- **Process**:
    - Checks if the length of `top_reviews` exceeds `MAX_REVIEWERS_TO_REWARD`.
    - If the list is too long, the review with the lowest score (the last entry) is removed by calling `service.top_reviews.pop_back()`.

Whenever someone casts a vote on a review, the `total_score` of the review is updated and the `update_top_reviews` function updates the `top_reviews` field, as needed.
Casting a vote also triggers a reordering of the `top_reviews` field to ensure that the top rated reviews are always at the top.

### Authorization

```move
    /// A capability that can be used to perform admin operations on a service
    struct AdminCap has key, store {
        id: UID,
        service_id: ID
    }

    /// Represents a moderator that can be used to delete reviews
    struct Moderator has key {
        id: UID,
    }
```

This example follows a capabilities pattern to manage authorizations.
For example, `SERVICE OWNERS` are given `AdminCap` and `MODERATORS` are given `Moderator` such that only they are allowed to perform privileged operations.

To learn more about the capabilities pattern, see [The Move Book](https://move-book.com/programmability/capability.html).

## Conclusion

This tutorial explains how to build a decentralized review rating platform using multisig on IOTA. Service owners can list their services, while reviewers provide feedback that is rated by readers. Moderators maintain quality control, ensuring that only appropriate reviews remain. Reviews are scored based on their content, upvotes, and proof of experience (PoE), with top reviews earning rewards. The multisig setup enhances security, as key actions like removing reviews or distributing rewards require approval from multiple parties. By storing the review algorithm and data on-chain using Move-based smart contracts, the platform guarantees transparency and fairness.