---
title: Debugging
description: Move does not have a native debugger. You can, however, use the std::debug module to monitor variable values while your code executes.
---

Move does not currently have a native debugger. You can use the `std::debug` module, however, to print arbitrary values to the console. Monitoring variable values in this manner can provide insight into the logic of your modules. To do so, first import the debug module in your source file:

```move
use std::debug;
```

Then in places where you want to print out a value `v`, regardless of its type, add the following code:

```move
debug::print(&v);
```

or the following if `v` is already a reference:

```move
debug::print(v);
```

The debug module also provides a function to print out the current stacktrace:

```move
debug::print_stack_trace();
```

Alternatively, any call to abort or assertion failure also prints the stacktrace at the point of failure.

## Using debug in my_module

To see the module in action, update your `my_module` code to include debug calls. Specifically, update the `new_sword` function so that you print the value of `forge` before and after updating `swords_created`. Also, include a `print_stack_trace` so that the function looks like the following:

```move
/// Constructor for creating swords.
public fun new_sword(forge: &mut Forge, magic: u64, strength: u64, ctx: &mut TxContext): Sword {
    debug::print(forge);

    // Increment the `swords_created` counter.
    forge.swords_created = forge.swords_created + 1;

    debug::print(forge);
    debug::print_stack_trace();

    // Create a sword.
    Sword {
        id: object::new(ctx),
        magic: magic,
        strength: strength,
    }
}
```

To see the results, run the module's tests.

```shell
$ iota move test test_sword_transactions
```

The response prints out the expected results as the test calls the `new_sword` function.

```shell
INCLUDING DEPENDENCY Iota
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
Running Move unit tests
[debug] 0x0::my_module::Forge {
  id: 0x2::object::UID {
    id: 0x2::object::ID {
      bytes: @<OBJECT-ID>
    }
  },
  swords_created: 0
}
[debug] 0x0::my_module::Forge {
  id: 0x2::object::UID {
    id: 0x2::object::ID {
      bytes: @<OBJECT-ID>
    }
  },
  swords_created: 1
}
Call Stack:
    [0] 0000000000000000000000000000000000000000000000000000000000000000::my_module::test_sword_transactions

        Code:
            [24] LdU64(7)
            [25] CopyLoc(5)
            [26] Call(13)
          > [27] Call(6)
            [28] CopyLoc(4)
            [29] CallGeneric(2)
            [30] CopyLoc(5)

        Locals:
            [0] -
            [1] -
            [2] 000000000000000000000000000000000000000000000000000000000000face
            [3] { { { <OBJECT-ID-WITHOUT-0x> } }, 1 }
            [4] 000000000000000000000000000000000000000000000000000000000000cafe
            [5] (&) { 1, { 000000000000000000000000000000000000000000000000000000000000babe, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 0, 0 } }
            [6] { 1, { 000000000000000000000000000000000000000000000000000000000000babe, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 0, 0 } }
            [7] -


Operand Stack:

[ PASS    ] 0x0::my_module::test_sword_transactions
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

## Related links

- [Publish a Package](publish.mdx): Publish the example to the IOTA network.