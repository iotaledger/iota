---
title: Module `0x3::iota_system_state_inner`
---
import Link from '@docusaurus/Link';

<Link id="0x3_iota_system_state_inner"/>


-  [Struct `SystemParameters`](#0x3_iota_system_state_inner_SystemParameters)
-  [Struct `SystemParametersV2`](#0x3_iota_system_state_inner_SystemParametersV2)
-  [Struct `IotaSystemStateInner`](#0x3_iota_system_state_inner_IotaSystemStateInner)
-  [Struct `IotaSystemStateInnerV2`](#0x3_iota_system_state_inner_IotaSystemStateInnerV2)
-  [Struct `SystemEpochInfoEvent`](#0x3_iota_system_state_inner_SystemEpochInfoEvent)
-  [Constants](#@Constants_0)
-  [Function `create`](#0x3_iota_system_state_inner_create)
-  [Function `create_system_parameters`](#0x3_iota_system_state_inner_create_system_parameters)
-  [Function `v1_to_v2`](#0x3_iota_system_state_inner_v1_to_v2)
-  [Function `request_add_validator_candidate`](#0x3_iota_system_state_inner_request_add_validator_candidate)
-  [Function `request_remove_validator_candidate`](#0x3_iota_system_state_inner_request_remove_validator_candidate)
-  [Function `request_add_validator`](#0x3_iota_system_state_inner_request_add_validator)
-  [Function `request_remove_validator`](#0x3_iota_system_state_inner_request_remove_validator)
-  [Function `request_set_gas_price`](#0x3_iota_system_state_inner_request_set_gas_price)
-  [Function `set_candidate_validator_gas_price`](#0x3_iota_system_state_inner_set_candidate_validator_gas_price)
-  [Function `request_set_commission_rate`](#0x3_iota_system_state_inner_request_set_commission_rate)
-  [Function `set_candidate_validator_commission_rate`](#0x3_iota_system_state_inner_set_candidate_validator_commission_rate)
-  [Function `request_add_stake`](#0x3_iota_system_state_inner_request_add_stake)
-  [Function `request_add_stake_mul_coin`](#0x3_iota_system_state_inner_request_add_stake_mul_coin)
-  [Function `request_withdraw_stake`](#0x3_iota_system_state_inner_request_withdraw_stake)
-  [Function `report_validator`](#0x3_iota_system_state_inner_report_validator)
-  [Function `undo_report_validator`](#0x3_iota_system_state_inner_undo_report_validator)
-  [Function `report_validator_impl`](#0x3_iota_system_state_inner_report_validator_impl)
-  [Function `undo_report_validator_impl`](#0x3_iota_system_state_inner_undo_report_validator_impl)
-  [Function `rotate_operation_cap`](#0x3_iota_system_state_inner_rotate_operation_cap)
-  [Function `update_validator_name`](#0x3_iota_system_state_inner_update_validator_name)
-  [Function `update_validator_description`](#0x3_iota_system_state_inner_update_validator_description)
-  [Function `update_validator_image_url`](#0x3_iota_system_state_inner_update_validator_image_url)
-  [Function `update_validator_project_url`](#0x3_iota_system_state_inner_update_validator_project_url)
-  [Function `update_validator_next_epoch_network_address`](#0x3_iota_system_state_inner_update_validator_next_epoch_network_address)
-  [Function `update_candidate_validator_network_address`](#0x3_iota_system_state_inner_update_candidate_validator_network_address)
-  [Function `update_validator_next_epoch_p2p_address`](#0x3_iota_system_state_inner_update_validator_next_epoch_p2p_address)
-  [Function `update_candidate_validator_p2p_address`](#0x3_iota_system_state_inner_update_candidate_validator_p2p_address)
-  [Function `update_validator_next_epoch_primary_address`](#0x3_iota_system_state_inner_update_validator_next_epoch_primary_address)
-  [Function `update_candidate_validator_primary_address`](#0x3_iota_system_state_inner_update_candidate_validator_primary_address)
-  [Function `update_validator_next_epoch_worker_address`](#0x3_iota_system_state_inner_update_validator_next_epoch_worker_address)
-  [Function `update_candidate_validator_worker_address`](#0x3_iota_system_state_inner_update_candidate_validator_worker_address)
-  [Function `update_validator_next_epoch_protocol_pubkey`](#0x3_iota_system_state_inner_update_validator_next_epoch_protocol_pubkey)
-  [Function `update_candidate_validator_protocol_pubkey`](#0x3_iota_system_state_inner_update_candidate_validator_protocol_pubkey)
-  [Function `update_validator_next_epoch_worker_pubkey`](#0x3_iota_system_state_inner_update_validator_next_epoch_worker_pubkey)
-  [Function `update_candidate_validator_worker_pubkey`](#0x3_iota_system_state_inner_update_candidate_validator_worker_pubkey)
-  [Function `update_validator_next_epoch_network_pubkey`](#0x3_iota_system_state_inner_update_validator_next_epoch_network_pubkey)
-  [Function `update_candidate_validator_network_pubkey`](#0x3_iota_system_state_inner_update_candidate_validator_network_pubkey)
-  [Function `advance_epoch`](#0x3_iota_system_state_inner_advance_epoch)
-  [Function `epoch`](#0x3_iota_system_state_inner_epoch)
-  [Function `protocol_version`](#0x3_iota_system_state_inner_protocol_version)
-  [Function `system_state_version`](#0x3_iota_system_state_inner_system_state_version)
-  [Function `genesis_system_state_version`](#0x3_iota_system_state_inner_genesis_system_state_version)
-  [Function `epoch_start_timestamp_ms`](#0x3_iota_system_state_inner_epoch_start_timestamp_ms)
-  [Function `validator_stake_amount`](#0x3_iota_system_state_inner_validator_stake_amount)
-  [Function `validator_staking_pool_id`](#0x3_iota_system_state_inner_validator_staking_pool_id)
-  [Function `validator_staking_pool_mappings`](#0x3_iota_system_state_inner_validator_staking_pool_mappings)
-  [Function `get_reporters_of`](#0x3_iota_system_state_inner_get_reporters_of)
-  [Function `get_storage_fund_total_balance`](#0x3_iota_system_state_inner_get_storage_fund_total_balance)
-  [Function `get_storage_fund_object_rebates`](#0x3_iota_system_state_inner_get_storage_fund_object_rebates)
-  [Function `pool_exchange_rates`](#0x3_iota_system_state_inner_pool_exchange_rates)
-  [Function `active_validator_addresses`](#0x3_iota_system_state_inner_active_validator_addresses)
-  [Function `extract_coin_balance`](#0x3_iota_system_state_inner_extract_coin_balance)


<pre><code>
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../iota-framework/bag#0x2_bag">0x2::bag</Link>;
<b>use</b> <Link to="../iota-framework/balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link to="../iota-framework/coin#0x2_coin">0x2::coin</Link>;
<b>use</b> <Link to="../iota-framework/event#0x2_event">0x2::event</Link>;
<b>use</b> <Link to="../iota-framework/iota#0x2_iota">0x2::iota</Link>;
<b>use</b> <Link to="../iota-framework/object#0x2_object">0x2::object</Link>;
<b>use</b> <Link to="../iota-framework/pay#0x2_pay">0x2::pay</Link>;
<b>use</b> <Link to="../iota-framework/table#0x2_table">0x2::table</Link>;
<b>use</b> <Link to="../iota-framework/transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link to="../iota-framework/tx_context#0x2_tx_context">0x2::tx_context</Link>;
<b>use</b> <Link to="../iota-framework/vec_map#0x2_vec_map">0x2::vec_map</Link>;
<b>use</b> <Link to="../iota-framework/vec_set#0x2_vec_set">0x2::vec_set</Link>;
<b>use</b> <Link to="stake_subsidy#0x3_stake_subsidy">0x3::stake_subsidy</Link>;
<b>use</b> <Link to="staking_pool#0x3_staking_pool">0x3::staking_pool</Link>;
<b>use</b> <Link to="storage_fund#0x3_storage_fund">0x3::storage_fund</Link>;
<b>use</b> <Link to="validator#0x3_validator">0x3::validator</Link>;
<b>use</b> <Link to="validator_cap#0x3_validator_cap">0x3::validator_cap</Link>;
<b>use</b> <Link to="validator_set#0x3_validator_set">0x3::validator_set</Link>;
</code></pre>



<Link id="0x3_iota_system_state_inner_SystemParameters"></Link>

## Struct `SystemParameters`

A list of system config parameters.


<pre><code>
<b>struct</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">SystemParameters</Link> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
epoch_duration_ms: u64</code>
</dt>
<dd>
 The duration of an epoch, in milliseconds.
</dd>
<dt>
<code>
stake_subsidy_start_epoch: u64</code>
</dt>
<dd>
 The starting epoch in which stake subsidies start being paid out
</dd>
<dt>
<code>
max_validator_count: u64</code>
</dt>
<dd>
 Maximum number of active validators at any moment.
 We do not allow the number of validators in any epoch to go above this.
</dd>
<dt>
<code>
min_validator_joining_stake: u64</code>
</dt>
<dd>
 Lower-bound on the amount of stake required to become a validator.
</dd>
<dt>
<code>
validator_low_stake_threshold: u64</code>
</dt>
<dd>
 Validators with stake amount below <code>
validator_low_stake_threshold</code> are considered to
 have low stake and will be escorted out of the validator set after being below this
 threshold for more than <code>
validator_low_stake_grace_period</code> number of epochs.
</dd>
<dt>
<code>
validator_very_low_stake_threshold: u64</code>
</dt>
<dd>
 Validators with stake below <code>
validator_very_low_stake_threshold</code> will be removed
 immediately at epoch change, no grace period.
</dd>
<dt>
<code>
validator_low_stake_grace_period: u64</code>
</dt>
<dd>
 A validator can have stake below <code>
validator_low_stake_threshold</code>
 for this many epochs before being kicked out.
</dd>
<dt>
<code>
extra_fields: <Link to="../iota-framework/bag#0x2_bag_Bag">bag::Bag</Link></code>
</dt>
<dd>
 Any extra fields that's not defined statically.
</dd>
</dl>


</details>

<Link id="0x3_iota_system_state_inner_SystemParametersV2"></Link>

## Struct `SystemParametersV2`

Added min_validator_count.


<pre><code>
<b>struct</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParametersV2">SystemParametersV2</Link> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
epoch_duration_ms: u64</code>
</dt>
<dd>
 The duration of an epoch, in milliseconds.
</dd>
<dt>
<code>
stake_subsidy_start_epoch: u64</code>
</dt>
<dd>
 The starting epoch in which stake subsidies start being paid out
</dd>
<dt>
<code>
min_validator_count: u64</code>
</dt>
<dd>
 Minimum number of active validators at any moment.
</dd>
<dt>
<code>
max_validator_count: u64</code>
</dt>
<dd>
 Maximum number of active validators at any moment.
 We do not allow the number of validators in any epoch to go above this.
</dd>
<dt>
<code>
min_validator_joining_stake: u64</code>
</dt>
<dd>
 Lower-bound on the amount of stake required to become a validator.
</dd>
<dt>
<code>
validator_low_stake_threshold: u64</code>
</dt>
<dd>
 Validators with stake amount below <code>
validator_low_stake_threshold</code> are considered to
 have low stake and will be escorted out of the validator set after being below this
 threshold for more than <code>
validator_low_stake_grace_period</code> number of epochs.
</dd>
<dt>
<code>
validator_very_low_stake_threshold: u64</code>
</dt>
<dd>
 Validators with stake below <code>
validator_very_low_stake_threshold</code> will be removed
 immediately at epoch change, no grace period.
</dd>
<dt>
<code>
validator_low_stake_grace_period: u64</code>
</dt>
<dd>
 A validator can have stake below <code>
validator_low_stake_threshold</code>
 for this many epochs before being kicked out.
</dd>
<dt>
<code>
extra_fields: <Link to="../iota-framework/bag#0x2_bag_Bag">bag::Bag</Link></code>
</dt>
<dd>
 Any extra fields that's not defined statically.
</dd>
</dl>


</details>

<Link id="0x3_iota_system_state_inner_IotaSystemStateInner"></Link>

## Struct `IotaSystemStateInner`

The top-level object containing all information of the Iota system.


<pre><code>
<b>struct</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">IotaSystemStateInner</Link> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
epoch: u64</code>
</dt>
<dd>
 The current epoch ID, starting from 0.
</dd>
<dt>
<code>
protocol_version: u64</code>
</dt>
<dd>
 The current protocol version, starting from 1.
</dd>
<dt>
<code>
system_state_version: u64</code>
</dt>
<dd>
 The current version of the system state data structure type.
 This is always the same as IotaSystemState.version. Keeping a copy here so that
 we know what version it is by inspecting IotaSystemStateInner as well.
</dd>
<dt>
<code>
validators: <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link></code>
</dt>
<dd>
 Contains all information about the validators.
</dd>
<dt>
<code>
<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>: <Link to="storage_fund#0x3_storage_fund_StorageFund">storage_fund::StorageFund</Link></code>
</dt>
<dd>
 The storage fund.
</dd>
<dt>
<code>
parameters: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">iota_system_state_inner::SystemParameters</Link></code>
</dt>
<dd>
 A list of system config parameters.
</dd>
<dt>
<code>
reference_gas_price: u64</code>
</dt>
<dd>
 The reference gas price for the current epoch.
</dd>
<dt>
<code>
validator_report_records: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;</code>
</dt>
<dd>
 A map storing the records of validator reporting each other.
 There is an entry in the map for each validator that has been reported
 at least once. The entry VecSet contains all the validators that reported
 them. If a validator has never been reported they don't have an entry in this map.
 This map persists across epoch: a peer continues being in a reported state until the
 reporter doesn't explicitly remove their report.
 Note that in case we want to support validator address change in future,
 the reports should be based on validator ids
</dd>
<dt>
<code>
<Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>: <Link to="stake_subsidy#0x3_stake_subsidy_StakeSubsidy">stake_subsidy::StakeSubsidy</Link></code>
</dt>
<dd>
 Schedule of stake subsidies given out each epoch.
</dd>
<dt>
<code>
safe_mode: bool</code>
</dt>
<dd>
 Whether the system is running in a downgraded safe mode due to a non-recoverable bug.
 This is set whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode.
 It can be reset once we are able to successfully execute advance_epoch.
 The rest of the fields starting with <code>
safe_mode_</code> are accmulated during safe mode
 when advance_epoch_safe_mode is executed. They will eventually be processed once we
 are out of safe mode.
</dd>
<dt>
<code>
safe_mode_storage_rewards: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
safe_mode_computation_rewards: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
safe_mode_storage_rebates: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
safe_mode_non_refundable_storage_fee: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
epoch_start_timestamp_ms: u64</code>
</dt>
<dd>
 Unix timestamp of the current epoch start
</dd>
<dt>
<code>
extra_fields: <Link to="../iota-framework/bag#0x2_bag_Bag">bag::Bag</Link></code>
</dt>
<dd>
 Any extra fields that's not defined statically.
</dd>
</dl>


</details>

<Link id="0x3_iota_system_state_inner_IotaSystemStateInnerV2"></Link>

## Struct `IotaSystemStateInnerV2`

Uses SystemParametersV2 as the parameters.


<pre><code>
<b>struct</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
epoch: u64</code>
</dt>
<dd>
 The current epoch ID, starting from 0.
</dd>
<dt>
<code>
protocol_version: u64</code>
</dt>
<dd>
 The current protocol version, starting from 1.
</dd>
<dt>
<code>
system_state_version: u64</code>
</dt>
<dd>
 The current version of the system state data structure type.
 This is always the same as IotaSystemState.version. Keeping a copy here so that
 we know what version it is by inspecting IotaSystemStateInner as well.
</dd>
<dt>
<code>
validators: <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link></code>
</dt>
<dd>
 Contains all information about the validators.
</dd>
<dt>
<code>
<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>: <Link to="storage_fund#0x3_storage_fund_StorageFund">storage_fund::StorageFund</Link></code>
</dt>
<dd>
 The storage fund.
</dd>
<dt>
<code>
parameters: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParametersV2">iota_system_state_inner::SystemParametersV2</Link></code>
</dt>
<dd>
 A list of system config parameters.
</dd>
<dt>
<code>
reference_gas_price: u64</code>
</dt>
<dd>
 The reference gas price for the current epoch.
</dd>
<dt>
<code>
validator_report_records: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;</code>
</dt>
<dd>
 A map storing the records of validator reporting each other.
 There is an entry in the map for each validator that has been reported
 at least once. The entry VecSet contains all the validators that reported
 them. If a validator has never been reported they don't have an entry in this map.
 This map persists across epoch: a peer continues being in a reported state until the
 reporter doesn't explicitly remove their report.
 Note that in case we want to support validator address change in future,
 the reports should be based on validator ids
</dd>
<dt>
<code>
<Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>: <Link to="stake_subsidy#0x3_stake_subsidy_StakeSubsidy">stake_subsidy::StakeSubsidy</Link></code>
</dt>
<dd>
 Schedule of stake subsidies given out each epoch.
</dd>
<dt>
<code>
safe_mode: bool</code>
</dt>
<dd>
 Whether the system is running in a downgraded safe mode due to a non-recoverable bug.
 This is set whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode.
 It can be reset once we are able to successfully execute advance_epoch.
 The rest of the fields starting with <code>
safe_mode_</code> are accmulated during safe mode
 when advance_epoch_safe_mode is executed. They will eventually be processed once we
 are out of safe mode.
</dd>
<dt>
<code>
safe_mode_storage_rewards: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
safe_mode_computation_rewards: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
safe_mode_storage_rebates: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
safe_mode_non_refundable_storage_fee: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
epoch_start_timestamp_ms: u64</code>
</dt>
<dd>
 Unix timestamp of the current epoch start
</dd>
<dt>
<code>
extra_fields: <Link to="../iota-framework/bag#0x2_bag_Bag">bag::Bag</Link></code>
</dt>
<dd>
 Any extra fields that's not defined statically.
</dd>
</dl>


</details>

<Link id="0x3_iota_system_state_inner_SystemEpochInfoEvent"></Link>

## Struct `SystemEpochInfoEvent`

Event containing system-level epoch information, emitted during
the epoch advancement transaction.


<pre><code>
<b>struct</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemEpochInfoEvent">SystemEpochInfoEvent</Link> <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
epoch: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
protocol_version: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
reference_gas_price: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
total_stake: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
storage_fund_reinvestment: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
storage_charge: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
storage_rebate: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
storage_fund_balance: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
stake_subsidy_amount: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
total_gas_fees: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
total_stake_rewards_distributed: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
leftover_storage_fund_inflow: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x3_iota_system_state_inner_ENotSystemAddress"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ENotSystemAddress">ENotSystemAddress</Link>: u64 = 2;
</code></pre>



<Link id="0x3_iota_system_state_inner_ACTIVE_OR_PENDING_VALIDATOR"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ACTIVE_OR_PENDING_VALIDATOR">ACTIVE_OR_PENDING_VALIDATOR</Link>: u8 = 2;
</code></pre>



<Link id="0x3_iota_system_state_inner_ACTIVE_VALIDATOR_ONLY"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ACTIVE_VALIDATOR_ONLY">ACTIVE_VALIDATOR_ONLY</Link>: u8 = 1;
</code></pre>



<Link id="0x3_iota_system_state_inner_ANY_VALIDATOR"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ANY_VALIDATOR">ANY_VALIDATOR</Link>: u8 = 3;
</code></pre>



<Link id="0x3_iota_system_state_inner_BASIS_POINT_DENOMINATOR"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_BASIS_POINT_DENOMINATOR">BASIS_POINT_DENOMINATOR</Link>: u128 = 10000;
</code></pre>



<Link id="0x3_iota_system_state_inner_EAdvancedToWrongEpoch"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EAdvancedToWrongEpoch">EAdvancedToWrongEpoch</Link>: u64 = 8;
</code></pre>



<Link id="0x3_iota_system_state_inner_EBpsTooLarge"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EBpsTooLarge">EBpsTooLarge</Link>: u64 = 5;
</code></pre>



<Link id="0x3_iota_system_state_inner_ECannotReportOneself"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ECannotReportOneself">ECannotReportOneself</Link>: u64 = 3;
</code></pre>



<Link id="0x3_iota_system_state_inner_ELimitExceeded"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ELimitExceeded">ELimitExceeded</Link>: u64 = 1;
</code></pre>



<Link id="0x3_iota_system_state_inner_ENotValidator"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ENotValidator">ENotValidator</Link>: u64 = 0;
</code></pre>



<Link id="0x3_iota_system_state_inner_EReportRecordNotFound"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EReportRecordNotFound">EReportRecordNotFound</Link>: u64 = 4;
</code></pre>



<Link id="0x3_iota_system_state_inner_ESafeModeGasNotProcessed"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ESafeModeGasNotProcessed">ESafeModeGasNotProcessed</Link>: u64 = 7;
</code></pre>



<Link id="0x3_iota_system_state_inner_EStakeWithdrawBeforeActivation"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EStakeWithdrawBeforeActivation">EStakeWithdrawBeforeActivation</Link>: u64 = 6;
</code></pre>



<Link id="0x3_iota_system_state_inner_SYSTEM_STATE_VERSION_V1"></Link>



<pre><code>
<b>const</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SYSTEM_STATE_VERSION_V1">SYSTEM_STATE_VERSION_V1</Link>: u64 = 1;
</code></pre>



<Link id="0x3_iota_system_state_inner_create"></Link>

## Function `create`

Create a new IotaSystemState object and make it shared.
This function will be called only once in genesis.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_create">create</Link>(validators: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, initial_storage_fund: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, protocol_version: u64, epoch_start_timestamp_ms: u64, parameters: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">iota_system_state_inner::SystemParameters</Link>, <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>: <Link to="stake_subsidy#0x3_stake_subsidy_StakeSubsidy">stake_subsidy::StakeSubsidy</Link>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">iota_system_state_inner::IotaSystemStateInner</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_create">create</Link>(
    validators: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    initial_storage_fund: Balance&lt;IOTA&gt;,
    protocol_version: u64,
    epoch_start_timestamp_ms: u64,
    parameters: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">SystemParameters</Link>,
    <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>: StakeSubsidy,
    ctx: &<b>mut</b> TxContext,
): <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">IotaSystemStateInner</Link> \{
    <b>let</b> validators = <Link to="validator_set#0x3_validator_set_new">validator_set::new</Link>(validators, ctx);
    <b>let</b> reference_gas_price = validators.derive_reference_gas_price();
    // This type is fixed <b>as</b> it's created at <Link to="genesis#0x3_genesis">genesis</Link>. It should not be updated during type upgrade.
    <b>let</b> system_state = <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">IotaSystemStateInner</Link> \{
        epoch: 0,
        protocol_version,
        system_state_version: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_genesis_system_state_version">genesis_system_state_version</Link>(),
        validators,
        <Link to="storage_fund#0x3_storage_fund">storage_fund</Link>: <Link to="storage_fund#0x3_storage_fund_new">storage_fund::new</Link>(initial_storage_fund),
        parameters,
        reference_gas_price,
        validator_report_records: <Link to="../iota-framework/vec_map#0x2_vec_map_empty">vec_map::empty</Link>(),
        <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>,
        safe_mode: <b>false</b>,
        safe_mode_storage_rewards: <Link to="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>(),
        safe_mode_computation_rewards: <Link to="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>(),
        safe_mode_storage_rebates: 0,
        safe_mode_non_refundable_storage_fee: 0,
        epoch_start_timestamp_ms,
        extra_fields: <Link to="../iota-framework/bag#0x2_bag_new">bag::new</Link>(ctx),
    };
    system_state
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_create_system_parameters"></Link>

## Function `create_system_parameters`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_create_system_parameters">create_system_parameters</Link>(epoch_duration_ms: u64, stake_subsidy_start_epoch: u64, max_validator_count: u64, min_validator_joining_stake: u64, validator_low_stake_threshold: u64, validator_very_low_stake_threshold: u64, validator_low_stake_grace_period: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">iota_system_state_inner::SystemParameters</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_create_system_parameters">create_system_parameters</Link>(
    epoch_duration_ms: u64,
    stake_subsidy_start_epoch: u64,

    // Validator committee parameters
    max_validator_count: u64,
    min_validator_joining_stake: u64,
    validator_low_stake_threshold: u64,
    validator_very_low_stake_threshold: u64,
    validator_low_stake_grace_period: u64,
    ctx: &<b>mut</b> TxContext,
): <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">SystemParameters</Link> \{
    <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">SystemParameters</Link> \{
        epoch_duration_ms,
        stake_subsidy_start_epoch,
        max_validator_count,
        min_validator_joining_stake,
        validator_low_stake_threshold,
        validator_very_low_stake_threshold,
        validator_low_stake_grace_period,
        extra_fields: <Link to="../iota-framework/bag#0x2_bag_new">bag::new</Link>(ctx),
    }
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_v1_to_v2"></Link>

## Function `v1_to_v2`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_v1_to_v2">v1_to_v2</Link>(self: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">iota_system_state_inner::IotaSystemStateInner</Link>): <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_v1_to_v2">v1_to_v2</Link>(self: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">IotaSystemStateInner</Link>): <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link> \{
    <b>let</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInner">IotaSystemStateInner</Link> \{
        epoch,
        protocol_version,
        system_state_version: _,
        validators,
        <Link to="storage_fund#0x3_storage_fund">storage_fund</Link>,
        parameters,
        reference_gas_price,
        validator_report_records,
        <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>,
        safe_mode,
        safe_mode_storage_rewards,
        safe_mode_computation_rewards,
        safe_mode_storage_rebates,
        safe_mode_non_refundable_storage_fee,
        epoch_start_timestamp_ms,
        extra_fields: state_extra_fields,
    } = self;
    <b>let</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParameters">SystemParameters</Link> \{
        epoch_duration_ms,
        stake_subsidy_start_epoch,
        max_validator_count,
        min_validator_joining_stake,
        validator_low_stake_threshold,
        validator_very_low_stake_threshold,
        validator_low_stake_grace_period,
        extra_fields: param_extra_fields,
    } = parameters;
    <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link> \{
        epoch,
        protocol_version,
        system_state_version: 2,
        validators,
        <Link to="storage_fund#0x3_storage_fund">storage_fund</Link>,
        parameters: <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemParametersV2">SystemParametersV2</Link> \{
            epoch_duration_ms,
            stake_subsidy_start_epoch,
            min_validator_count: 4,
            max_validator_count,
            min_validator_joining_stake,
            validator_low_stake_threshold,
            validator_very_low_stake_threshold,
            validator_low_stake_grace_period,
            extra_fields: param_extra_fields,
        },
        reference_gas_price,
        validator_report_records,
        <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>,
        safe_mode,
        safe_mode_storage_rewards,
        safe_mode_computation_rewards,
        safe_mode_storage_rebates,
        safe_mode_non_refundable_storage_fee,
        epoch_start_timestamp_ms,
        extra_fields: state_extra_fields
    }
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_add_validator_candidate"></Link>

## Function `request_add_validator_candidate`

Can be called by anyone who wishes to become a validator candidate and starts accuring delegated
stakes in their staking pool. Once they have at least <code>
MIN_VALIDATOR_JOINING_STAKE</code> amount of stake they
can call <code>
request_add_validator</code> to officially become an active validator at the next epoch.
Aborts if the caller is already a pending or active validator, or a validator candidate.
Note: <code>
proof_of_possession</code> MUST be a valid signature using iota_address and protocol_pubkey_bytes.
To produce a valid PoP, run [fn test_proof_of_possession].


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_validator_candidate">request_add_validator_candidate</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, pubkey_bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, network_pubkey_bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, worker_pubkey_bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, proof_of_possession: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, name: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, description: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, image_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, project_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, net_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, p2p_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, primary_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, worker_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, gas_price: u64, commission_rate: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_validator_candidate">request_add_validator_candidate</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    pubkey_bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    network_pubkey_bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    worker_pubkey_bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    proof_of_possession: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    name: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    description: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    image_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    project_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    net_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    p2p_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    primary_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    worker_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    gas_price: u64,
    commission_rate: u64,
    ctx: &<b>mut</b> TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator#0x3_validator_new">validator::new</Link>(
        ctx.sender(),
        pubkey_bytes,
        network_pubkey_bytes,
        worker_pubkey_bytes,
        proof_of_possession,
        name,
        description,
        image_url,
        project_url,
        net_address,
        p2p_address,
        primary_address,
        worker_address,
        gas_price,
        commission_rate,
        ctx
    );

    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_validator_candidate">request_add_validator_candidate</Link>(<Link to="validator#0x3_validator">validator</Link>, ctx);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_remove_validator_candidate"></Link>

## Function `request_remove_validator_candidate`

Called by a validator candidate to remove themselves from the candidacy. After this call
their staking pool becomes deactivate.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_remove_validator_candidate">request_remove_validator_candidate</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_remove_validator_candidate">request_remove_validator_candidate</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    ctx: &<b>mut</b> TxContext,
) \{
    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_remove_validator_candidate">request_remove_validator_candidate</Link>(ctx);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_add_validator"></Link>

## Function `request_add_validator`

Called by a validator candidate to add themselves to the active validator set beginning next epoch.
Aborts if the validator is a duplicate with one of the pending or active validators, or if the amount of
stake the validator has doesn't meet the min threshold, or if the number of new validators for the next
epoch has already reached the maximum.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_validator">request_add_validator</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_validator">request_add_validator</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    ctx: &TxContext,
) \{
    <b>assert</b>!(
        self.validators.next_epoch_validator_count() &lt; self.parameters.max_validator_count,
        <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ELimitExceeded">ELimitExceeded</Link>,
    );

    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_validator">request_add_validator</Link>(self.parameters.min_validator_joining_stake, ctx);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_remove_validator"></Link>

## Function `request_remove_validator`

A validator can call this function to request a removal in the next epoch.
We use the sender of <code>
ctx</code> to look up the validator
(i.e. sender must match the iota_address in the validator).
At the end of the epoch, the <code>
<Link to="validator#0x3_validator">validator</Link></code> object will be returned to the iota_address
of the validator.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_remove_validator">request_remove_validator</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_remove_validator">request_remove_validator</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    ctx: &TxContext,
) \{
    // Only check <b>min</b> <Link to="validator#0x3_validator">validator</Link> condition <b>if</b> the current number of validators satisfy the constraint.
    // This is so that <b>if</b> we somehow already are in a state <b>where</b> we have less than <b>min</b> validators, it no longer matters
    // and is ok <b>to</b> stay so. This is useful for a test setup.
    <b>if</b> (self.validators.active_validators().length() &gt;= self.parameters.min_validator_count) \{
        <b>assert</b>!(
            self.validators.next_epoch_validator_count() &gt; self.parameters.min_validator_count,
            <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ELimitExceeded">ELimitExceeded</Link>,
        );
    };

    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_remove_validator">request_remove_validator</Link>(ctx)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_set_gas_price"></Link>

## Function `request_set_gas_price`

A validator can call this function to submit a new gas price quote, to be
used for the reference gas price calculation at the end of the epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_set_gas_price">request_set_gas_price</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, cap: &<Link to="validator_cap#0x3_validator_cap_UnverifiedValidatorOperationCap">validator_cap::UnverifiedValidatorOperationCap</Link>, new_gas_price: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_set_gas_price">request_set_gas_price</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    cap: &UnverifiedValidatorOperationCap,
    new_gas_price: u64,
) \{
    // Verify the represented <b>address</b> is an active or pending <Link to="validator#0x3_validator">validator</Link>, and the capability is still valid.
    <b>let</b> verified_cap = self.validators.verify_cap(cap, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ACTIVE_OR_PENDING_VALIDATOR">ACTIVE_OR_PENDING_VALIDATOR</Link>);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_verified_cap(&verified_cap, <b>false</b> /* include_candidate */);

    <Link to="validator#0x3_validator">validator</Link>.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_set_gas_price">request_set_gas_price</Link>(verified_cap, new_gas_price);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_set_candidate_validator_gas_price"></Link>

## Function `set_candidate_validator_gas_price`

This function is used to set new gas price for candidate validators


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_set_candidate_validator_gas_price">set_candidate_validator_gas_price</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, cap: &<Link to="validator_cap#0x3_validator_cap_UnverifiedValidatorOperationCap">validator_cap::UnverifiedValidatorOperationCap</Link>, new_gas_price: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_set_candidate_validator_gas_price">set_candidate_validator_gas_price</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    cap: &UnverifiedValidatorOperationCap,
    new_gas_price: u64,
) \{
    // Verify the represented <b>address</b> is an active or pending <Link to="validator#0x3_validator">validator</Link>, and the capability is still valid.
    <b>let</b> verified_cap = self.validators.verify_cap(cap, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ANY_VALIDATOR">ANY_VALIDATOR</Link>);
    <b>let</b> candidate = self.validators.get_validator_mut_with_verified_cap(&verified_cap, <b>true</b> /* include_candidate */);
    candidate.set_candidate_gas_price(verified_cap, new_gas_price)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_set_commission_rate"></Link>

## Function `request_set_commission_rate`

A validator can call this function to set a new commission rate, updated at the end of
the epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_set_commission_rate">request_set_commission_rate</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, new_commission_rate: u64, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_set_commission_rate">request_set_commission_rate</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    new_commission_rate: u64,
    ctx: &TxContext,
) \{
    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_set_commission_rate">request_set_commission_rate</Link>(
        new_commission_rate,
        ctx
    )
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_set_candidate_validator_commission_rate"></Link>

## Function `set_candidate_validator_commission_rate`

This function is used to set new commission rate for candidate validators


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_set_candidate_validator_commission_rate">set_candidate_validator_commission_rate</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, new_commission_rate: u64, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_set_candidate_validator_commission_rate">set_candidate_validator_commission_rate</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    new_commission_rate: u64,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.set_candidate_commission_rate(new_commission_rate)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_add_stake"></Link>

## Function `request_add_stake`

Add stake to a validator's staking pool.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_stake">request_add_stake</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, stake: <Link to="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, validator_address: <b>address</b>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_stake">request_add_stake</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    stake: Coin&lt;IOTA&gt;,
    validator_address: <b>address</b>,
    ctx: &<b>mut</b> TxContext,
) : StakedIota \{
    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_stake">request_add_stake</Link>(
        validator_address,
        stake.into_balance(),
        ctx,
    )
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_add_stake_mul_coin"></Link>

## Function `request_add_stake_mul_coin`

Add stake to a validator's staking pool using multiple coins.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_stake_mul_coin">request_add_stake_mul_coin</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, stakes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;&gt;, stake_amount: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;, validator_address: <b>address</b>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_stake_mul_coin">request_add_stake_mul_coin</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    stakes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Coin&lt;IOTA&gt;&gt;,
    stake_amount: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;,
    validator_address: <b>address</b>,
    ctx: &<b>mut</b> TxContext,
) : StakedIota \{
    <b>let</b> <Link to="../iota-framework/balance#0x2_balance">balance</Link> = <Link to="iota_system_state_inner#0x3_iota_system_state_inner_extract_coin_balance">extract_coin_balance</Link>(stakes, stake_amount, ctx);
    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_add_stake">request_add_stake</Link>(validator_address, <Link to="../iota-framework/balance#0x2_balance">balance</Link>, ctx)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_request_withdraw_stake"></Link>

## Function `request_withdraw_stake`

Withdraw some portion of a stake from a validator's staking pool.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_withdraw_stake">request_withdraw_stake</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_withdraw_stake">request_withdraw_stake</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    staked_iota: StakedIota,
    ctx: &TxContext,
) : Balance&lt;IOTA&gt; \{
    <b>assert</b>!(
        stake_activation_epoch(&staked_iota) &lt;= ctx.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_epoch">epoch</Link>(),
        <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EStakeWithdrawBeforeActivation">EStakeWithdrawBeforeActivation</Link>
    );
    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_request_withdraw_stake">request_withdraw_stake</Link>(staked_iota, ctx)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_report_validator"></Link>

## Function `report_validator`

Report a validator as a bad or non-performant actor in the system.
Succeeds if all the following are satisfied:
1. both the reporter in <code>
cap</code> and the input <code>
reportee_addr</code> are active validators.
2. reporter and reportee not the same address.
3. the cap object is still valid.
This function is idempotent.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_report_validator">report_validator</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, cap: &<Link to="validator_cap#0x3_validator_cap_UnverifiedValidatorOperationCap">validator_cap::UnverifiedValidatorOperationCap</Link>, reportee_addr: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_report_validator">report_validator</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    cap: &UnverifiedValidatorOperationCap,
    reportee_addr: <b>address</b>,
) \{
    // Reportee needs <b>to</b> be an active <Link to="validator#0x3_validator">validator</Link>
    <b>assert</b>!(self.validators.is_active_validator_by_iota_address(reportee_addr), <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ENotValidator">ENotValidator</Link>);
    // Verify the represented reporter <b>address</b> is an active <Link to="validator#0x3_validator">validator</Link>, and the capability is still valid.
    <b>let</b> verified_cap = self.validators.verify_cap(cap, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ACTIVE_VALIDATOR_ONLY">ACTIVE_VALIDATOR_ONLY</Link>);
    <Link to="iota_system_state_inner#0x3_iota_system_state_inner_report_validator_impl">report_validator_impl</Link>(verified_cap, reportee_addr, &<b>mut</b> self.validator_report_records);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_undo_report_validator"></Link>

## Function `undo_report_validator`

Undo a <code>
report_validator</code> action. Aborts if
1. the reportee is not a currently active validator or
2. the sender has not previously reported the <code>
reportee_addr</code>, or
3. the cap is not valid


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_undo_report_validator">undo_report_validator</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, cap: &<Link to="validator_cap#0x3_validator_cap_UnverifiedValidatorOperationCap">validator_cap::UnverifiedValidatorOperationCap</Link>, reportee_addr: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_undo_report_validator">undo_report_validator</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    cap: &UnverifiedValidatorOperationCap,
    reportee_addr: <b>address</b>,
) \{
    <b>let</b> verified_cap = self.validators.verify_cap(cap, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ACTIVE_VALIDATOR_ONLY">ACTIVE_VALIDATOR_ONLY</Link>);
    <Link to="iota_system_state_inner#0x3_iota_system_state_inner_undo_report_validator_impl">undo_report_validator_impl</Link>(verified_cap, reportee_addr, &<b>mut</b> self.validator_report_records);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_report_validator_impl"></Link>

## Function `report_validator_impl`



<pre><code>
<b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_report_validator_impl">report_validator_impl</Link>(verified_cap: <Link to="validator_cap#0x3_validator_cap_ValidatorOperationCap">validator_cap::ValidatorOperationCap</Link>, reportee_addr: <b>address</b>, validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_report_validator_impl">report_validator_impl</Link>(
    verified_cap: ValidatorOperationCap,
    reportee_addr: <b>address</b>,
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
) \{
    <b>let</b> reporter_address = *verified_cap.verified_operation_cap_address();
    <b>assert</b>!(reporter_address != reportee_addr, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ECannotReportOneself">ECannotReportOneself</Link>);
    <b>if</b> (!validator_report_records.contains(&reportee_addr)) \{
        validator_report_records.insert(reportee_addr, <Link to="../iota-framework/vec_set#0x2_vec_set_singleton">vec_set::singleton</Link>(reporter_address));
    } <b>else</b> \{
        <b>let</b> reporters = validator_report_records.get_mut(&reportee_addr);
        <b>if</b> (!reporters.contains(&reporter_address)) \{
            reporters.insert(reporter_address);
        }
    }
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_undo_report_validator_impl"></Link>

## Function `undo_report_validator_impl`



<pre><code>
<b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_undo_report_validator_impl">undo_report_validator_impl</Link>(verified_cap: <Link to="validator_cap#0x3_validator_cap_ValidatorOperationCap">validator_cap::ValidatorOperationCap</Link>, reportee_addr: <b>address</b>, validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_undo_report_validator_impl">undo_report_validator_impl</Link>(
    verified_cap: ValidatorOperationCap,
    reportee_addr: <b>address</b>,
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
) \{
    <b>assert</b>!(validator_report_records.contains(&reportee_addr), <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EReportRecordNotFound">EReportRecordNotFound</Link>);
    <b>let</b> reporters = validator_report_records.get_mut(&reportee_addr);

    <b>let</b> reporter_addr = *verified_cap.verified_operation_cap_address();
    <b>assert</b>!(reporters.contains(&reporter_addr), <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EReportRecordNotFound">EReportRecordNotFound</Link>);

    reporters.remove(&reporter_addr);
    <b>if</b> (reporters.is_empty()) \{
        validator_report_records.remove(&reportee_addr);
    }
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_rotate_operation_cap"></Link>

## Function `rotate_operation_cap`

Create a new <code>
UnverifiedValidatorOperationCap</code>, transfer it to the
validator and registers it. The original object is thus revoked.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_rotate_operation_cap">rotate_operation_cap</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_rotate_operation_cap">rotate_operation_cap</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    ctx: &<b>mut</b> TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    <Link to="validator#0x3_validator">validator</Link>.new_unverified_validator_operation_cap_and_transfer(ctx);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_name"></Link>

## Function `update_validator_name`

Update a validator's name.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_name">update_validator_name</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, name: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_name">update_validator_name</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    name: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);

    <Link to="validator#0x3_validator">validator</Link>.update_name(name);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_description"></Link>

## Function `update_validator_description`

Update a validator's description


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_description">update_validator_description</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, description: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_description">update_validator_description</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    description: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_description(description);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_image_url"></Link>

## Function `update_validator_image_url`

Update a validator's image url


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_image_url">update_validator_image_url</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, image_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_image_url">update_validator_image_url</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    image_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_image_url(image_url);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_project_url"></Link>

## Function `update_validator_project_url`

Update a validator's project url


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_project_url">update_validator_project_url</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, project_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_project_url">update_validator_project_url</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    project_url: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_project_url(project_url);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_network_address"></Link>

## Function `update_validator_next_epoch_network_address`

Update a validator's network address.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_network_address">update_validator_next_epoch_network_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, network_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_network_address">update_validator_next_epoch_network_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    network_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_network_address(network_address);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> :&Validator = <Link to="validator#0x3_validator">validator</Link>; // Force immutability for the following call
    self.validators.assert_no_pending_or_active_duplicates(<Link to="validator#0x3_validator">validator</Link>);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_network_address"></Link>

## Function `update_candidate_validator_network_address`

Update candidate validator's network address.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_network_address">update_candidate_validator_network_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, network_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_network_address">update_candidate_validator_network_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    network_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_network_address(network_address);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_p2p_address"></Link>

## Function `update_validator_next_epoch_p2p_address`

Update a validator's p2p address.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_p2p_address">update_validator_next_epoch_p2p_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, p2p_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_p2p_address">update_validator_next_epoch_p2p_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    p2p_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_p2p_address(p2p_address);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> :&Validator = <Link to="validator#0x3_validator">validator</Link>; // Force immutability for the following call
    self.validators.assert_no_pending_or_active_duplicates(<Link to="validator#0x3_validator">validator</Link>);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_p2p_address"></Link>

## Function `update_candidate_validator_p2p_address`

Update candidate validator's p2p address.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_p2p_address">update_candidate_validator_p2p_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, p2p_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_p2p_address">update_candidate_validator_p2p_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    p2p_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_p2p_address(p2p_address);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_primary_address"></Link>

## Function `update_validator_next_epoch_primary_address`

Update a validator's narwhal primary address.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_primary_address">update_validator_next_epoch_primary_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, primary_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_primary_address">update_validator_next_epoch_primary_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    primary_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_primary_address(primary_address);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_primary_address"></Link>

## Function `update_candidate_validator_primary_address`

Update candidate validator's narwhal primary address.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_primary_address">update_candidate_validator_primary_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, primary_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_primary_address">update_candidate_validator_primary_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    primary_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_primary_address(primary_address);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_worker_address"></Link>

## Function `update_validator_next_epoch_worker_address`

Update a validator's narwhal worker address.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_worker_address">update_validator_next_epoch_worker_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, worker_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_worker_address">update_validator_next_epoch_worker_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    worker_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_worker_address(worker_address);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_worker_address"></Link>

## Function `update_candidate_validator_worker_address`

Update candidate validator's narwhal worker address.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_worker_address">update_candidate_validator_worker_address</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, worker_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_worker_address">update_candidate_validator_worker_address</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    worker_address: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_worker_address(worker_address);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_protocol_pubkey"></Link>

## Function `update_validator_next_epoch_protocol_pubkey`

Update a validator's public key of protocol key and proof of possession.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_protocol_pubkey">update_validator_next_epoch_protocol_pubkey</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, protocol_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, proof_of_possession: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_protocol_pubkey">update_validator_next_epoch_protocol_pubkey</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    protocol_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    proof_of_possession: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_protocol_pubkey(protocol_pubkey, proof_of_possession);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> :&Validator = <Link to="validator#0x3_validator">validator</Link>; // Force immutability for the following call
    self.validators.assert_no_pending_or_active_duplicates(<Link to="validator#0x3_validator">validator</Link>);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_protocol_pubkey"></Link>

## Function `update_candidate_validator_protocol_pubkey`

Update candidate validator's public key of protocol key and proof of possession.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_protocol_pubkey">update_candidate_validator_protocol_pubkey</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, protocol_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, proof_of_possession: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_protocol_pubkey">update_candidate_validator_protocol_pubkey</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    protocol_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    proof_of_possession: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_protocol_pubkey(protocol_pubkey, proof_of_possession);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_worker_pubkey"></Link>

## Function `update_validator_next_epoch_worker_pubkey`

Update a validator's public key of worker key.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_worker_pubkey">update_validator_next_epoch_worker_pubkey</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, worker_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_worker_pubkey">update_validator_next_epoch_worker_pubkey</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    worker_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_worker_pubkey(worker_pubkey);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> :&Validator = <Link to="validator#0x3_validator">validator</Link>; // Force immutability for the following call
    self.validators.assert_no_pending_or_active_duplicates(<Link to="validator#0x3_validator">validator</Link>);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_worker_pubkey"></Link>

## Function `update_candidate_validator_worker_pubkey`

Update candidate validator's public key of worker key.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_worker_pubkey">update_candidate_validator_worker_pubkey</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, worker_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_worker_pubkey">update_candidate_validator_worker_pubkey</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    worker_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_worker_pubkey(worker_pubkey);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_validator_next_epoch_network_pubkey"></Link>

## Function `update_validator_next_epoch_network_pubkey`

Update a validator's public key of network key.
The change will only take effects starting from the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_network_pubkey">update_validator_next_epoch_network_pubkey</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, network_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_validator_next_epoch_network_pubkey">update_validator_next_epoch_network_pubkey</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    network_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.validators.get_validator_mut_with_ctx(ctx);
    <Link to="validator#0x3_validator">validator</Link>.update_next_epoch_network_pubkey(network_pubkey);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> :&Validator = <Link to="validator#0x3_validator">validator</Link>; // Force immutability for the following call
    self.validators.assert_no_pending_or_active_duplicates(<Link to="validator#0x3_validator">validator</Link>);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_update_candidate_validator_network_pubkey"></Link>

## Function `update_candidate_validator_network_pubkey`

Update candidate validator's public key of network key.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_network_pubkey">update_candidate_validator_network_pubkey</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, network_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_update_candidate_validator_network_pubkey">update_candidate_validator_network_pubkey</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    network_pubkey: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;,
    ctx: &TxContext,
) \{
    <b>let</b> candidate = self.validators.get_validator_mut_with_ctx_including_candidates(ctx);
    candidate.update_candidate_network_pubkey(network_pubkey);
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_advance_epoch"></Link>

## Function `advance_epoch`

This function should be called at the end of an epoch, and advances the system to the next epoch.
It does the following things:
1. Add storage charge to the storage fund.
2. Burn the storage rebates from the storage fund. These are already refunded to transaction sender's
gas coins.
3. Distribute computation charge to validator stake.
4. Update all validators.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_advance_epoch">advance_epoch</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, new_epoch: u64, next_protocol_version: u64, storage_reward: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, computation_reward: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, storage_rebate_amount: u64, non_refundable_storage_fee_amount: u64, storage_fund_reinvest_rate: u64, reward_slashing_rate: u64, epoch_start_timestamp_ms: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_advance_epoch">advance_epoch</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    new_epoch: u64,
    next_protocol_version: u64,
    <b>mut</b> storage_reward: Balance&lt;IOTA&gt;,
    <b>mut</b> computation_reward: Balance&lt;IOTA&gt;,
    <b>mut</b> storage_rebate_amount: u64,
    <b>mut</b> non_refundable_storage_fee_amount: u64,
    storage_fund_reinvest_rate: u64, // share of storage fund's rewards that's reinvested
                                     // into storage fund, in basis point.
    reward_slashing_rate: u64, // how much rewards are slashed <b>to</b> punish a <Link to="validator#0x3_validator">validator</Link>, in bps.
    epoch_start_timestamp_ms: u64, // Timestamp of the epoch start
    ctx: &<b>mut</b> TxContext,
) : Balance&lt;IOTA&gt; \{
    <b>let</b> prev_epoch_start_timestamp = self.epoch_start_timestamp_ms;
    self.epoch_start_timestamp_ms = epoch_start_timestamp_ms;

    <b>let</b> bps_denominator_u64 = <Link to="iota_system_state_inner#0x3_iota_system_state_inner_BASIS_POINT_DENOMINATOR">BASIS_POINT_DENOMINATOR</Link> <b>as</b> u64;
    // Rates can't be higher than 100%.
    <b>assert</b>!(
        storage_fund_reinvest_rate &lt;= bps_denominator_u64
        && reward_slashing_rate &lt;= bps_denominator_u64,
        <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EBpsTooLarge">EBpsTooLarge</Link>,
    );

    // TODO: remove this in later upgrade.
    <b>if</b> (self.parameters.stake_subsidy_start_epoch &gt; 0) \{
        self.parameters.stake_subsidy_start_epoch = 20;
    };

    // Accumulate the gas summary during safe_mode before processing any rewards:
    <b>let</b> safe_mode_storage_rewards = self.safe_mode_storage_rewards.withdraw_all();
    storage_reward.join(safe_mode_storage_rewards);
    <b>let</b> safe_mode_computation_rewards = self.safe_mode_computation_rewards.withdraw_all();
    computation_reward.join(safe_mode_computation_rewards);
    storage_rebate_amount = storage_rebate_amount + self.safe_mode_storage_rebates;
    self.safe_mode_storage_rebates = 0;
    non_refundable_storage_fee_amount = non_refundable_storage_fee_amount + self.safe_mode_non_refundable_storage_fee;
    self.safe_mode_non_refundable_storage_fee = 0;

    <b>let</b> total_validators_stake = self.validators.total_stake();
    <b>let</b> storage_fund_balance = self.<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>.total_balance();
    <b>let</b> total_stake = storage_fund_balance + total_validators_stake;

    <b>let</b> storage_charge = storage_reward.value();
    <b>let</b> computation_charge = computation_reward.value();

    // Include stake subsidy in the rewards given out <b>to</b> validators and stakers.
    // Delay distributing any stake subsidies until after `stake_subsidy_start_epoch`.
    // And <b>if</b> this epoch is shorter than the regular epoch duration, don't distribute any stake subsidy.
    <b>let</b> <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link> =
        <b>if</b> (ctx.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_epoch">epoch</Link>() &gt;= self.parameters.stake_subsidy_start_epoch  &&
            epoch_start_timestamp_ms &gt;= prev_epoch_start_timestamp + self.parameters.epoch_duration_ms)
        \{
            self.<Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_advance_epoch">advance_epoch</Link>()
        } <b>else</b> \{
            <Link to="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>()
        };

    <b>let</b> stake_subsidy_amount = <Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>.value();
    computation_reward.join(<Link to="stake_subsidy#0x3_stake_subsidy">stake_subsidy</Link>);

    <b>let</b> total_stake_u128 = total_stake <b>as</b> u128;
    <b>let</b> computation_charge_u128 = computation_charge <b>as</b> u128;

    <b>let</b> storage_fund_reward_amount = storage_fund_balance <b>as</b> u128 * computation_charge_u128 / total_stake_u128;
    <b>let</b> <b>mut</b> storage_fund_reward = computation_reward.split(storage_fund_reward_amount <b>as</b> u64);
    <b>let</b> storage_fund_reinvestment_amount =
        storage_fund_reward_amount * (storage_fund_reinvest_rate <b>as</b> u128) / <Link to="iota_system_state_inner#0x3_iota_system_state_inner_BASIS_POINT_DENOMINATOR">BASIS_POINT_DENOMINATOR</Link>;
    <b>let</b> storage_fund_reinvestment = storage_fund_reward.split(
        storage_fund_reinvestment_amount <b>as</b> u64,
    );

    self.epoch = self.epoch + 1;
    // Sanity check <b>to</b> make sure we are advancing <b>to</b> the right epoch.
    <b>assert</b>!(new_epoch == self.epoch, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_EAdvancedToWrongEpoch">EAdvancedToWrongEpoch</Link>);

    <b>let</b> computation_reward_amount_before_distribution = computation_reward.value();
    <b>let</b> storage_fund_reward_amount_before_distribution = storage_fund_reward.value();

    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_advance_epoch">advance_epoch</Link>(
        &<b>mut</b> computation_reward,
        &<b>mut</b> storage_fund_reward,
        &<b>mut</b> self.validator_report_records,
        reward_slashing_rate,
        self.parameters.validator_low_stake_threshold,
        self.parameters.validator_very_low_stake_threshold,
        self.parameters.validator_low_stake_grace_period,
        ctx,
    );

    <b>let</b> new_total_stake = self.validators.total_stake();

    <b>let</b> computation_reward_amount_after_distribution = computation_reward.value();
    <b>let</b> storage_fund_reward_amount_after_distribution = storage_fund_reward.value();
    <b>let</b> computation_reward_distributed = computation_reward_amount_before_distribution - computation_reward_amount_after_distribution;
    <b>let</b> storage_fund_reward_distributed = storage_fund_reward_amount_before_distribution - storage_fund_reward_amount_after_distribution;

    self.protocol_version = next_protocol_version;

    // Derive the reference gas price for the new epoch
    self.reference_gas_price = self.validators.derive_reference_gas_price();
    // Because of precision issues <b>with</b> integer divisions, we expect that there will be some
    // remaining <Link to="../iota-framework/balance#0x2_balance">balance</Link> in `storage_fund_reward` and `computation_reward`.
    // All of these go <b>to</b> the storage fund.
    <b>let</b> <b>mut</b> leftover_staking_rewards = storage_fund_reward;
    leftover_staking_rewards.join(computation_reward);
    <b>let</b> leftover_storage_fund_inflow = leftover_staking_rewards.value();

    <b>let</b> refunded_storage_rebate =
        self.<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_advance_epoch">advance_epoch</Link>(
            storage_reward,
            storage_fund_reinvestment,
            leftover_staking_rewards,
            storage_rebate_amount,
            non_refundable_storage_fee_amount,
        );

    <Link to="../iota-framework/event#0x2_event_emit">event::emit</Link>(
        <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SystemEpochInfoEvent">SystemEpochInfoEvent</Link> \{
            epoch: self.epoch,
            protocol_version: self.protocol_version,
            reference_gas_price: self.reference_gas_price,
            total_stake: new_total_stake,
            storage_charge,
            storage_fund_reinvestment: storage_fund_reinvestment_amount <b>as</b> u64,
            storage_rebate: storage_rebate_amount,
            storage_fund_balance: self.<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>.total_balance(),
            stake_subsidy_amount,
            total_gas_fees: computation_charge,
            total_stake_rewards_distributed: computation_reward_distributed + storage_fund_reward_distributed,
            leftover_storage_fund_inflow,
        }
    );
    self.safe_mode = <b>false</b>;
    // Double check that the gas from safe mode <b>has</b> been processed.
    <b>assert</b>!(self.safe_mode_storage_rebates == 0
        && self.safe_mode_storage_rewards.value() == 0
        && self.safe_mode_computation_rewards.value() == 0, <Link to="iota_system_state_inner#0x3_iota_system_state_inner_ESafeModeGasNotProcessed">ESafeModeGasNotProcessed</Link>);

    // Return the storage rebate split from storage fund that's already refunded <b>to</b> the transaction senders.
    // This will be burnt at the last step of epoch change programmable transaction.
    refunded_storage_rebate
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_epoch"></Link>

## Function `epoch`

Return the current epoch number. Useful for applications that need a coarse-grained concept of time,
since epochs are ever-increasing and epoch changes are intended to happen every 24 hours.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_epoch">epoch</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_epoch">epoch</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): u64 \{
    self.epoch
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_protocol_version"></Link>

## Function `protocol_version`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_protocol_version">protocol_version</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_protocol_version">protocol_version</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): u64 \{
    self.protocol_version
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_system_state_version"></Link>

## Function `system_state_version`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_system_state_version">system_state_version</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_system_state_version">system_state_version</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): u64 \{
    self.system_state_version
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_genesis_system_state_version"></Link>

## Function `genesis_system_state_version`

This function always return the genesis system state version, which is used to create the system state in genesis.
It should never change for a given network.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_genesis_system_state_version">genesis_system_state_version</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_genesis_system_state_version">genesis_system_state_version</Link>(): u64 \{
    <Link to="iota_system_state_inner#0x3_iota_system_state_inner_SYSTEM_STATE_VERSION_V1">SYSTEM_STATE_VERSION_V1</Link>
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_epoch_start_timestamp_ms"></Link>

## Function `epoch_start_timestamp_ms`

Returns unix timestamp of the start of current epoch


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_epoch_start_timestamp_ms">epoch_start_timestamp_ms</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_epoch_start_timestamp_ms">epoch_start_timestamp_ms</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): u64 \{
    self.epoch_start_timestamp_ms
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_validator_stake_amount"></Link>

## Function `validator_stake_amount`

Returns the total amount staked with <code>
validator_addr</code>.
Aborts if <code>
validator_addr</code> is not an active validator.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_stake_amount">validator_stake_amount</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, validator_addr: <b>address</b>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_stake_amount">validator_stake_amount</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>, validator_addr: <b>address</b>): u64 \{
    self.validators.validator_total_stake_amount(validator_addr)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_validator_staking_pool_id"></Link>

## Function `validator_staking_pool_id`

Returns the staking pool id of a given validator.
Aborts if <code>
validator_addr</code> is not an active validator.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_staking_pool_id">validator_staking_pool_id</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, validator_addr: <b>address</b>): <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_staking_pool_id">validator_staking_pool_id</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>, validator_addr: <b>address</b>): ID \{

    self.validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_staking_pool_id">validator_staking_pool_id</Link>(validator_addr)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_validator_staking_pool_mappings"></Link>

## Function `validator_staking_pool_mappings`

Returns reference to the staking pool mappings that map pool ids to active validator addresses


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_staking_pool_mappings">validator_staking_pool_mappings</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): &<Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;<Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>, <b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_validator_staking_pool_mappings">validator_staking_pool_mappings</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): &Table&lt;ID, <b>address</b>&gt; \{

    self.validators.staking_pool_mappings()
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_get_reporters_of"></Link>

## Function `get_reporters_of`

Returns all the validators who are currently reporting <code>
addr</code>


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_get_reporters_of">get_reporters_of</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, addr: <b>address</b>): <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_get_reporters_of">get_reporters_of</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>, addr: <b>address</b>): VecSet&lt;<b>address</b>&gt; \{

    <b>if</b> (self.validator_report_records.contains(&addr)) \{
        self.validator_report_records[&addr]
    } <b>else</b> \{
        <Link to="../iota-framework/vec_set#0x2_vec_set_empty">vec_set::empty</Link>()
    }
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_get_storage_fund_total_balance"></Link>

## Function `get_storage_fund_total_balance`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_get_storage_fund_total_balance">get_storage_fund_total_balance</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_get_storage_fund_total_balance">get_storage_fund_total_balance</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): u64 \{
    self.<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>.total_balance()
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_get_storage_fund_object_rebates"></Link>

## Function `get_storage_fund_object_rebates`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_get_storage_fund_object_rebates">get_storage_fund_object_rebates</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_get_storage_fund_object_rebates">get_storage_fund_object_rebates</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): u64 \{
    self.<Link to="storage_fund#0x3_storage_fund">storage_fund</Link>.total_object_storage_rebates()
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_pool_exchange_rates"></Link>

## Function `pool_exchange_rates`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_pool_exchange_rates">pool_exchange_rates</Link>(self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>, pool_id: &<Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>): &<Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;u64, <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_pool_exchange_rates">pool_exchange_rates</Link>(
    self: &<b>mut</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>,
    pool_id: &ID
): &Table&lt;u64, PoolTokenExchangeRate&gt;  \{
    <b>let</b> validators = &<b>mut</b> self.validators;
    validators.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_pool_exchange_rates">pool_exchange_rates</Link>(pool_id)
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_active_validator_addresses"></Link>

## Function `active_validator_addresses`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_active_validator_addresses">active_validator_addresses</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">iota_system_state_inner::IotaSystemStateInnerV2</Link>): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_active_validator_addresses">active_validator_addresses</Link>(self: &<Link to="iota_system_state_inner#0x3_iota_system_state_inner_IotaSystemStateInnerV2">IotaSystemStateInnerV2</Link>): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt; \{
    <b>let</b> <Link to="validator_set#0x3_validator_set">validator_set</Link> = &self.validators;
    <Link to="validator_set#0x3_validator_set">validator_set</Link>.<Link to="iota_system_state_inner#0x3_iota_system_state_inner_active_validator_addresses">active_validator_addresses</Link>()
}
</code></pre>



</details>

<Link id="0x3_iota_system_state_inner_extract_coin_balance"></Link>

## Function `extract_coin_balance`

Extract required Balance from vector of `Coin<IOTA>`, transfer the remainder back to sender.


<pre><code>
<b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_extract_coin_balance">extract_coin_balance</Link>(coins: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;&gt;, amount: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="iota_system_state_inner#0x3_iota_system_state_inner_extract_coin_balance">extract_coin_balance</Link>(<b>mut</b> coins: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Coin&lt;IOTA&gt;&gt;, amount: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;, ctx: &<b>mut</b> TxContext): Balance&lt;IOTA&gt; \{
    <b>let</b> <b>mut</b> merged_coin = coins.pop_back();
    merged_coin.join_vec(coins);

    <b>let</b> <b>mut</b> total_balance = merged_coin.into_balance();
    // <b>return</b> the full amount <b>if</b> amount is not specified
    <b>if</b> (amount.is_some()) \{
        <b>let</b> amount = amount.destroy_some();
        <b>let</b> <Link to="../iota-framework/balance#0x2_balance">balance</Link> = total_balance.split(amount);
        // <Link to="../iota-framework/transfer#0x2_transfer">transfer</Link> back the remainder <b>if</b> non zero.
        <b>if</b> (total_balance.value() &gt; 0) \{
            <Link to="../iota-framework/transfer#0x2_transfer_public_transfer">transfer::public_transfer</Link>(total_balance.into_coin(ctx), ctx.sender());
        } <b>else</b> \{
            total_balance.destroy_zero();
        };
        <Link to="../iota-framework/balance#0x2_balance">balance</Link>
    } <b>else</b> \{
        total_balance
    }
}
</code></pre>



</details>
