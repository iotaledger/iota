---
title: Module 0x3::staking_pool
sidebar_label: staking_pool
---
import Link from '@docusaurus/Link';

<Link id="0x3_staking_pool"/>


-  [Resource `StakingPool`](#0x3_staking_pool_StakingPool)
-  [Struct `PoolTokenExchangeRate`](#0x3_staking_pool_PoolTokenExchangeRate)
-  [Resource `StakedIota`](#0x3_staking_pool_StakedIota)
-  [Constants](#@Constants_0)
-  [Function `new`](#0x3_staking_pool_new)
-  [Function `request_add_stake`](#0x3_staking_pool_request_add_stake)
-  [Function `request_withdraw_stake`](#0x3_staking_pool_request_withdraw_stake)
-  [Function `withdraw_from_principal`](#0x3_staking_pool_withdraw_from_principal)
-  [Function `unwrap_staked_iota`](#0x3_staking_pool_unwrap_staked_iota)
-  [Function `deposit_rewards`](#0x3_staking_pool_deposit_rewards)
-  [Function `process_pending_stakes_and_withdraws`](#0x3_staking_pool_process_pending_stakes_and_withdraws)
-  [Function `process_pending_stake_withdraw`](#0x3_staking_pool_process_pending_stake_withdraw)
-  [Function `process_pending_stake`](#0x3_staking_pool_process_pending_stake)
-  [Function `withdraw_rewards`](#0x3_staking_pool_withdraw_rewards)
-  [Function `activate_staking_pool`](#0x3_staking_pool_activate_staking_pool)
-  [Function `deactivate_staking_pool`](#0x3_staking_pool_deactivate_staking_pool)
-  [Function `iota_balance`](#0x3_staking_pool_iota_balance)
-  [Function `pool_id`](#0x3_staking_pool_pool_id)
-  [Function `staked_iota_amount`](#0x3_staking_pool_staked_iota_amount)
-  [Function `stake_activation_epoch`](#0x3_staking_pool_stake_activation_epoch)
-  [Function `is_preactive`](#0x3_staking_pool_is_preactive)
-  [Function `is_inactive`](#0x3_staking_pool_is_inactive)
-  [Function `split`](#0x3_staking_pool_split)
-  [Function `split_staked_iota`](#0x3_staking_pool_split_staked_iota)
-  [Function `join_staked_iota`](#0x3_staking_pool_join_staked_iota)
-  [Function `is_equal_staking_metadata`](#0x3_staking_pool_is_equal_staking_metadata)
-  [Function `pool_token_exchange_rate_at_epoch`](#0x3_staking_pool_pool_token_exchange_rate_at_epoch)
-  [Function `pending_stake_amount`](#0x3_staking_pool_pending_stake_amount)
-  [Function `pending_stake_withdraw_amount`](#0x3_staking_pool_pending_stake_withdraw_amount)
-  [Function `exchange_rates`](#0x3_staking_pool_exchange_rates)
-  [Function `iota_amount`](#0x3_staking_pool_iota_amount)
-  [Function `pool_token_amount`](#0x3_staking_pool_pool_token_amount)
-  [Function `is_preactive_at_epoch`](#0x3_staking_pool_is_preactive_at_epoch)
-  [Function `get_iota_amount`](#0x3_staking_pool_get_iota_amount)
-  [Function `get_token_amount`](#0x3_staking_pool_get_token_amount)
-  [Function `initial_exchange_rate`](#0x3_staking_pool_initial_exchange_rate)
-  [Function `check_balance_invariants`](#0x3_staking_pool_check_balance_invariants)


<pre>
<code>
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../iota-framework/bag#0x2_bag">0x2::bag</Link>;
<b>use</b> <Link to="../iota-framework/balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link to="../iota-framework/iota#0x2_iota">0x2::iota</Link>;
<b>use</b> <Link to="../iota-framework/math#0x2_math">0x2::math</Link>;
<b>use</b> <Link to="../iota-framework/object#0x2_object">0x2::object</Link>;
<b>use</b> <Link to="../iota-framework/table#0x2_table">0x2::table</Link>;
<b>use</b> <Link to="../iota-framework/transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link to="../iota-framework/tx_context#0x2_tx_context">0x2::tx_context</Link>;
</code>
</pre>



<Link id="0x3_staking_pool_StakingPool"></Link>

## Resource `StakingPool`

A staking pool embedded in each validator struct in the system state object.


<pre>
<code>
<b>struct</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link> <b>has</b> store, key
</code>
</pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>id: <Link to="../iota-framework/object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>activation_epoch: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;</code>
</dt>
<dd>
 The epoch at which this pool became active.
 The value is <code>None</code> if the pool is pre-active and <code>Some(&lt;epoch_number&gt;)</code> if active or inactive.
</dd>
<dt>
<code>deactivation_epoch: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;</code>
</dt>
<dd>
 The epoch at which this staking pool ceased to be active. <code>None</code> = \{pre-active, active},
 <code>Some(&lt;epoch_number&gt;)</code> if in-active, and it was de-activated at epoch <code>&lt;epoch_number&gt;</code>.
</dd>
<dt>
<code>iota_balance: u64</code>
</dt>
<dd>
 The total number of IOTA tokens in this pool, including the IOTA in the rewards_pool, as well as in all the principal
 in the <code><Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link></code> object, updated at epoch boundaries.
</dd>
<dt>
<code>rewards_pool: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>
 The epoch stake rewards will be added here at the end of each epoch.
</dd>
<dt>
<code>pool_token_balance: u64</code>
</dt>
<dd>
 Total number of pool tokens issued by the pool.
</dd>
<dt>
<code>exchange_rates: <Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;u64, <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>&gt;</code>
</dt>
<dd>
 Exchange rate history of previous epochs. Key is the epoch number.
 The entries start from the <code>activation_epoch</code> of this pool and contains exchange rates at the beginning of each epoch,
 i.e., right after the rewards for the previous epoch have been deposited into the pool.
</dd>
<dt>
<code>pending_stake: u64</code>
</dt>
<dd>
 Pending stake amount for this epoch, emptied at epoch boundaries.
</dd>
<dt>
<code>pending_total_iota_withdraw: u64</code>
</dt>
<dd>
 Pending stake withdrawn during the current epoch, emptied at epoch boundaries.
 This includes both the principal and rewards IOTA withdrawn.
</dd>
<dt>
<code>pending_pool_token_withdraw: u64</code>
</dt>
<dd>
 Pending pool token withdrawn during the current epoch, emptied at epoch boundaries.
</dd>
<dt>
<code>extra_fields: <Link to="../iota-framework/bag#0x2_bag_Bag">bag::Bag</Link></code>
</dt>
<dd>
 Any extra fields that's not defined statically.
</dd>
</dl>


</details>

<Link id="0x3_staking_pool_PoolTokenExchangeRate"></Link>

## Struct `PoolTokenExchangeRate`

Struct representing the exchange rate of the stake pool token to IOTA.


<pre>
<code>
<b>struct</b> <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link> <b>has</b> <b>copy</b>, drop, store
</code>
</pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>iota_amount: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>pool_token_amount: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x3_staking_pool_StakedIota"></Link>

## Resource `StakedIota`

A self-custodial object holding the staked IOTA tokens.


<pre>
<code>
<b>struct</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> <b>has</b> store, key
</code>
</pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>id: <Link to="../iota-framework/object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>pool_id: <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 ID of the staking pool we are staking with.
</dd>
<dt>
<code>stake_activation_epoch: u64</code>
</dt>
<dd>
 The epoch at which the stake becomes active.
</dd>
<dt>
<code>principal: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>
 The staked IOTA tokens.
</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x3_staking_pool_EActivationOfInactivePool"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EActivationOfInactivePool">EActivationOfInactivePool</Link>: u64 = 16;
</code>
</pre>



<Link id="0x3_staking_pool_EDeactivationOfInactivePool"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EDeactivationOfInactivePool">EDeactivationOfInactivePool</Link>: u64 = 11;
</code>
</pre>



<Link id="0x3_staking_pool_EDelegationOfZeroIota"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EDelegationOfZeroIota">EDelegationOfZeroIota</Link>: u64 = 17;
</code>
</pre>



<Link id="0x3_staking_pool_EDelegationToInactivePool"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EDelegationToInactivePool">EDelegationToInactivePool</Link>: u64 = 10;
</code>
</pre>



<Link id="0x3_staking_pool_EDestroyNonzeroBalance"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EDestroyNonzeroBalance">EDestroyNonzeroBalance</Link>: u64 = 5;
</code>
</pre>



<Link id="0x3_staking_pool_EIncompatibleStakedIota"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EIncompatibleStakedIota">EIncompatibleStakedIota</Link>: u64 = 12;
</code>
</pre>



<Link id="0x3_staking_pool_EInsufficientIotaTokenBalance"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EInsufficientIotaTokenBalance">EInsufficientIotaTokenBalance</Link>: u64 = 3;
</code>
</pre>



<Link id="0x3_staking_pool_EInsufficientPoolTokenBalance"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EInsufficientPoolTokenBalance">EInsufficientPoolTokenBalance</Link>: u64 = 0;
</code>
</pre>



<Link id="0x3_staking_pool_EInsufficientRewardsPoolBalance"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EInsufficientRewardsPoolBalance">EInsufficientRewardsPoolBalance</Link>: u64 = 4;
</code>
</pre>



<Link id="0x3_staking_pool_EPendingDelegationDoesNotExist"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EPendingDelegationDoesNotExist">EPendingDelegationDoesNotExist</Link>: u64 = 8;
</code>
</pre>



<Link id="0x3_staking_pool_EPoolAlreadyActive"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EPoolAlreadyActive">EPoolAlreadyActive</Link>: u64 = 14;
</code>
</pre>



<Link id="0x3_staking_pool_EPoolNotPreactive"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EPoolNotPreactive">EPoolNotPreactive</Link>: u64 = 15;
</code>
</pre>



<Link id="0x3_staking_pool_EStakedIotaBelowThreshold"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EStakedIotaBelowThreshold">EStakedIotaBelowThreshold</Link>: u64 = 18;
</code>
</pre>



<Link id="0x3_staking_pool_ETokenBalancesDoNotMatchExchangeRate"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_ETokenBalancesDoNotMatchExchangeRate">ETokenBalancesDoNotMatchExchangeRate</Link>: u64 = 9;
</code>
</pre>



<Link id="0x3_staking_pool_ETokenTimeLockIsSome"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_ETokenTimeLockIsSome">ETokenTimeLockIsSome</Link>: u64 = 6;
</code>
</pre>



<Link id="0x3_staking_pool_EWithdrawAmountCannotBeZero"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EWithdrawAmountCannotBeZero">EWithdrawAmountCannotBeZero</Link>: u64 = 2;
</code>
</pre>



<Link id="0x3_staking_pool_EWithdrawalInSameEpoch"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EWithdrawalInSameEpoch">EWithdrawalInSameEpoch</Link>: u64 = 13;
</code>
</pre>



<Link id="0x3_staking_pool_EWrongDelegation"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EWrongDelegation">EWrongDelegation</Link>: u64 = 7;
</code>
</pre>



<Link id="0x3_staking_pool_EWrongPool"></Link>



<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_EWrongPool">EWrongPool</Link>: u64 = 1;
</code>
</pre>



<Link id="0x3_staking_pool_MIN_STAKING_THRESHOLD"></Link>

StakedIota objects cannot be split to below this amount.


<pre>
<code>
<b>const</b> <Link to="staking_pool#0x3_staking_pool_MIN_STAKING_THRESHOLD">MIN_STAKING_THRESHOLD</Link>: u64 = 1000000000;
</code>
</pre>



<Link id="0x3_staking_pool_new"></Link>

## Function `new`

Create a new, empty staking pool.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_new">new</Link>(ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_new">new</Link>(ctx: &<b>mut</b> TxContext) : <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link> \{
    <b>let</b> exchange_rates = <Link to="../iota-framework/table#0x2_table_new">table::new</Link>(ctx);
    <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link> \{
        id: <Link to="../iota-framework/object#0x2_object_new">object::new</Link>(ctx),
        activation_epoch: <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
        deactivation_epoch: <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
        iota_balance: 0,
        rewards_pool: <Link to="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>(),
        pool_token_balance: 0,
        exchange_rates,
        pending_stake: 0,
        pending_total_iota_withdraw: 0,
        pending_pool_token_withdraw: 0,
        extra_fields: <Link to="../iota-framework/bag#0x2_bag_new">bag::new</Link>(ctx),
    }
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_request_add_stake"></Link>

## Function `request_add_stake`

Request to stake to a staking pool. The stake starts counting at the beginning of the next epoch,


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_request_add_stake">request_add_stake</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, stake: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, stake_activation_epoch: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_request_add_stake">request_add_stake</Link>(
    pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>,
    stake: Balance&lt;IOTA&gt;,
    stake_activation_epoch: u64,
    ctx: &<b>mut</b> TxContext
) : <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> \{
    <b>let</b> iota_amount = stake.value();
    <b>assert</b>!(!<Link to="staking_pool#0x3_staking_pool_is_inactive">is_inactive</Link>(pool), <Link to="staking_pool#0x3_staking_pool_EDelegationToInactivePool">EDelegationToInactivePool</Link>);
    <b>assert</b>!(iota_amount &gt; 0, <Link to="staking_pool#0x3_staking_pool_EDelegationOfZeroIota">EDelegationOfZeroIota</Link>);
    <b>let</b> staked_iota = <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> \{
        id: <Link to="../iota-framework/object#0x2_object_new">object::new</Link>(ctx),
        pool_id: <Link to="../iota-framework/object#0x2_object_id">object::id</Link>(pool),
        stake_activation_epoch,
        principal: stake,
    };
    pool.pending_stake = pool.pending_stake + iota_amount;
    staked_iota
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_request_withdraw_stake"></Link>

## Function `request_withdraw_stake`

Request to withdraw the given stake plus rewards from a staking pool.
Both the principal and corresponding rewards in IOTA are withdrawn.
A proportional amount of pool token withdraw is recorded and processed at epoch change time.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_request_withdraw_stake">request_withdraw_stake</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_request_withdraw_stake">request_withdraw_stake</Link>(
    pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>,
    staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>,
    ctx: &TxContext
) : Balance&lt;IOTA&gt; \{
    <b>let</b> (pool_token_withdraw_amount, <b>mut</b> principal_withdraw) =
        <Link to="staking_pool#0x3_staking_pool_withdraw_from_principal">withdraw_from_principal</Link>(pool, staked_iota);
    <b>let</b> principal_withdraw_amount = principal_withdraw.value();

    <b>let</b> rewards_withdraw = <Link to="staking_pool#0x3_staking_pool_withdraw_rewards">withdraw_rewards</Link>(
        pool, principal_withdraw_amount, pool_token_withdraw_amount, ctx.epoch()
    );
    <b>let</b> total_iota_withdraw_amount = principal_withdraw_amount + rewards_withdraw.value();

    pool.pending_total_iota_withdraw = pool.pending_total_iota_withdraw + total_iota_withdraw_amount;
    pool.pending_pool_token_withdraw = pool.pending_pool_token_withdraw + pool_token_withdraw_amount;

    // If the pool is inactive, we immediately process the withdrawal.
    <b>if</b> (<Link to="staking_pool#0x3_staking_pool_is_inactive">is_inactive</Link>(pool)) <Link to="staking_pool#0x3_staking_pool_process_pending_stake_withdraw">process_pending_stake_withdraw</Link>(pool);

    // TODO: implement withdraw bonding period here.
    principal_withdraw.join(rewards_withdraw);
    principal_withdraw
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_withdraw_from_principal"></Link>

## Function `withdraw_from_principal`

Withdraw the principal IOTA stored in the StakedIota object, and calculate the corresponding amount of pool
tokens using exchange rate at staking epoch.
Returns values are amount of pool tokens withdrawn and withdrawn principal portion of IOTA.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_withdraw_from_principal">withdraw_from_principal</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>): (u64, <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_withdraw_from_principal">withdraw_from_principal</Link>(
    pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>,
    staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>,
) : (u64, Balance&lt;IOTA&gt;) \{

    // Check that the stake information matches the pool.
    <b>assert</b>!(staked_iota.pool_id == <Link to="../iota-framework/object#0x2_object_id">object::id</Link>(pool), <Link to="staking_pool#0x3_staking_pool_EWrongPool">EWrongPool</Link>);

    <b>let</b> exchange_rate_at_staking_epoch = <Link to="staking_pool#0x3_staking_pool_pool_token_exchange_rate_at_epoch">pool_token_exchange_rate_at_epoch</Link>(pool, staked_iota.stake_activation_epoch);
    <b>let</b> principal_withdraw = <Link to="staking_pool#0x3_staking_pool_unwrap_staked_iota">unwrap_staked_iota</Link>(staked_iota);
    <b>let</b> pool_token_withdraw_amount = <Link to="staking_pool#0x3_staking_pool_get_token_amount">get_token_amount</Link>(
		&exchange_rate_at_staking_epoch,
		principal_withdraw.value()
	);

    (
        pool_token_withdraw_amount,
        principal_withdraw,
    )
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_unwrap_staked_iota"></Link>

## Function `unwrap_staked_iota`



<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_unwrap_staked_iota">unwrap_staked_iota</Link>(staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_unwrap_staked_iota">unwrap_staked_iota</Link>(staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>): Balance&lt;IOTA&gt; \{
    <b>let</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> \{
        id,
        pool_id: _,
        stake_activation_epoch: _,
        principal,
    } = staked_iota;
    <Link to="../iota-framework/object#0x2_object_delete">object::delete</Link>(id);
    principal
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_deposit_rewards"></Link>

## Function `deposit_rewards`

Called at epoch advancement times to add rewards (in IOTA) to the staking pool.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_deposit_rewards">deposit_rewards</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, rewards: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_deposit_rewards">deposit_rewards</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, rewards: Balance&lt;IOTA&gt;) \{
    pool.iota_balance = pool.iota_balance + rewards.value();
    pool.rewards_pool.join(rewards);
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_process_pending_stakes_and_withdraws"></Link>

## Function `process_pending_stakes_and_withdraws`



<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_process_pending_stakes_and_withdraws">process_pending_stakes_and_withdraws</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_process_pending_stakes_and_withdraws">process_pending_stakes_and_withdraws</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, ctx: &TxContext) \{
    <b>let</b> new_epoch = ctx.epoch() + 1;
    <Link to="staking_pool#0x3_staking_pool_process_pending_stake_withdraw">process_pending_stake_withdraw</Link>(pool);
    <Link to="staking_pool#0x3_staking_pool_process_pending_stake">process_pending_stake</Link>(pool);
    pool.exchange_rates.add(
        new_epoch,
        <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link> \{ iota_amount: pool.iota_balance, pool_token_amount: pool.pool_token_balance },
    );
    <Link to="staking_pool#0x3_staking_pool_check_balance_invariants">check_balance_invariants</Link>(pool, new_epoch);
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_process_pending_stake_withdraw"></Link>

## Function `process_pending_stake_withdraw`

Called at epoch boundaries to process pending stake withdraws requested during the epoch.
Also called immediately upon withdrawal if the pool is inactive.


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_process_pending_stake_withdraw">process_pending_stake_withdraw</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_process_pending_stake_withdraw">process_pending_stake_withdraw</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>) \{
    pool.iota_balance = pool.iota_balance - pool.pending_total_iota_withdraw;
    pool.pool_token_balance = pool.pool_token_balance - pool.pending_pool_token_withdraw;
    pool.pending_total_iota_withdraw = 0;
    pool.pending_pool_token_withdraw = 0;
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_process_pending_stake"></Link>

## Function `process_pending_stake`

Called at epoch boundaries to process the pending stake.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_process_pending_stake">process_pending_stake</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_process_pending_stake">process_pending_stake</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>) \{
    // Use the most up <b>to</b> date exchange rate <b>with</b> the rewards deposited and withdraws effectuated.
    <b>let</b> latest_exchange_rate =
        <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link> \{ iota_amount: pool.iota_balance, pool_token_amount: pool.pool_token_balance };
    pool.iota_balance = pool.iota_balance + pool.pending_stake;
    pool.pool_token_balance = <Link to="staking_pool#0x3_staking_pool_get_token_amount">get_token_amount</Link>(&latest_exchange_rate, pool.iota_balance);
    pool.pending_stake = 0;
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_withdraw_rewards"></Link>

## Function `withdraw_rewards`

This function does the following:
1. Calculates the total amount of IOTA (including principal and rewards) that the provided pool tokens represent
at the current exchange rate.
2. Using the above number and the given <code>principal_withdraw_amount</code>, calculates the rewards portion of the
stake we should withdraw.
3. Withdraws the rewards portion from the rewards pool at the current exchange rate. We only withdraw the rewards
portion because the principal portion was already taken out of the staker's self custodied StakedIota.


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_withdraw_rewards">withdraw_rewards</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, principal_withdraw_amount: u64, pool_token_withdraw_amount: u64, epoch: u64): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_withdraw_rewards">withdraw_rewards</Link>(
    pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>,
    principal_withdraw_amount: u64,
    pool_token_withdraw_amount: u64,
    epoch: u64,
) : Balance&lt;IOTA&gt; \{
    <b>let</b> exchange_rate = <Link to="staking_pool#0x3_staking_pool_pool_token_exchange_rate_at_epoch">pool_token_exchange_rate_at_epoch</Link>(pool, epoch);
    <b>let</b> total_iota_withdraw_amount = <Link to="staking_pool#0x3_staking_pool_get_iota_amount">get_iota_amount</Link>(&exchange_rate, pool_token_withdraw_amount);
    <b>let</b> <b>mut</b> reward_withdraw_amount =
        <b>if</b> (total_iota_withdraw_amount &gt;= principal_withdraw_amount)
            total_iota_withdraw_amount - principal_withdraw_amount
        <b>else</b> 0;
    // This may happen when we are withdrawing everything from the pool and
    // the rewards pool <Link to="../iota-framework/balance#0x2_balance">balance</Link> may be less than reward_withdraw_amount.
    // TODO: FIGURE OUT EXACTLY WHY THIS CAN HAPPEN.
    reward_withdraw_amount = <Link to="../iota-framework/math#0x2_math_min">math::min</Link>(reward_withdraw_amount, pool.rewards_pool.value());
    pool.rewards_pool.<Link to="staking_pool#0x3_staking_pool_split">split</Link>(reward_withdraw_amount)
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_activate_staking_pool"></Link>

## Function `activate_staking_pool`

Called by <code><Link to="validator#0x3_validator">validator</Link></code> module to activate a staking pool.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_activate_staking_pool">activate_staking_pool</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, activation_epoch: u64)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_activate_staking_pool">activate_staking_pool</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, activation_epoch: u64) \{
    // Add the initial exchange rate <b>to</b> the <Link to="../iota-framework/table#0x2_table">table</Link>.
    pool.exchange_rates.add(
        activation_epoch,
        <Link to="staking_pool#0x3_staking_pool_initial_exchange_rate">initial_exchange_rate</Link>()
    );
    // Check that the pool is preactive and not inactive.
    <b>assert</b>!(<Link to="staking_pool#0x3_staking_pool_is_preactive">is_preactive</Link>(pool), <Link to="staking_pool#0x3_staking_pool_EPoolAlreadyActive">EPoolAlreadyActive</Link>);
    <b>assert</b>!(!<Link to="staking_pool#0x3_staking_pool_is_inactive">is_inactive</Link>(pool), <Link to="staking_pool#0x3_staking_pool_EActivationOfInactivePool">EActivationOfInactivePool</Link>);
    // Fill in the active epoch.
    pool.activation_epoch.fill(activation_epoch);
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_deactivate_staking_pool"></Link>

## Function `deactivate_staking_pool`

Deactivate a staking pool by setting the <code>deactivation_epoch</code>. After
this pool deactivation, the pool stops earning rewards. Only stake
withdraws can be made to the pool.


<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_deactivate_staking_pool">deactivate_staking_pool</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, deactivation_epoch: u64)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_deactivate_staking_pool">deactivate_staking_pool</Link>(pool: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, deactivation_epoch: u64) \{
    // We can't deactivate an already deactivated pool.
    <b>assert</b>!(!<Link to="staking_pool#0x3_staking_pool_is_inactive">is_inactive</Link>(pool), <Link to="staking_pool#0x3_staking_pool_EDeactivationOfInactivePool">EDeactivationOfInactivePool</Link>);
    pool.deactivation_epoch = <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(deactivation_epoch);
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_iota_balance"></Link>

## Function `iota_balance`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_iota_balance">iota_balance</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_iota_balance">iota_balance</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>): u64 \{ pool.iota_balance }
</code>
</pre>



</details>

<Link id="0x3_staking_pool_pool_id"></Link>

## Function `pool_id`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pool_id">pool_id</Link>(staked_iota: &<Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>): <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pool_id">pool_id</Link>(staked_iota: &<Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>): ID \{ staked_iota.pool_id }
</code>
</pre>



</details>

<Link id="0x3_staking_pool_staked_iota_amount"></Link>

## Function `staked_iota_amount`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_staked_iota_amount">staked_iota_amount</Link>(staked_iota: &<Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_staked_iota_amount">staked_iota_amount</Link>(staked_iota: &<Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>): u64 \{ staked_iota.principal.value() }
</code>
</pre>



</details>

<Link id="0x3_staking_pool_stake_activation_epoch"></Link>

## Function `stake_activation_epoch`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_stake_activation_epoch">stake_activation_epoch</Link>(staked_iota: &<Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_stake_activation_epoch">stake_activation_epoch</Link>(staked_iota: &<Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>): u64 \{
    staked_iota.stake_activation_epoch
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_is_preactive"></Link>

## Function `is_preactive`

Returns true if the input staking pool is preactive.


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_preactive">is_preactive</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>): bool
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_preactive">is_preactive</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>): bool\{
    pool.activation_epoch.is_none()
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_is_inactive"></Link>

## Function `is_inactive`

Returns true if the input staking pool is inactive.


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_inactive">is_inactive</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>): bool
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_inactive">is_inactive</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>): bool \{
    pool.deactivation_epoch.is_some()
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_split"></Link>

## Function `split`

Split StakedIota <code>self</code> to two parts, one with principal <code>split_amount</code>,
and the remaining principal is left in <code>self</code>.
All the other parameters of the StakedIota like <code>stake_activation_epoch</code> or <code>pool_id</code> remain the same.


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_split">split</Link>(self: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, split_amount: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_split">split</Link>(self: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>, split_amount: u64, ctx: &<b>mut</b> TxContext): <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> \{
    <b>let</b> original_amount = self.principal.value();
    <b>assert</b>!(split_amount &lt;= original_amount, <Link to="staking_pool#0x3_staking_pool_EInsufficientIotaTokenBalance">EInsufficientIotaTokenBalance</Link>);
    <b>let</b> remaining_amount = original_amount - split_amount;
    // Both resulting parts should have at least <Link to="staking_pool#0x3_staking_pool_MIN_STAKING_THRESHOLD">MIN_STAKING_THRESHOLD</Link>.
    <b>assert</b>!(remaining_amount &gt;= <Link to="staking_pool#0x3_staking_pool_MIN_STAKING_THRESHOLD">MIN_STAKING_THRESHOLD</Link>, <Link to="staking_pool#0x3_staking_pool_EStakedIotaBelowThreshold">EStakedIotaBelowThreshold</Link>);
    <b>assert</b>!(split_amount &gt;= <Link to="staking_pool#0x3_staking_pool_MIN_STAKING_THRESHOLD">MIN_STAKING_THRESHOLD</Link>, <Link to="staking_pool#0x3_staking_pool_EStakedIotaBelowThreshold">EStakedIotaBelowThreshold</Link>);
    <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> \{
        id: <Link to="../iota-framework/object#0x2_object_new">object::new</Link>(ctx),
        pool_id: self.pool_id,
        stake_activation_epoch: self.stake_activation_epoch,
        principal: self.principal.<Link to="staking_pool#0x3_staking_pool_split">split</Link>(split_amount),
    }
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_split_staked_iota"></Link>

## Function `split_staked_iota`

Split the given StakedIota to the two parts, one with principal <code>split_amount</code>,
transfer the newly split part to the sender address.


<pre>
<code>
<b>public</b> entry <b>fun</b> <Link to="staking_pool#0x3_staking_pool_split_staked_iota">split_staked_iota</Link>(stake: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, split_amount: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> entry <b>fun</b> <Link to="staking_pool#0x3_staking_pool_split_staked_iota">split_staked_iota</Link>(stake: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>, split_amount: u64, ctx: &<b>mut</b> TxContext) \{
    <Link to="../iota-framework/transfer#0x2_transfer_transfer">transfer::transfer</Link>(<Link to="staking_pool#0x3_staking_pool_split">split</Link>(stake, split_amount, ctx), ctx.sender());
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_join_staked_iota"></Link>

## Function `join_staked_iota`

Consume the staked iota <code>other</code> and add its value to <code>self</code>.
Aborts if some of the staking parameters are incompatible (pool id, stake activation epoch, etc.)


<pre>
<code>
<b>public</b> entry <b>fun</b> <Link to="staking_pool#0x3_staking_pool_join_staked_iota">join_staked_iota</Link>(self: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, other: <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> entry <b>fun</b> <Link to="staking_pool#0x3_staking_pool_join_staked_iota">join_staked_iota</Link>(self: &<b>mut</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>, other: <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>) \{
    <b>assert</b>!(<Link to="staking_pool#0x3_staking_pool_is_equal_staking_metadata">is_equal_staking_metadata</Link>(self, &other), <Link to="staking_pool#0x3_staking_pool_EIncompatibleStakedIota">EIncompatibleStakedIota</Link>);
    <b>let</b> <Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link> \{
        id,
        pool_id: _,
        stake_activation_epoch: _,
        principal,
    } = other;

    id.delete();
    self.principal.join(principal);
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_is_equal_staking_metadata"></Link>

## Function `is_equal_staking_metadata`

Returns true if all the staking parameters of the staked iota except the principal are identical


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_equal_staking_metadata">is_equal_staking_metadata</Link>(self: &<Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, other: &<Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>): bool
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_equal_staking_metadata">is_equal_staking_metadata</Link>(self: &<Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>, other: &<Link to="staking_pool#0x3_staking_pool_StakedIota">StakedIota</Link>): bool \{
    (self.pool_id == other.pool_id) &&
    (self.stake_activation_epoch == other.stake_activation_epoch)
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_pool_token_exchange_rate_at_epoch"></Link>

## Function `pool_token_exchange_rate_at_epoch`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pool_token_exchange_rate_at_epoch">pool_token_exchange_rate_at_epoch</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, epoch: u64): <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pool_token_exchange_rate_at_epoch">pool_token_exchange_rate_at_epoch</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, epoch: u64): <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link> \{
    // If the pool is preactive then the exchange rate is always 1:1.
    <b>if</b> (<Link to="staking_pool#0x3_staking_pool_is_preactive_at_epoch">is_preactive_at_epoch</Link>(pool, epoch)) \{
        <b>return</b> <Link to="staking_pool#0x3_staking_pool_initial_exchange_rate">initial_exchange_rate</Link>()
    };
    <b>let</b> clamped_epoch = pool.deactivation_epoch.get_with_default(epoch);
    <b>let</b> <b>mut</b> epoch = <Link to="../iota-framework/math#0x2_math_min">math::min</Link>(clamped_epoch, epoch);
    <b>let</b> activation_epoch = *pool.activation_epoch.borrow();

    // Find the latest epoch that's earlier than the given epoch <b>with</b> an entry in the <Link to="../iota-framework/table#0x2_table">table</Link>
    <b>while</b> (epoch &gt;= activation_epoch) \{
        <b>if</b> (pool.exchange_rates.contains(epoch)) \{
            <b>return</b> pool.exchange_rates[epoch]
        };
        epoch = epoch - 1;
    };
    // This line really should be unreachable. Do we want an <b>assert</b> <b>false</b> here?
    <Link to="staking_pool#0x3_staking_pool_initial_exchange_rate">initial_exchange_rate</Link>()
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_pending_stake_amount"></Link>

## Function `pending_stake_amount`

Returns the total value of the pending staking requests for this staking pool.


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pending_stake_amount">pending_stake_amount</Link>(<Link to="staking_pool#0x3_staking_pool">staking_pool</Link>: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pending_stake_amount">pending_stake_amount</Link>(<Link to="staking_pool#0x3_staking_pool">staking_pool</Link>: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>): u64 \{
    <Link to="staking_pool#0x3_staking_pool">staking_pool</Link>.pending_stake
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_pending_stake_withdraw_amount"></Link>

## Function `pending_stake_withdraw_amount`

Returns the total withdrawal from the staking pool this epoch.


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pending_stake_withdraw_amount">pending_stake_withdraw_amount</Link>(<Link to="staking_pool#0x3_staking_pool">staking_pool</Link>: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pending_stake_withdraw_amount">pending_stake_withdraw_amount</Link>(<Link to="staking_pool#0x3_staking_pool">staking_pool</Link>: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>): u64 \{
    <Link to="staking_pool#0x3_staking_pool">staking_pool</Link>.pending_total_iota_withdraw
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_exchange_rates"></Link>

## Function `exchange_rates`



<pre>
<code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_exchange_rates">exchange_rates</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>): &<Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;u64, <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>&gt;
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b>(package) <b>fun</b> <Link to="staking_pool#0x3_staking_pool_exchange_rates">exchange_rates</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>): &Table&lt;u64, <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link>&gt; \{
    &pool.exchange_rates
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_iota_amount"></Link>

## Function `iota_amount`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_iota_amount">iota_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_iota_amount">iota_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link>): u64 \{
    exchange_rate.iota_amount
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_pool_token_amount"></Link>

## Function `pool_token_amount`



<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pool_token_amount">pool_token_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>public</b> <b>fun</b> <Link to="staking_pool#0x3_staking_pool_pool_token_amount">pool_token_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link>): u64 \{
    exchange_rate.pool_token_amount
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_is_preactive_at_epoch"></Link>

## Function `is_preactive_at_epoch`

Returns true if the provided staking pool is preactive at the provided epoch.


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_preactive_at_epoch">is_preactive_at_epoch</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, epoch: u64): bool
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_is_preactive_at_epoch">is_preactive_at_epoch</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, epoch: u64): bool\{
    // Either the pool is currently preactive or the pool's starting epoch is later than the provided epoch.
    <Link to="staking_pool#0x3_staking_pool_is_preactive">is_preactive</Link>(pool) || (*pool.activation_epoch.borrow() &gt; epoch)
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_get_iota_amount"></Link>

## Function `get_iota_amount`



<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_get_iota_amount">get_iota_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>, token_amount: u64): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_get_iota_amount">get_iota_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link>, token_amount: u64): u64 \{
    // When either amount is 0, that means we have no stakes <b>with</b> this pool.
    // The other amount might be non-zero when there's dust left in the pool.
    <b>if</b> (exchange_rate.iota_amount == 0 || exchange_rate.pool_token_amount == 0) \{
        <b>return</b> token_amount
    };
    <b>let</b> res = exchange_rate.iota_amount <b>as</b> u128
            * (token_amount <b>as</b> u128)
            / (exchange_rate.pool_token_amount <b>as</b> u128);
    res <b>as</b> u64
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_get_token_amount"></Link>

## Function `get_token_amount`



<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_get_token_amount">get_token_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>, iota_amount: u64): u64
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_get_token_amount">get_token_amount</Link>(exchange_rate: &<Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link>, iota_amount: u64): u64 \{
    // When either amount is 0, that means we have no stakes <b>with</b> this pool.
    // The other amount might be non-zero when there's dust left in the pool.
    <b>if</b> (exchange_rate.iota_amount == 0 || exchange_rate.pool_token_amount == 0) \{
        <b>return</b> iota_amount
    };
    <b>let</b> res = exchange_rate.pool_token_amount <b>as</b> u128
            * (iota_amount <b>as</b> u128)
            / (exchange_rate.iota_amount <b>as</b> u128);
    res <b>as</b> u64
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_initial_exchange_rate"></Link>

## Function `initial_exchange_rate`



<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_initial_exchange_rate">initial_exchange_rate</Link>(): <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_initial_exchange_rate">initial_exchange_rate</Link>(): <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link> \{
    <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">PoolTokenExchangeRate</Link> \{ iota_amount: 0, pool_token_amount: 0 }
}
</code>
</pre>



</details>

<Link id="0x3_staking_pool_check_balance_invariants"></Link>

## Function `check_balance_invariants`



<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_check_balance_invariants">check_balance_invariants</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">staking_pool::StakingPool</Link>, epoch: u64)
</code>
</pre>



<details>
<summary>Implementation</summary>


<pre>
<code>
<b>fun</b> <Link to="staking_pool#0x3_staking_pool_check_balance_invariants">check_balance_invariants</Link>(pool: &<Link to="staking_pool#0x3_staking_pool_StakingPool">StakingPool</Link>, epoch: u64) \{
    <b>let</b> exchange_rate = <Link to="staking_pool#0x3_staking_pool_pool_token_exchange_rate_at_epoch">pool_token_exchange_rate_at_epoch</Link>(pool, epoch);
    // check that the pool token <Link to="../iota-framework/balance#0x2_balance">balance</Link> and <Link to="../iota-framework/iota#0x2_iota">iota</Link> <Link to="../iota-framework/balance#0x2_balance">balance</Link> ratio matches the exchange rate stored.
    <b>let</b> expected = <Link to="staking_pool#0x3_staking_pool_get_token_amount">get_token_amount</Link>(&exchange_rate, pool.iota_balance);
    <b>let</b> actual = pool.pool_token_balance;
    <b>assert</b>!(expected == actual, <Link to="staking_pool#0x3_staking_pool_ETokenBalancesDoNotMatchExchangeRate">ETokenBalancesDoNotMatchExchangeRate</Link>)
}
</code>
</pre>



</details>
