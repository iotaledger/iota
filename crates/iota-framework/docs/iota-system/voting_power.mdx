---
title: Module `0x3::voting_power`
---
import Link from '@docusaurus/Link';

<Link id="0x3_voting_power"/>


-  [Struct `VotingPowerInfo`](#0x3_voting_power_VotingPowerInfo)
-  [Struct `VotingPowerInfoV2`](#0x3_voting_power_VotingPowerInfoV2)
-  [Constants](#@Constants_0)
-  [Function `set_voting_power`](#0x3_voting_power_set_voting_power)
-  [Function `init_voting_power_info`](#0x3_voting_power_init_voting_power_info)
-  [Function `total_stake`](#0x3_voting_power_total_stake)
-  [Function `insert`](#0x3_voting_power_insert)
-  [Function `adjust_voting_power`](#0x3_voting_power_adjust_voting_power)
-  [Function `update_voting_power`](#0x3_voting_power_update_voting_power)
-  [Function `check_invariants`](#0x3_voting_power_check_invariants)
-  [Function `total_voting_power`](#0x3_voting_power_total_voting_power)
-  [Function `quorum_threshold`](#0x3_voting_power_quorum_threshold)


<pre><code>
<b>use</b> <Link href="../move-stdlib/vector#0x1_vector">0x1::vector</Link>;
<b>use</b> <Link href="../iota-framework/math#0x2_math">0x2::math</Link>;
<b>use</b> <Link href="validator#0x3_validator">0x3::validator</Link>;
</code></pre>



<Link id="0x3_voting_power_VotingPowerInfo"></Link>

## Struct `VotingPowerInfo`

Deprecated. Use VotingPowerInfoV2 instead.


<pre><code>
<b>struct</b> <Link href="voting_power#0x3_voting_power_VotingPowerInfo">VotingPowerInfo</Link> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
validator_index: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link href="voting_power#0x3_voting_power">voting_power</Link>: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x3_voting_power_VotingPowerInfoV2"></Link>

## Struct `VotingPowerInfoV2`



<pre><code>
<b>struct</b> <Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link> <b>has</b> drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
validator_index: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link href="voting_power#0x3_voting_power">voting_power</Link>: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
stake: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x3_voting_power_EInvalidVotingPower"></Link>



<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_EInvalidVotingPower">EInvalidVotingPower</Link>: u64 = 4;
</code></pre>



<Link id="0x3_voting_power_ERelativePowerMismatch"></Link>



<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_ERelativePowerMismatch">ERelativePowerMismatch</Link>: u64 = 2;
</code></pre>



<Link id="0x3_voting_power_ETotalPowerMismatch"></Link>



<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_ETotalPowerMismatch">ETotalPowerMismatch</Link>: u64 = 1;
</code></pre>



<Link id="0x3_voting_power_EVotingPowerOverThreshold"></Link>



<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_EVotingPowerOverThreshold">EVotingPowerOverThreshold</Link>: u64 = 3;
</code></pre>



<Link id="0x3_voting_power_MAX_VOTING_POWER"></Link>



<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link>: u64 = 1000;
</code></pre>



<Link id="0x3_voting_power_QUORUM_THRESHOLD"></Link>

Quorum threshold for our fixed voting power--any message signed by this much voting power can be trusted
up to BFT assumptions


<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_QUORUM_THRESHOLD">QUORUM_THRESHOLD</Link>: u64 = 6667;
</code></pre>



<Link id="0x3_voting_power_TOTAL_VOTING_POWER"></Link>

Set total_voting_power as 10_000 by convention. Individual voting powers can be interpreted
as easily understandable basis points (e.g., voting_power: 100 = 1%, voting_power: 1 = 0.01%) rather than
opaque quantities whose meaning changes from epoch to epoch as the total amount staked shifts.
Fixing the total voting power allows clients to hardcode the quorum threshold and total_voting power rather
than recomputing these.


<pre><code>
<b>const</b> <Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>: u64 = 10000;
</code></pre>



<Link id="0x3_voting_power_set_voting_power"></Link>

## Function `set_voting_power`

Set the voting power of all validators.
Each validator's voting power is initialized using their stake. We then attempt to cap their voting power
at <code>
<Link href="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link></code>. If <code>
<Link href="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link></code> is not a feasible cap, we pick the lowest possible cap.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link href="voting_power#0x3_voting_power_set_voting_power">set_voting_power</Link>(validators: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="validator#0x3_validator_Validator">validator::Validator</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link href="voting_power#0x3_voting_power_set_voting_power">set_voting_power</Link>(validators: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;) \{
    // If threshold_pct is too small, it's possible that even when all validators reach the threshold we still don't
    // have 100%. So we bound the threshold_pct <b>to</b> be always enough <b>to</b> find a solution.
    <b>let</b> threshold = <Link href="../iota-framework/math#0x2_math_min">math::min</Link>(
        <Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>,
        <Link href="../iota-framework/math#0x2_math_max">math::max</Link>(<Link href="voting_power#0x3_voting_power_MAX_VOTING_POWER">MAX_VOTING_POWER</Link>, divide_and_round_up(<Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>, validators.length())),
    );
    <b>let</b> (<b>mut</b> info_list, remaining_power) = <Link href="voting_power#0x3_voting_power_init_voting_power_info">init_voting_power_info</Link>(validators, threshold);
    <Link href="voting_power#0x3_voting_power_adjust_voting_power">adjust_voting_power</Link>(&<b>mut</b> info_list, threshold, remaining_power);
    <Link href="voting_power#0x3_voting_power_update_voting_power">update_voting_power</Link>(validators, info_list);
    <Link href="voting_power#0x3_voting_power_check_invariants">check_invariants</Link>(validators);
}
</code></pre>



</details>

<Link id="0x3_voting_power_init_voting_power_info"></Link>

## Function `init_voting_power_info`

Create the initial voting power of each validator, set using their stake, but capped using threshold.
We also perform insertion sort while creating the voting power list, by maintaining the list in
descending order using voting power.
Anything beyond the threshold is added to the remaining_power, which is also returned.


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_init_voting_power_info">init_voting_power_info</Link>(validators: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, threshold: u64): (<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_init_voting_power_info">init_voting_power_info</Link>(
    validators: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    threshold: u64,
): (<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;, u64) \{
    <b>let</b> total_stake = <Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>(validators);
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = validators.length();
    <b>let</b> <b>mut</b> total_power = 0;
    <b>let</b> <b>mut</b> result = <Link href="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>while</b> (i &lt; len) \{
        <b>let</b> <Link href="validator#0x3_validator">validator</Link> = &validators[i];
        <b>let</b> stake = <Link href="validator#0x3_validator">validator</Link>.<Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
        <b>let</b> adjusted_stake = stake <b>as</b> u128 * (<Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link> <b>as</b> u128) / (total_stake <b>as</b> u128);
        <b>let</b> <Link href="voting_power#0x3_voting_power">voting_power</Link> = <Link href="../iota-framework/math#0x2_math_min">math::min</Link>(adjusted_stake <b>as</b> u64, threshold);
        <b>let</b> info = <Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link> \{
            validator_index: i,
            <Link href="voting_power#0x3_voting_power">voting_power</Link>,
            stake,
        };
        <Link href="voting_power#0x3_voting_power_insert">insert</Link>(&<b>mut</b> result, info);
        total_power = total_power + <Link href="voting_power#0x3_voting_power">voting_power</Link>;
        i = i + 1;
    };
    (result, <Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link> - total_power)
}
</code></pre>



</details>

<Link id="0x3_voting_power_total_stake"></Link>

## Function `total_stake`

Sum up the total stake of all validators.


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>(validators: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="validator#0x3_validator_Validator">validator::Validator</Link>&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>(validators: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;): u64 \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = validators.length();
    <b>let</b> <b>mut</b> total_stake =0 ;
    <b>while</b> (i &lt; len) \{
        total_stake = total_stake + validators[i].<Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
        i = i + 1;
    };
    total_stake
}
</code></pre>



</details>

<Link id="0x3_voting_power_insert"></Link>

## Function `insert`

Insert <code>
new_info</code> to <code>
info_list</code> as part of insertion sort, such that <code>
info_list</code> is always sorted
using stake, in descending order.


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_insert">insert</Link>(info_list: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;, new_info: <Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_insert">insert</Link>(info_list: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;, new_info: <Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>) \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = info_list.length();
    <b>while</b> (i &lt; len && info_list[i].stake &gt; new_info.stake) \{
        i = i + 1;
    };
    info_list.<Link href="voting_power#0x3_voting_power_insert">insert</Link>(new_info, i);
}
</code></pre>



</details>

<Link id="0x3_voting_power_adjust_voting_power"></Link>

## Function `adjust_voting_power`

Distribute remaining_power to validators that are not capped at threshold.


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_adjust_voting_power">adjust_voting_power</Link>(info_list: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;, threshold: u64, remaining_power: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_adjust_voting_power">adjust_voting_power</Link>(info_list: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;, threshold: u64, <b>mut</b> remaining_power: u64) \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = info_list.length();
    <b>while</b> (i &lt; len && remaining_power &gt; 0) \{
        <b>let</b> v = &<b>mut</b> info_list[i];
        // planned is the amount of extra power we want <b>to</b> distribute <b>to</b> this <Link href="validator#0x3_validator">validator</Link>.
        <b>let</b> planned = divide_and_round_up(remaining_power, len - i);
        // target is the targeting power this <Link href="validator#0x3_validator">validator</Link> will reach, capped by threshold.
        <b>let</b> target = <Link href="../iota-framework/math#0x2_math_min">math::min</Link>(threshold, v.<Link href="voting_power#0x3_voting_power">voting_power</Link> + planned);
        // actual is the actual amount of power we will be distributing <b>to</b> this <Link href="validator#0x3_validator">validator</Link>.
        <b>let</b> actual = <Link href="../iota-framework/math#0x2_math_min">math::min</Link>(remaining_power, target - v.<Link href="voting_power#0x3_voting_power">voting_power</Link>);
        v.<Link href="voting_power#0x3_voting_power">voting_power</Link> = v.<Link href="voting_power#0x3_voting_power">voting_power</Link> + actual;
        <b>assert</b>!(v.<Link href="voting_power#0x3_voting_power">voting_power</Link> &lt;= threshold, <Link href="voting_power#0x3_voting_power_EVotingPowerOverThreshold">EVotingPowerOverThreshold</Link>);
        remaining_power = remaining_power - actual;
        i = i + 1;
    };
    <b>assert</b>!(remaining_power == 0, <Link href="voting_power#0x3_voting_power_ETotalPowerMismatch">ETotalPowerMismatch</Link>);
}
</code></pre>



</details>

<Link id="0x3_voting_power_update_voting_power"></Link>

## Function `update_voting_power`

Update validators with the decided voting power.


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_update_voting_power">update_voting_power</Link>(validators: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, info_list: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">voting_power::VotingPowerInfoV2</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_update_voting_power">update_voting_power</Link>(validators: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, <b>mut</b> info_list: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link>&gt;) \{
    <b>while</b> (!info_list.is_empty()) \{
        <b>let</b> <Link href="voting_power#0x3_voting_power_VotingPowerInfoV2">VotingPowerInfoV2</Link> \{
            validator_index,
            <Link href="voting_power#0x3_voting_power">voting_power</Link>,
            stake: _,
        } = info_list.pop_back();
        <b>let</b> v = &<b>mut</b> validators[validator_index];
        v.<Link href="voting_power#0x3_voting_power_set_voting_power">set_voting_power</Link>(<Link href="voting_power#0x3_voting_power">voting_power</Link>);
    };
    info_list.destroy_empty();
}
</code></pre>



</details>

<Link id="0x3_voting_power_check_invariants"></Link>

## Function `check_invariants`

Check a few invariants that must hold after setting the voting power.


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_check_invariants">check_invariants</Link>(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="validator#0x3_validator_Validator">validator::Validator</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="voting_power#0x3_voting_power_check_invariants">check_invariants</Link>(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;) \{
    // First check that the total voting power must be <Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>.
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = v.length();
    <b>let</b> <b>mut</b> total = 0;
    <b>while</b> (i &lt; len) \{
        <b>let</b> <Link href="voting_power#0x3_voting_power">voting_power</Link> = v[i].<Link href="voting_power#0x3_voting_power">voting_power</Link>();
        <b>assert</b>!(<Link href="voting_power#0x3_voting_power">voting_power</Link> &gt; 0, <Link href="voting_power#0x3_voting_power_EInvalidVotingPower">EInvalidVotingPower</Link>);
        total = total + <Link href="voting_power#0x3_voting_power">voting_power</Link>;
        i = i + 1;
    };
    <b>assert</b>!(total == <Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>, <Link href="voting_power#0x3_voting_power_ETotalPowerMismatch">ETotalPowerMismatch</Link>);

    // Second check that <b>if</b> <Link href="validator#0x3_validator">validator</Link> A's stake is larger than B's stake, A's voting power must be no less
    // than B's voting power; similarly, <b>if</b> A's stake is less than B's stake, A's voting power must be no larger
    // than B's voting power.
    <b>let</b> <b>mut</b> a = 0;
    <b>while</b> (a &lt; len) \{
        <b>let</b> <b>mut</b> b = a + 1;
        <b>while</b> (b &lt; len) \{
            <b>let</b> validator_a = &v[a];
            <b>let</b> validator_b = &v[b];
            <b>let</b> stake_a = validator_a.<Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
            <b>let</b> stake_b = validator_b.<Link href="voting_power#0x3_voting_power_total_stake">total_stake</Link>();
            <b>let</b> power_a = validator_a.<Link href="voting_power#0x3_voting_power">voting_power</Link>();
            <b>let</b> power_b = validator_b.<Link href="voting_power#0x3_voting_power">voting_power</Link>();
            <b>if</b> (stake_a &gt; stake_b) \{
                <b>assert</b>!(power_a &gt;= power_b, <Link href="voting_power#0x3_voting_power_ERelativePowerMismatch">ERelativePowerMismatch</Link>);
            };
            <b>if</b> (stake_a &lt; stake_b) \{
                <b>assert</b>!(power_a &lt;= power_b, <Link href="voting_power#0x3_voting_power_ERelativePowerMismatch">ERelativePowerMismatch</Link>);
            };
            b = b + 1;
        };
        a = a + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_voting_power_total_voting_power"></Link>

## Function `total_voting_power`

Return the (constant) total voting power


<pre><code>
<b>public</b> <b>fun</b> <Link href="voting_power#0x3_voting_power_total_voting_power">total_voting_power</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="voting_power#0x3_voting_power_total_voting_power">total_voting_power</Link>(): u64 \{
    <Link href="voting_power#0x3_voting_power_TOTAL_VOTING_POWER">TOTAL_VOTING_POWER</Link>
}
</code></pre>



</details>

<Link id="0x3_voting_power_quorum_threshold"></Link>

## Function `quorum_threshold`

Return the (constant) quorum threshold


<pre><code>
<b>public</b> <b>fun</b> <Link href="voting_power#0x3_voting_power_quorum_threshold">quorum_threshold</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="voting_power#0x3_voting_power_quorum_threshold">quorum_threshold</Link>(): u64 \{
    <Link href="voting_power#0x3_voting_power_QUORUM_THRESHOLD">QUORUM_THRESHOLD</Link>
}
</code></pre>



</details>
