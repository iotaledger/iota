---
title: Module 0x3::validator_set
sidebar_label: validator_set
---
import Link from '@docusaurus/Link';

<Link id="0x3_validator_set"/>


-  [Struct `ValidatorSet`](#0x3_validator_set_ValidatorSet)
-  [Struct `ValidatorEpochInfoEvent`](#0x3_validator_set_ValidatorEpochInfoEvent)
-  [Struct `ValidatorEpochInfoEventV2`](#0x3_validator_set_ValidatorEpochInfoEventV2)
-  [Struct `ValidatorJoinEvent`](#0x3_validator_set_ValidatorJoinEvent)
-  [Struct `ValidatorLeaveEvent`](#0x3_validator_set_ValidatorLeaveEvent)
-  [Constants](#@Constants_0)
-  [Function `new`](#0x3_validator_set_new)
-  [Function `request_add_validator_candidate`](#0x3_validator_set_request_add_validator_candidate)
-  [Function `request_remove_validator_candidate`](#0x3_validator_set_request_remove_validator_candidate)
-  [Function `request_add_validator`](#0x3_validator_set_request_add_validator)
-  [Function `assert_no_pending_or_active_duplicates`](#0x3_validator_set_assert_no_pending_or_active_duplicates)
-  [Function `request_remove_validator`](#0x3_validator_set_request_remove_validator)
-  [Function `request_add_stake`](#0x3_validator_set_request_add_stake)
-  [Function `request_withdraw_stake`](#0x3_validator_set_request_withdraw_stake)
-  [Function `request_set_commission_rate`](#0x3_validator_set_request_set_commission_rate)
-  [Function `advance_epoch`](#0x3_validator_set_advance_epoch)
-  [Function `update_and_process_low_stake_departures`](#0x3_validator_set_update_and_process_low_stake_departures)
-  [Function `effectuate_staged_metadata`](#0x3_validator_set_effectuate_staged_metadata)
-  [Function `derive_reference_gas_price`](#0x3_validator_set_derive_reference_gas_price)
-  [Function `total_stake`](#0x3_validator_set_total_stake)
-  [Function `validator_total_stake_amount`](#0x3_validator_set_validator_total_stake_amount)
-  [Function `validator_stake_amount`](#0x3_validator_set_validator_stake_amount)
-  [Function `validator_staking_pool_id`](#0x3_validator_set_validator_staking_pool_id)
-  [Function `staking_pool_mappings`](#0x3_validator_set_staking_pool_mappings)
-  [Function `pool_exchange_rates`](#0x3_validator_set_pool_exchange_rates)
-  [Function `next_epoch_validator_count`](#0x3_validator_set_next_epoch_validator_count)
-  [Function `is_active_validator_by_iota_address`](#0x3_validator_set_is_active_validator_by_iota_address)
-  [Function `is_duplicate_with_active_validator`](#0x3_validator_set_is_duplicate_with_active_validator)
-  [Function `is_duplicate_validator`](#0x3_validator_set_is_duplicate_validator)
-  [Function `count_duplicates_vec`](#0x3_validator_set_count_duplicates_vec)
-  [Function `is_duplicate_with_pending_validator`](#0x3_validator_set_is_duplicate_with_pending_validator)
-  [Function `count_duplicates_tablevec`](#0x3_validator_set_count_duplicates_tablevec)
-  [Function `get_candidate_or_active_validator_mut`](#0x3_validator_set_get_candidate_or_active_validator_mut)
-  [Function `find_validator`](#0x3_validator_set_find_validator)
-  [Function `find_validator_from_table_vec`](#0x3_validator_set_find_validator_from_table_vec)
-  [Function `get_validator_indices`](#0x3_validator_set_get_validator_indices)
-  [Function `get_validator_mut`](#0x3_validator_set_get_validator_mut)
-  [Function `get_active_or_pending_or_candidate_validator_mut`](#0x3_validator_set_get_active_or_pending_or_candidate_validator_mut)
-  [Function `get_validator_mut_with_verified_cap`](#0x3_validator_set_get_validator_mut_with_verified_cap)
-  [Function `get_validator_mut_with_ctx`](#0x3_validator_set_get_validator_mut_with_ctx)
-  [Function `get_validator_mut_with_ctx_including_candidates`](#0x3_validator_set_get_validator_mut_with_ctx_including_candidates)
-  [Function `get_validator_ref`](#0x3_validator_set_get_validator_ref)
-  [Function `get_active_or_pending_or_candidate_validator_ref`](#0x3_validator_set_get_active_or_pending_or_candidate_validator_ref)
-  [Function `get_active_validator_ref`](#0x3_validator_set_get_active_validator_ref)
-  [Function `get_pending_validator_ref`](#0x3_validator_set_get_pending_validator_ref)
-  [Function `verify_cap`](#0x3_validator_set_verify_cap)
-  [Function `process_pending_removals`](#0x3_validator_set_process_pending_removals)
-  [Function `process_validator_departure`](#0x3_validator_set_process_validator_departure)
-  [Function `clean_report_records_leaving_validator`](#0x3_validator_set_clean_report_records_leaving_validator)
-  [Function `process_pending_validators`](#0x3_validator_set_process_pending_validators)
-  [Function `sort_removal_list`](#0x3_validator_set_sort_removal_list)
-  [Function `process_pending_stakes_and_withdraws`](#0x3_validator_set_process_pending_stakes_and_withdraws)
-  [Function `calculate_total_stakes`](#0x3_validator_set_calculate_total_stakes)
-  [Function `adjust_stake_and_gas_price`](#0x3_validator_set_adjust_stake_and_gas_price)
-  [Function `compute_reward_adjustments`](#0x3_validator_set_compute_reward_adjustments)
-  [Function `compute_slashed_validators`](#0x3_validator_set_compute_slashed_validators)
-  [Function `compute_unadjusted_reward_distribution`](#0x3_validator_set_compute_unadjusted_reward_distribution)
-  [Function `compute_adjusted_reward_distribution`](#0x3_validator_set_compute_adjusted_reward_distribution)
-  [Function `distribute_reward`](#0x3_validator_set_distribute_reward)
-  [Function `emit_validator_epoch_events`](#0x3_validator_set_emit_validator_epoch_events)
-  [Function `sum_voting_power_by_addresses`](#0x3_validator_set_sum_voting_power_by_addresses)
-  [Function `active_validators`](#0x3_validator_set_active_validators)
-  [Function `is_validator_candidate`](#0x3_validator_set_is_validator_candidate)
-  [Function `is_inactive_validator`](#0x3_validator_set_is_inactive_validator)
-  [Function `active_validator_addresses`](#0x3_validator_set_active_validator_addresses)


<pre><code>
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../move-stdlib/vector#0x1_vector">0x1::vector</Link>;
<b>use</b> <Link to="../iota-framework/bag#0x2_bag">0x2::bag</Link>;
<b>use</b> <Link to="../iota-framework/balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link to="../iota-framework/event#0x2_event">0x2::event</Link>;
<b>use</b> <Link to="../iota-framework/iota#0x2_iota">0x2::iota</Link>;
<b>use</b> <Link to="../iota-framework/object#0x2_object">0x2::object</Link>;
<b>use</b> <Link to="../iota-framework/priority_queue#0x2_priority_queue">0x2::priority_queue</Link>;
<b>use</b> <Link to="../iota-framework/table#0x2_table">0x2::table</Link>;
<b>use</b> <Link to="../iota-framework/table_vec#0x2_table_vec">0x2::table_vec</Link>;
<b>use</b> <Link to="../iota-framework/transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link to="../iota-framework/tx_context#0x2_tx_context">0x2::tx_context</Link>;
<b>use</b> <Link to="../iota-framework/vec_map#0x2_vec_map">0x2::vec_map</Link>;
<b>use</b> <Link to="../iota-framework/vec_set#0x2_vec_set">0x2::vec_set</Link>;
<b>use</b> <Link to="staking_pool#0x3_staking_pool">0x3::staking_pool</Link>;
<b>use</b> <Link to="validator#0x3_validator">0x3::validator</Link>;
<b>use</b> <Link to="validator_cap#0x3_validator_cap">0x3::validator_cap</Link>;
<b>use</b> <Link to="validator_wrapper#0x3_validator_wrapper">0x3::validator_wrapper</Link>;
<b>use</b> <Link to="voting_power#0x3_voting_power">0x3::voting_power</Link>;
</code></pre>



<Link id="0x3_validator_set_ValidatorSet"></Link>

## Struct `ValidatorSet`



<pre><code>
<b>struct</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

total_stake: u64
</dt>
<dd>
 Total amount of stake from all active validators at the beginning of the epoch.
</dd>
<dt>

active_validators: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;
</dt>
<dd>
 The current list of active validators.
</dd>
<dt>

pending_active_validators: <Link to="../iota-framework/table_vec#0x2_table_vec_TableVec">table_vec::TableVec</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;
</dt>
<dd>
 List of new validator candidates added during the current epoch.
 They will be processed at the end of the epoch.
</dd>
<dt>

pending_removals: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;
</dt>
<dd>
 Removal requests from the validators. Each element is an index
 pointing to 
active_validators.
</dd>
<dt>

staking_pool_mappings: <Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;<Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>, <b>address</b>&gt;
</dt>
<dd>
 Mappings from staking pool's ID to the iota address of a validator.
</dd>
<dt>

inactive_validators: <Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;<Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>, <Link to="validator_wrapper#0x3_validator_wrapper_ValidatorWrapper">validator_wrapper::ValidatorWrapper</Link>&gt;
</dt>
<dd>
 Mapping from a staking pool ID to the inactive validator that has that pool as its staking pool.
 When a validator is deactivated the validator is removed from 
active_validators it
 is added to this table so that stakers can continue to withdraw their stake from it.
</dd>
<dt>

validator_candidates: <Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;<b>address</b>, <Link to="validator_wrapper#0x3_validator_wrapper_ValidatorWrapper">validator_wrapper::ValidatorWrapper</Link>&gt;
</dt>
<dd>
 Table storing preactive/candidate validators, mapping their addresses to their 
Validator  structs.
 When an address calls 
request_add_validator_candidate, they get added to this table and become a preactive
 validator.
 When the candidate has met the min stake requirement, they can call 
request_add_validator to
 officially add them to the active validator set 
active_validators next epoch.
</dd>
<dt>

at_risk_validators: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, u64&gt;
</dt>
<dd>
 Table storing the number of epochs during which a validator's stake has been below the low stake threshold.
</dd>
<dt>

extra_fields: <Link to="../iota-framework/bag#0x2_bag_Bag">bag::Bag</Link>
</dt>
<dd>
 Any extra fields that's not defined statically.
</dd>
</dl>


</details>

<Link id="0x3_validator_set_ValidatorEpochInfoEvent"></Link>

## Struct `ValidatorEpochInfoEvent`

Event containing staking and rewards related information of
each validator, emitted during epoch advancement.


<pre><code>
<b>struct</b> <Link to="validator_set#0x3_validator_set_ValidatorEpochInfoEvent">ValidatorEpochInfoEvent</Link> <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

epoch: u64
</dt>
<dd>

</dd>
<dt>

validator_address: <b>address</b>
</dt>
<dd>

</dd>
<dt>

reference_gas_survey_quote: u64
</dt>
<dd>

</dd>
<dt>

stake: u64
</dt>
<dd>

</dd>
<dt>

commission_rate: u64
</dt>
<dd>

</dd>
<dt>

pool_staking_reward: u64
</dt>
<dd>

</dd>
<dt>

pool_token_exchange_rate: <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>
</dt>
<dd>

</dd>
<dt>

tallying_rule_reporters: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;
</dt>
<dd>

</dd>
<dt>

tallying_rule_global_score: u64
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x3_validator_set_ValidatorEpochInfoEventV2"></Link>

## Struct `ValidatorEpochInfoEventV2`

V2 of ValidatorEpochInfoEvent containing more information about the validator.


<pre><code>
<b>struct</b> <Link to="validator_set#0x3_validator_set_ValidatorEpochInfoEventV2">ValidatorEpochInfoEventV2</Link> <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

epoch: u64
</dt>
<dd>

</dd>
<dt>

validator_address: <b>address</b>
</dt>
<dd>

</dd>
<dt>

reference_gas_survey_quote: u64
</dt>
<dd>

</dd>
<dt>

stake: u64
</dt>
<dd>

</dd>
<dt>

<Link to="voting_power#0x3_voting_power">voting_power</Link>: u64
</dt>
<dd>

</dd>
<dt>

commission_rate: u64
</dt>
<dd>

</dd>
<dt>

pool_staking_reward: u64
</dt>
<dd>

</dd>
<dt>

pool_token_exchange_rate: <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>
</dt>
<dd>

</dd>
<dt>

tallying_rule_reporters: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;
</dt>
<dd>

</dd>
<dt>

tallying_rule_global_score: u64
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x3_validator_set_ValidatorJoinEvent"></Link>

## Struct `ValidatorJoinEvent`

Event emitted every time a new validator joins the committee.
The epoch value corresponds to the first epoch this change takes place.


<pre><code>
<b>struct</b> <Link to="validator_set#0x3_validator_set_ValidatorJoinEvent">ValidatorJoinEvent</Link> <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

epoch: u64
</dt>
<dd>

</dd>
<dt>

validator_address: <b>address</b>
</dt>
<dd>

</dd>
<dt>

staking_pool_id: <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x3_validator_set_ValidatorLeaveEvent"></Link>

## Struct `ValidatorLeaveEvent`

Event emitted every time a validator leaves the committee.
The epoch value corresponds to the first epoch this change takes place.


<pre><code>
<b>struct</b> <Link to="validator_set#0x3_validator_set_ValidatorLeaveEvent">ValidatorLeaveEvent</Link> <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

epoch: u64
</dt>
<dd>

</dd>
<dt>

validator_address: <b>address</b>
</dt>
<dd>

</dd>
<dt>

staking_pool_id: <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>
</dt>
<dd>

</dd>
<dt>

is_voluntary: bool
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x3_validator_set_MIN_STAKING_THRESHOLD"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_MIN_STAKING_THRESHOLD">MIN_STAKING_THRESHOLD</Link>: u64 = 1000000000;
</code></pre>



<Link id="0x3_validator_set_EInvalidCap"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EInvalidCap">EInvalidCap</Link>: u64 = 101;
</code></pre>



<Link id="0x3_validator_set_ENotValidatorCandidate"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ENotValidatorCandidate">ENotValidatorCandidate</Link>: u64 = 8;
</code></pre>



<Link id="0x3_validator_set_ACTIVE_OR_PENDING_VALIDATOR"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ACTIVE_OR_PENDING_VALIDATOR">ACTIVE_OR_PENDING_VALIDATOR</Link>: u8 = 2;
</code></pre>



<Link id="0x3_validator_set_ACTIVE_VALIDATOR_ONLY"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ACTIVE_VALIDATOR_ONLY">ACTIVE_VALIDATOR_ONLY</Link>: u8 = 1;
</code></pre>



<Link id="0x3_validator_set_ANY_VALIDATOR"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ANY_VALIDATOR">ANY_VALIDATOR</Link>: u8 = 3;
</code></pre>



<Link id="0x3_validator_set_BASIS_POINT_DENOMINATOR"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_BASIS_POINT_DENOMINATOR">BASIS_POINT_DENOMINATOR</Link>: u128 = 10000;
</code></pre>



<Link id="0x3_validator_set_EAlreadyValidatorCandidate"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EAlreadyValidatorCandidate">EAlreadyValidatorCandidate</Link>: u64 = 6;
</code></pre>



<Link id="0x3_validator_set_EDuplicateValidator"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EDuplicateValidator">EDuplicateValidator</Link>: u64 = 2;
</code></pre>



<Link id="0x3_validator_set_EInvalidStakeAdjustmentAmount"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EInvalidStakeAdjustmentAmount">EInvalidStakeAdjustmentAmount</Link>: u64 = 1;
</code></pre>



<Link id="0x3_validator_set_EMinJoiningStakeNotReached"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EMinJoiningStakeNotReached">EMinJoiningStakeNotReached</Link>: u64 = 5;
</code></pre>



<Link id="0x3_validator_set_ENoPoolFound"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ENoPoolFound">ENoPoolFound</Link>: u64 = 3;
</code></pre>



<Link id="0x3_validator_set_ENonValidatorInReportRecords"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ENonValidatorInReportRecords">ENonValidatorInReportRecords</Link>: u64 = 0;
</code></pre>



<Link id="0x3_validator_set_ENotAPendingValidator"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ENotAPendingValidator">ENotAPendingValidator</Link>: u64 = 12;
</code></pre>



<Link id="0x3_validator_set_ENotAValidator"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ENotAValidator">ENotAValidator</Link>: u64 = 4;
</code></pre>



<Link id="0x3_validator_set_ENotActiveOrPendingValidator"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_ENotActiveOrPendingValidator">ENotActiveOrPendingValidator</Link>: u64 = 9;
</code></pre>



<Link id="0x3_validator_set_EStakingBelowThreshold"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EStakingBelowThreshold">EStakingBelowThreshold</Link>: u64 = 10;
</code></pre>



<Link id="0x3_validator_set_EValidatorAlreadyRemoved"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EValidatorAlreadyRemoved">EValidatorAlreadyRemoved</Link>: u64 = 11;
</code></pre>



<Link id="0x3_validator_set_EValidatorNotCandidate"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EValidatorNotCandidate">EValidatorNotCandidate</Link>: u64 = 7;
</code></pre>



<Link id="0x3_validator_set_EValidatorSetEmpty"></Link>



<pre><code>
<b>const</b> <Link to="validator_set#0x3_validator_set_EValidatorSetEmpty">EValidatorSetEmpty</Link>: u64 = 13;
</code></pre>



<Link id="0x3_validator_set_new"></Link>

## Function `new`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_new">new</Link>(init_active_validators: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_new">new</Link>(init_active_validators: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, ctx: &<b>mut</b> TxContext): <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link> \{
    <b>let</b> total_stake = <Link to="validator_set#0x3_validator_set_calculate_total_stakes">calculate_total_stakes</Link>(&init_active_validators);
    <b>let</b> <b>mut</b> staking_pool_mappings = <Link to="../iota-framework/table#0x2_table_new">table::new</Link>(ctx);
    <b>let</b> num_validators = init_active_validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; num_validators) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &init_active_validators[i];
        staking_pool_mappings.add(staking_pool_id(<Link to="validator#0x3_validator">validator</Link>), iota_address(<Link to="validator#0x3_validator">validator</Link>));
        i = i + 1;
    };
    <b>let</b> <b>mut</b> validators = <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link> \{
        total_stake,
        active_validators: init_active_validators,
        pending_active_validators: <Link to="../iota-framework/table_vec#0x2_table_vec_empty">table_vec::empty</Link>(ctx),
        pending_removals: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[],
        staking_pool_mappings,
        inactive_validators: <Link to="../iota-framework/table#0x2_table_new">table::new</Link>(ctx),
        validator_candidates: <Link to="../iota-framework/table#0x2_table_new">table::new</Link>(ctx),
        at_risk_validators: <Link to="../iota-framework/vec_map#0x2_vec_map_empty">vec_map::empty</Link>(),
        extra_fields: <Link to="../iota-framework/bag#0x2_bag_new">bag::new</Link>(ctx),
    };
    <Link to="voting_power#0x3_voting_power_set_voting_power">voting_power::set_voting_power</Link>(&<b>mut</b> validators.active_validators);
    validators
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_add_validator_candidate"></Link>

## Function `request_add_validator_candidate`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link> to add a new validator candidate.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_add_validator_candidate">request_add_validator_candidate</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, <Link to="validator#0x3_validator">validator</Link>: <Link to="validator#0x3_validator_Validator">validator::Validator</Link>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_add_validator_candidate">request_add_validator_candidate</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    <Link to="validator#0x3_validator">validator</Link>: Validator,
    ctx: &<b>mut</b> TxContext,
) \{
    // The next assertions are not critical for the protocol, but they are here <b>to</b> catch problematic configs earlier.
    <b>assert</b>!(
        !<Link to="validator_set#0x3_validator_set_is_duplicate_with_active_validator">is_duplicate_with_active_validator</Link>(self, &<Link to="validator#0x3_validator">validator</Link>)
            && !<Link to="validator_set#0x3_validator_set_is_duplicate_with_pending_validator">is_duplicate_with_pending_validator</Link>(self, &<Link to="validator#0x3_validator">validator</Link>),
        <Link to="validator_set#0x3_validator_set_EDuplicateValidator">EDuplicateValidator</Link>
    );
    <b>let</b> validator_address = iota_address(&<Link to="validator#0x3_validator">validator</Link>);
    <b>assert</b>!(
        !self.validator_candidates.contains(validator_address),
        <Link to="validator_set#0x3_validator_set_EAlreadyValidatorCandidate">EAlreadyValidatorCandidate</Link>
    );

    <b>assert</b>!(<Link to="validator#0x3_validator">validator</Link>.is_preactive(), <Link to="validator_set#0x3_validator_set_EValidatorNotCandidate">EValidatorNotCandidate</Link>);
    // Add <Link to="validator#0x3_validator">validator</Link> <b>to</b> the candidates mapping and the pool id mappings so that users can start
    // staking <b>with</b> this candidate.
    self.staking_pool_mappings.add(staking_pool_id(&<Link to="validator#0x3_validator">validator</Link>), validator_address);
    self.validator_candidates.add(
        iota_address(&<Link to="validator#0x3_validator">validator</Link>),
        <Link to="validator_wrapper#0x3_validator_wrapper_create_v1">validator_wrapper::create_v1</Link>(<Link to="validator#0x3_validator">validator</Link>, ctx),
    );
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_remove_validator_candidate"></Link>

## Function `request_remove_validator_candidate`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link> to remove a validator candidate, and move them to 
inactive_validators.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_remove_validator_candidate">request_remove_validator_candidate</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_remove_validator_candidate">request_remove_validator_candidate</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, ctx: &<b>mut</b> TxContext) \{
    <b>let</b> validator_address = ctx.sender();
     <b>assert</b>!(
        self.validator_candidates.contains(validator_address),
        <Link to="validator_set#0x3_validator_set_ENotValidatorCandidate">ENotValidatorCandidate</Link>
    );
    <b>let</b> wrapper = self.validator_candidates.remove(validator_address);
    <b>let</b> <b>mut</b> <Link to="validator#0x3_validator">validator</Link> = wrapper.destroy();
    <b>assert</b>!(<Link to="validator#0x3_validator">validator</Link>.is_preactive(), <Link to="validator_set#0x3_validator_set_EValidatorNotCandidate">EValidatorNotCandidate</Link>);

    <b>let</b> staking_pool_id = staking_pool_id(&<Link to="validator#0x3_validator">validator</Link>);

    // Remove the <Link to="validator#0x3_validator">validator</Link>'s staking pool from mappings.
    self.staking_pool_mappings.remove(staking_pool_id);

    // Deactivate the staking pool.
    <Link to="validator#0x3_validator">validator</Link>.deactivate(ctx.epoch());

    // Add <b>to</b> the inactive tables.
    self.inactive_validators.add(
        staking_pool_id,
        <Link to="validator_wrapper#0x3_validator_wrapper_create_v1">validator_wrapper::create_v1</Link>(<Link to="validator#0x3_validator">validator</Link>, ctx),
    );
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_add_validator"></Link>

## Function `request_add_validator`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link> to add a new validator to 
pending_active_validators, which will be
processed at the end of epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_add_validator">request_add_validator</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, min_joining_stake_amount: u64, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_add_validator">request_add_validator</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, min_joining_stake_amount: u64, ctx: &TxContext) \{
    <b>let</b> validator_address = ctx.sender();
    <b>assert</b>!(
        self.validator_candidates.contains(validator_address),
        <Link to="validator_set#0x3_validator_set_ENotValidatorCandidate">ENotValidatorCandidate</Link>
    );
    <b>let</b> wrapper = self.validator_candidates.remove(validator_address);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = wrapper.destroy();
    <b>assert</b>!(
        !<Link to="validator_set#0x3_validator_set_is_duplicate_with_active_validator">is_duplicate_with_active_validator</Link>(self, &<Link to="validator#0x3_validator">validator</Link>)
            && !<Link to="validator_set#0x3_validator_set_is_duplicate_with_pending_validator">is_duplicate_with_pending_validator</Link>(self, &<Link to="validator#0x3_validator">validator</Link>),
        <Link to="validator_set#0x3_validator_set_EDuplicateValidator">EDuplicateValidator</Link>
    );
    <b>assert</b>!(<Link to="validator#0x3_validator">validator</Link>.is_preactive(), <Link to="validator_set#0x3_validator_set_EValidatorNotCandidate">EValidatorNotCandidate</Link>);
    <b>assert</b>!(<Link to="validator#0x3_validator">validator</Link>.total_stake_amount() &gt;= min_joining_stake_amount, <Link to="validator_set#0x3_validator_set_EMinJoiningStakeNotReached">EMinJoiningStakeNotReached</Link>);

    self.pending_active_validators.push_back(<Link to="validator#0x3_validator">validator</Link>);
}
</code></pre>



</details>

<Link id="0x3_validator_set_assert_no_pending_or_active_duplicates"></Link>

## Function `assert_no_pending_or_active_duplicates`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_assert_no_pending_or_active_duplicates">assert_no_pending_or_active_duplicates</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, <Link to="validator#0x3_validator">validator</Link>: &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_assert_no_pending_or_active_duplicates">assert_no_pending_or_active_duplicates</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, <Link to="validator#0x3_validator">validator</Link>: &Validator) \{
    // Validator here must be active or pending, and thus must be identified <b>as</b> duplicate exactly once.
    <b>assert</b>!(
        <Link to="validator_set#0x3_validator_set_count_duplicates_vec">count_duplicates_vec</Link>(&self.active_validators, <Link to="validator#0x3_validator">validator</Link>) +
            <Link to="validator_set#0x3_validator_set_count_duplicates_tablevec">count_duplicates_tablevec</Link>(&self.pending_active_validators, <Link to="validator#0x3_validator">validator</Link>) == 1,
        <Link to="validator_set#0x3_validator_set_EDuplicateValidator">EDuplicateValidator</Link>
    );
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_remove_validator"></Link>

## Function `request_remove_validator`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link>, to remove a validator.
The index of the validator is added to 
pending_removals and
will be processed at the end of epoch.
Only an active validator can request to be removed.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_remove_validator">request_remove_validator</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_remove_validator">request_remove_validator</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    ctx: &TxContext,
) \{
    <b>let</b> validator_address = ctx.sender();
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(&self.active_validators, validator_address);
    <b>assert</b>!(validator_index_opt.is_some(), <Link to="validator_set#0x3_validator_set_ENotAValidator">ENotAValidator</Link>);
    <b>let</b> validator_index = validator_index_opt.extract();
    <b>assert</b>!(
        !self.pending_removals.contains(&validator_index),
        <Link to="validator_set#0x3_validator_set_EValidatorAlreadyRemoved">EValidatorAlreadyRemoved</Link>
    );
    self.pending_removals.push_back(validator_index);
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_add_stake"></Link>

## Function `request_add_stake`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link>, to add a new stake to the validator.
This request is added to the validator's staking pool's pending stake entries, processed at the end
of the epoch.
Aborts in case the staking amount is smaller than MIN_STAKING_THRESHOLD


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_add_stake">request_add_stake</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>, stake: <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_add_stake">request_add_stake</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_address: <b>address</b>,
    stake: Balance&lt;IOTA&gt;,
    ctx: &<b>mut</b> TxContext,
) : StakedIota \{
    <b>let</b> iota_amount = stake.value();
    <b>assert</b>!(iota_amount &gt;= <Link to="validator_set#0x3_validator_set_MIN_STAKING_THRESHOLD">MIN_STAKING_THRESHOLD</Link>, <Link to="validator_set#0x3_validator_set_EStakingBelowThreshold">EStakingBelowThreshold</Link>);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator_set#0x3_validator_set_get_candidate_or_active_validator_mut">get_candidate_or_active_validator_mut</Link>(self, validator_address);
    <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_request_add_stake">request_add_stake</Link>(stake, ctx.sender(), ctx)
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_withdraw_stake"></Link>

## Function `request_withdraw_stake`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link>, to withdraw some share of a stake from the validator. The share to withdraw
is denoted by 
principal_withdraw_amount. One of two things occurs in this function:
1. If the 
staked_iota is staked with an active validator, the request is added to the validator's
staking pool's pending stake withdraw entries, processed at the end of the epoch.
2. If the 
staked_iota was staked with a validator that is no longer active,
the stake and any rewards corresponding to it will be immediately processed.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_withdraw_stake">request_withdraw_stake</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, staked_iota: <Link to="staking_pool#0x3_staking_pool_StakedIota">staking_pool::StakedIota</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_withdraw_stake">request_withdraw_stake</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    staked_iota: StakedIota,
    ctx: &TxContext,
) : Balance&lt;IOTA&gt; \{
    <b>let</b> staking_pool_id = pool_id(&staked_iota);
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> =
        <b>if</b> (self.staking_pool_mappings.contains(staking_pool_id)) \{ // This is an active <Link to="validator#0x3_validator">validator</Link>.
            <b>let</b> validator_address = self.staking_pool_mappings[pool_id(&staked_iota)];
            <Link to="validator_set#0x3_validator_set_get_candidate_or_active_validator_mut">get_candidate_or_active_validator_mut</Link>(self, validator_address)
        } <b>else</b> \{ // This is an inactive pool.
            <b>assert</b>!(self.inactive_validators.contains(staking_pool_id), <Link to="validator_set#0x3_validator_set_ENoPoolFound">ENoPoolFound</Link>);
            <b>let</b> wrapper = &<b>mut</b> self.inactive_validators[staking_pool_id];
            wrapper.load_validator_maybe_upgrade()
        };
    <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_request_withdraw_stake">request_withdraw_stake</Link>(staked_iota, ctx)
}
</code></pre>



</details>

<Link id="0x3_validator_set_request_set_commission_rate"></Link>

## Function `request_set_commission_rate`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_set_commission_rate">request_set_commission_rate</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, new_commission_rate: u64, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_request_set_commission_rate">request_set_commission_rate</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    new_commission_rate: u64,
    ctx: &TxContext,
) \{
    <b>let</b> validator_address = ctx.sender();
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator_set#0x3_validator_set_get_validator_mut">get_validator_mut</Link>(&<b>mut</b> self.active_validators, validator_address);
    <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_request_set_commission_rate">request_set_commission_rate</Link>(new_commission_rate);
}
</code></pre>



</details>

<Link id="0x3_validator_set_advance_epoch"></Link>

## Function `advance_epoch`

Update the validator set at the end of epoch.
It does the following things:
1. Distribute stake award.
2. Process pending stake deposits and withdraws for each validator (
adjust_stake).
3. Process pending stake deposits, and withdraws.
4. Process pending validator application and withdraws.
5. At the end, we calculate the total stake for the new epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_advance_epoch">advance_epoch</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, total_validator_rewards: &<b>mut</b> <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;, reward_slashing_rate: u64, low_stake_threshold: u64, very_low_stake_threshold: u64, low_stake_grace_period: u64, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_advance_epoch">advance_epoch</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    total_validator_rewards: &<b>mut</b> Balance&lt;IOTA&gt;,
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
    reward_slashing_rate: u64,
    low_stake_threshold: u64,
    very_low_stake_threshold: u64,
    low_stake_grace_period: u64,
    ctx: &<b>mut</b> TxContext,
) \{
    <b>let</b> new_epoch = ctx.epoch() + 1;
    <b>let</b> total_voting_power = <Link to="voting_power#0x3_voting_power_total_voting_power">voting_power::total_voting_power</Link>();

    // Compute the reward distribution without taking into account the tallying rule slashing.
    <b>let</b> unadjusted_staking_reward_amounts = <Link to="validator_set#0x3_validator_set_compute_unadjusted_reward_distribution">compute_unadjusted_reward_distribution</Link>(
        &self.active_validators,
        total_voting_power,
        total_validator_rewards.value(),
    );

    // Use the tallying rule report records for the epoch <b>to</b> compute validators that will be
    // punished.
    <b>let</b> slashed_validators = <Link to="validator_set#0x3_validator_set_compute_slashed_validators">compute_slashed_validators</Link>(self, *validator_report_records);

    <b>let</b> total_slashed_validator_voting_power = <Link to="validator_set#0x3_validator_set_sum_voting_power_by_addresses">sum_voting_power_by_addresses</Link>(&self.active_validators, &slashed_validators);

    // Compute the reward adjustments of slashed validators, <b>to</b> be taken into
    // account in adjusted reward computation.
    <b>let</b> (total_staking_reward_adjustment, individual_staking_reward_adjustments) =
        <Link to="validator_set#0x3_validator_set_compute_reward_adjustments">compute_reward_adjustments</Link>(
            <Link to="validator_set#0x3_validator_set_get_validator_indices">get_validator_indices</Link>(&self.active_validators, &slashed_validators),
            reward_slashing_rate,
            &unadjusted_staking_reward_amounts,
        );

    // Compute the adjusted amounts of stake each <Link to="validator#0x3_validator">validator</Link> should get given the tallying rule
    // reward adjustments we computed before.
    // `compute_adjusted_reward_distribution` must be called before `distribute_reward` and `adjust_stake_and_gas_price` <b>to</b>
    // make sure we are using the current epoch's stake information <b>to</b> compute reward distribution.
    <b>let</b> adjusted_staking_reward_amounts = <Link to="validator_set#0x3_validator_set_compute_adjusted_reward_distribution">compute_adjusted_reward_distribution</Link>(
        &self.active_validators,
        total_voting_power,
        total_slashed_validator_voting_power,
        unadjusted_staking_reward_amounts,
        total_staking_reward_adjustment,
        individual_staking_reward_adjustments,
    );

    // Distribute the rewards before adjusting stake so that we immediately start compounding
    // the rewards for validators and stakers.
    <Link to="validator_set#0x3_validator_set_distribute_reward">distribute_reward</Link>(
        &<b>mut</b> self.active_validators,
        &adjusted_staking_reward_amounts,
        total_validator_rewards,
        ctx
    );

    <Link to="validator_set#0x3_validator_set_adjust_stake_and_gas_price">adjust_stake_and_gas_price</Link>(&<b>mut</b> self.active_validators);

    <Link to="validator_set#0x3_validator_set_process_pending_stakes_and_withdraws">process_pending_stakes_and_withdraws</Link>(&<b>mut</b> self.active_validators, ctx);

    // Emit events after we have processed all the rewards distribution and pending stakes.
    <Link to="validator_set#0x3_validator_set_emit_validator_epoch_events">emit_validator_epoch_events</Link>(new_epoch, &self.active_validators, &adjusted_staking_reward_amounts,
        validator_report_records, &slashed_validators);

    // Note that all their staged next epoch metadata will be effectuated below.
    <Link to="validator_set#0x3_validator_set_process_pending_validators">process_pending_validators</Link>(self, new_epoch);

    <Link to="validator_set#0x3_validator_set_process_pending_removals">process_pending_removals</Link>(self, validator_report_records, ctx);

    // kick low stake validators out.
    <Link to="validator_set#0x3_validator_set_update_and_process_low_stake_departures">update_and_process_low_stake_departures</Link>(
        self,
        low_stake_threshold,
        very_low_stake_threshold,
        low_stake_grace_period,
        validator_report_records,
        ctx
    );

    self.total_stake = <Link to="validator_set#0x3_validator_set_calculate_total_stakes">calculate_total_stakes</Link>(&self.active_validators);

    <Link to="voting_power#0x3_voting_power_set_voting_power">voting_power::set_voting_power</Link>(&<b>mut</b> self.active_validators);

    // At this point, self.active_validators are updated for next epoch.
    // Now we process the staged <Link to="validator#0x3_validator">validator</Link> metadata.
    <Link to="validator_set#0x3_validator_set_effectuate_staged_metadata">effectuate_staged_metadata</Link>(self);
}
</code></pre>



</details>

<Link id="0x3_validator_set_update_and_process_low_stake_departures"></Link>

## Function `update_and_process_low_stake_departures`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_update_and_process_low_stake_departures">update_and_process_low_stake_departures</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, low_stake_threshold: u64, very_low_stake_threshold: u64, low_stake_grace_period: u64, validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_update_and_process_low_stake_departures">update_and_process_low_stake_departures</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    low_stake_threshold: u64,
    very_low_stake_threshold: u64,
    low_stake_grace_period: u64,
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
    ctx: &<b>mut</b> TxContext
) \{
    // Iterate through all the active validators, record their low stake status, and kick them out <b>if</b> the condition is met.
    <b>let</b> <b>mut</b> i = self.active_validators.length();
    <b>while</b> (i &gt; 0) \{
        i = i - 1;
        <b>let</b> validator_ref = &self.active_validators[i];
        <b>let</b> validator_address = validator_ref.iota_address();
        <b>let</b> stake = validator_ref.total_stake_amount();
        <b>if</b> (stake &gt;= low_stake_threshold) \{
            // The <Link to="validator#0x3_validator">validator</Link> is safe. We remove their entry from the at_risk map <b>if</b> there exists one.
            <b>if</b> (self.at_risk_validators.contains(&validator_address)) \{
               self.at_risk_validators.remove(&validator_address);
            }
        } <b>else</b> <b>if</b> (stake &gt;= very_low_stake_threshold) \{
            // The stake is a bit below the threshold so we increment the entry of the <Link to="validator#0x3_validator">validator</Link> in the map.
            <b>let</b> new_low_stake_period =
                <b>if</b> (self.at_risk_validators.contains(&validator_address)) \{
                    <b>let</b> num_epochs = &<b>mut</b> self.at_risk_validators[&validator_address];
                    *num_epochs = *num_epochs + 1;
                    *num_epochs
                } <b>else</b> \{
                    self.at_risk_validators.insert(validator_address, 1);
                    1
                };

            // If the grace period <b>has</b> passed, the <Link to="validator#0x3_validator">validator</Link> <b>has</b> <b>to</b> leave us.
            <b>if</b> (new_low_stake_period &gt; low_stake_grace_period) \{
                <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.active_validators.remove(i);
                <Link to="validator_set#0x3_validator_set_process_validator_departure">process_validator_departure</Link>(self, <Link to="validator#0x3_validator">validator</Link>, validator_report_records, <b>false</b> /* the <Link to="validator#0x3_validator">validator</Link> is kicked out involuntarily */, ctx);
            }
        } <b>else</b> \{
            // The <Link to="validator#0x3_validator">validator</Link>'s stake is lower than the very low threshold so we kick them out immediately.
            <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.active_validators.remove(i);
            <Link to="validator_set#0x3_validator_set_process_validator_departure">process_validator_departure</Link>(self, <Link to="validator#0x3_validator">validator</Link>, validator_report_records, <b>false</b> /* the <Link to="validator#0x3_validator">validator</Link> is kicked out involuntarily */, ctx);
        }
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_effectuate_staged_metadata"></Link>

## Function `effectuate_staged_metadata`

Effectutate pending next epoch metadata if they are staged.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_effectuate_staged_metadata">effectuate_staged_metadata</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_effectuate_staged_metadata">effectuate_staged_metadata</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
) \{
    <b>let</b> num_validators = self.active_validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; num_validators) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &<b>mut</b> self.active_validators[i];
        <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_effectuate_staged_metadata">effectuate_staged_metadata</Link>();
        i = i + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_derive_reference_gas_price"></Link>

## Function `derive_reference_gas_price`

Called by 
<Link to="iota_system#0x3_iota_system">iota_system</Link> to derive reference gas price for the new epoch.
Derive the reference gas price based on the gas price quote submitted by each validator.
The returned gas price should be greater than or equal to 2/3 of the validators submitted
gas price, weighted by stake.


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_derive_reference_gas_price">derive_reference_gas_price</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_derive_reference_gas_price">derive_reference_gas_price</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>): u64 \{
    <b>let</b> vs = &self.active_validators;
    <b>let</b> num_validators = vs.length();
    <b>let</b> <b>mut</b> entries = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; num_validators) \{
        <b>let</b> v = &vs[i];
        entries.push_back(
            pq::new_entry(v.gas_price(), v.<Link to="voting_power#0x3_voting_power">voting_power</Link>())
        );
        i = i + 1;
    };
    // Build a priority queue that will pop entries <b>with</b> gas price from the highest <b>to</b> the lowest.
    <b>let</b> <b>mut</b> pq = pq::new(entries);
    <b>let</b> <b>mut</b> sum = 0;
    <b>let</b> threshold = <Link to="voting_power#0x3_voting_power_total_voting_power">voting_power::total_voting_power</Link>() - <Link to="voting_power#0x3_voting_power_quorum_threshold">voting_power::quorum_threshold</Link>();
    <b>let</b> <b>mut</b> result = 0;
    <b>while</b> (sum &lt; threshold) \{
        <b>let</b> (gas_price, <Link to="voting_power#0x3_voting_power">voting_power</Link>) = pq.pop_max();
        result = gas_price;
        sum = sum + <Link to="voting_power#0x3_voting_power">voting_power</Link>;
    };
    result
}
</code></pre>



</details>

<Link id="0x3_validator_set_total_stake"></Link>

## Function `total_stake`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_total_stake">total_stake</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_total_stake">total_stake</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>): u64 \{
    self.total_stake
}
</code></pre>



</details>

<Link id="0x3_validator_set_validator_total_stake_amount"></Link>

## Function `validator_total_stake_amount`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_validator_total_stake_amount">validator_total_stake_amount</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_validator_total_stake_amount">validator_total_stake_amount</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, validator_address: <b>address</b>): u64 \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator_set#0x3_validator_set_get_validator_ref">get_validator_ref</Link>(&self.active_validators, validator_address);
    <Link to="validator#0x3_validator">validator</Link>.total_stake_amount()
}
</code></pre>



</details>

<Link id="0x3_validator_set_validator_stake_amount"></Link>

## Function `validator_stake_amount`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_validator_stake_amount">validator_stake_amount</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_validator_stake_amount">validator_stake_amount</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, validator_address: <b>address</b>): u64 \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator_set#0x3_validator_set_get_validator_ref">get_validator_ref</Link>(&self.active_validators, validator_address);
    <Link to="validator#0x3_validator">validator</Link>.stake_amount()
}
</code></pre>



</details>

<Link id="0x3_validator_set_validator_staking_pool_id"></Link>

## Function `validator_staking_pool_id`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_validator_staking_pool_id">validator_staking_pool_id</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_validator_staking_pool_id">validator_staking_pool_id</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, validator_address: <b>address</b>): ID \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator_set#0x3_validator_set_get_validator_ref">get_validator_ref</Link>(&self.active_validators, validator_address);
    <Link to="validator#0x3_validator">validator</Link>.staking_pool_id()
}
</code></pre>



</details>

<Link id="0x3_validator_set_staking_pool_mappings"></Link>

## Function `staking_pool_mappings`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_staking_pool_mappings">staking_pool_mappings</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>): &<Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;<Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>, <b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_staking_pool_mappings">staking_pool_mappings</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>): &Table&lt;ID, <b>address</b>&gt; \{
    &self.staking_pool_mappings
}
</code></pre>



</details>

<Link id="0x3_validator_set_pool_exchange_rates"></Link>

## Function `pool_exchange_rates`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_pool_exchange_rates">pool_exchange_rates</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, pool_id: &<Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>): &<Link to="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;u64, <Link to="staking_pool#0x3_staking_pool_PoolTokenExchangeRate">staking_pool::PoolTokenExchangeRate</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_pool_exchange_rates">pool_exchange_rates</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, pool_id: &ID
) : &Table&lt;u64, PoolTokenExchangeRate&gt; \{
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> =
        // If the pool id is recorded in the mapping, then it must be either candidate or active.
        <b>if</b> (self.staking_pool_mappings.contains(*pool_id)) \{
            <b>let</b> validator_address = self.staking_pool_mappings[*pool_id];
            <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_ref">get_active_or_pending_or_candidate_validator_ref</Link>(self, validator_address, <Link to="validator_set#0x3_validator_set_ANY_VALIDATOR">ANY_VALIDATOR</Link>)
        } <b>else</b> \{ // otherwise it's inactive
            <b>let</b> wrapper = &<b>mut</b> self.inactive_validators[*pool_id];
            wrapper.load_validator_maybe_upgrade()
        };
	<Link to="validator#0x3_validator">validator</Link>.get_staking_pool_ref().exchange_rates()
}
</code></pre>



</details>

<Link id="0x3_validator_set_next_epoch_validator_count"></Link>

## Function `next_epoch_validator_count`

Get the total number of validators in the next epoch.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_next_epoch_validator_count">next_epoch_validator_count</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_next_epoch_validator_count">next_epoch_validator_count</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>): u64 \{
    self.active_validators.length() - self.pending_removals.length() + self.pending_active_validators.length()
}
</code></pre>



</details>

<Link id="0x3_validator_set_is_active_validator_by_iota_address"></Link>

## Function `is_active_validator_by_iota_address`

Returns true iff the address exists in active validators.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_is_active_validator_by_iota_address">is_active_validator_by_iota_address</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_is_active_validator_by_iota_address">is_active_validator_by_iota_address</Link>(
    self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_address: <b>address</b>,
): bool \{
   <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(&self.active_validators, validator_address).is_some()
}
</code></pre>



</details>

<Link id="0x3_validator_set_is_duplicate_with_active_validator"></Link>

## Function `is_duplicate_with_active_validator`

Checks whether 
new_validator is duplicate with any currently active validators.
It differs from 
is_active_validator_by_iota_address in that the former checks
only the iota address but this function looks at more metadata.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_is_duplicate_with_active_validator">is_duplicate_with_active_validator</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, new_validator: &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_is_duplicate_with_active_validator">is_duplicate_with_active_validator</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, new_validator: &Validator): bool \{
    <Link to="validator_set#0x3_validator_set_is_duplicate_validator">is_duplicate_validator</Link>(&self.active_validators, new_validator)
}
</code></pre>



</details>

<Link id="0x3_validator_set_is_duplicate_validator"></Link>

## Function `is_duplicate_validator`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_is_duplicate_validator">is_duplicate_validator</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, new_validator: &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_is_duplicate_validator">is_duplicate_validator</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, new_validator: &Validator): bool \{
    <Link to="validator_set#0x3_validator_set_count_duplicates_vec">count_duplicates_vec</Link>(validators, new_validator) &gt; 0
}
</code></pre>



</details>

<Link id="0x3_validator_set_count_duplicates_vec"></Link>

## Function `count_duplicates_vec`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_count_duplicates_vec">count_duplicates_vec</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, <Link to="validator#0x3_validator">validator</Link>: &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_count_duplicates_vec">count_duplicates_vec</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, <Link to="validator#0x3_validator">validator</Link>: &Validator): u64 \{
    <b>let</b> len = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> <b>mut</b> result = 0;
    <b>while</b> (i &lt; len) \{
        <b>let</b> v = &validators[i];
        <b>if</b> (v.is_duplicate(<Link to="validator#0x3_validator">validator</Link>)) \{
            result = result + 1;
        };
        i = i + 1;
    };
    result
}
</code></pre>



</details>

<Link id="0x3_validator_set_is_duplicate_with_pending_validator"></Link>

## Function `is_duplicate_with_pending_validator`

Checks whether 
new_validator is duplicate with any currently pending validators.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_is_duplicate_with_pending_validator">is_duplicate_with_pending_validator</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, new_validator: &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_is_duplicate_with_pending_validator">is_duplicate_with_pending_validator</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, new_validator: &Validator): bool \{
    <Link to="validator_set#0x3_validator_set_count_duplicates_tablevec">count_duplicates_tablevec</Link>(&self.pending_active_validators, new_validator) &gt; 0
}
</code></pre>



</details>

<Link id="0x3_validator_set_count_duplicates_tablevec"></Link>

## Function `count_duplicates_tablevec`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_count_duplicates_tablevec">count_duplicates_tablevec</Link>(validators: &<Link to="../iota-framework/table_vec#0x2_table_vec_TableVec">table_vec::TableVec</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, <Link to="validator#0x3_validator">validator</Link>: &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_count_duplicates_tablevec">count_duplicates_tablevec</Link>(validators: &TableVec&lt;Validator&gt;, <Link to="validator#0x3_validator">validator</Link>: &Validator): u64 \{
    <b>let</b> len = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> <b>mut</b> result = 0;
    <b>while</b> (i &lt; len) \{
        <b>let</b> v = &validators[i];
        <b>if</b> (v.is_duplicate(<Link to="validator#0x3_validator">validator</Link>)) \{
            result = result + 1;
        };
        i = i + 1;
    };
    result
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_candidate_or_active_validator_mut"></Link>

## Function `get_candidate_or_active_validator_mut`

Get mutable reference to either a candidate or an active validator by address.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_candidate_or_active_validator_mut">get_candidate_or_active_validator_mut</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): &<b>mut</b> <Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_candidate_or_active_validator_mut">get_candidate_or_active_validator_mut</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, validator_address: <b>address</b>): &<b>mut</b> Validator \{
    <b>if</b> (self.validator_candidates.contains(validator_address)) \{
        <b>let</b> wrapper = &<b>mut</b> self.validator_candidates[validator_address];
        <b>return</b> wrapper.load_validator_maybe_upgrade()
    };
    <Link to="validator_set#0x3_validator_set_get_validator_mut">get_validator_mut</Link>(&<b>mut</b> self.active_validators, validator_address)
}
</code></pre>



</details>

<Link id="0x3_validator_set_find_validator"></Link>

## Function `find_validator`

Find validator by 
validator_address, in 
validators.
Returns (true, index) if the validator is found, and the index is its index in the list.
If not found, returns (false, 0).


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, validator_address: <b>address</b>): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, validator_address: <b>address</b>): Option&lt;u64&gt; \{
    <b>let</b> length = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> v = &validators[i];
        <b>if</b> (v.iota_address() == validator_address) \{
            <b>return</b> <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(i)
        };
        i = i + 1;
    };
    <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
}
</code></pre>



</details>

<Link id="0x3_validator_set_find_validator_from_table_vec"></Link>

## Function `find_validator_from_table_vec`

Find validator by 
validator_address, in 
validators.
Returns (true, index) if the validator is found, and the index is its index in the list.
If not found, returns (false, 0).


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_find_validator_from_table_vec">find_validator_from_table_vec</Link>(validators: &<Link to="../iota-framework/table_vec#0x2_table_vec_TableVec">table_vec::TableVec</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, validator_address: <b>address</b>): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_find_validator_from_table_vec">find_validator_from_table_vec</Link>(validators: &TableVec&lt;Validator&gt;, validator_address: <b>address</b>): Option&lt;u64&gt; \{
    <b>let</b> length = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> v = &validators[i];
        <b>if</b> (v.iota_address() == validator_address) \{
            <b>return</b> <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(i)
        };
        i = i + 1;
    };
    <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_validator_indices"></Link>

## Function `get_validator_indices`

Given a vector of validator addresses, return their indices in the validator set.
Aborts if any address isn't in the given validator set.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_indices">get_validator_indices</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, validator_addresses: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_indices">get_validator_indices</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, validator_addresses: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt; \{
    <b>let</b> length = validator_addresses.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> <b>mut</b> res = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>while</b> (i &lt; length) \{
        <b>let</b> addr = validator_addresses[i];
        <b>let</b> index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(validators, addr);
        <b>assert</b>!(index_opt.is_some(), <Link to="validator_set#0x3_validator_set_ENotAValidator">ENotAValidator</Link>);
        res.push_back(index_opt.destroy_some());
        i = i + 1;
    };
    res
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_validator_mut"></Link>

## Function `get_validator_mut`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut">get_validator_mut</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, validator_address: <b>address</b>): &<b>mut</b> <Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut">get_validator_mut</Link>(
    validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    validator_address: <b>address</b>,
): &<b>mut</b> Validator \{
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(validators, validator_address);
    <b>assert</b>!(validator_index_opt.is_some(), <Link to="validator_set#0x3_validator_set_ENotAValidator">ENotAValidator</Link>);
    <b>let</b> validator_index = validator_index_opt.extract();
    &<b>mut</b> validators[validator_index]
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_active_or_pending_or_candidate_validator_mut"></Link>

## Function `get_active_or_pending_or_candidate_validator_mut`

Get mutable reference to an active or (if active does not exist) pending or (if pending and
active do not exist) or candidate validator by address.
Note: this function should be called carefully, only after verifying the transaction
sender has the ability to modify the 
Validator.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_mut">get_active_or_pending_or_candidate_validator_mut</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>, include_candidate: bool): &<b>mut</b> <Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_mut">get_active_or_pending_or_candidate_validator_mut</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_address: <b>address</b>,
    include_candidate: bool,
): &<b>mut</b> Validator \{
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(&self.active_validators, validator_address);
    <b>if</b> (validator_index_opt.is_some()) \{
        <b>let</b> validator_index = validator_index_opt.extract();
        <b>return</b> &<b>mut</b> self.active_validators[validator_index]
    };
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator_from_table_vec">find_validator_from_table_vec</Link>(&self.pending_active_validators, validator_address);
    // consider both pending validators and the candidate ones
    <b>if</b> (validator_index_opt.is_some()) \{
        <b>let</b> validator_index = validator_index_opt.extract();
        <b>return</b> &<b>mut</b> self.pending_active_validators[validator_index]
    };
    <b>assert</b>!(include_candidate, <Link to="validator_set#0x3_validator_set_ENotActiveOrPendingValidator">ENotActiveOrPendingValidator</Link>);
    <b>let</b> wrapper = &<b>mut</b> self.validator_candidates[validator_address];
    wrapper.load_validator_maybe_upgrade()
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_validator_mut_with_verified_cap"></Link>

## Function `get_validator_mut_with_verified_cap`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut_with_verified_cap">get_validator_mut_with_verified_cap</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, verified_cap: &<Link to="validator_cap#0x3_validator_cap_ValidatorOperationCap">validator_cap::ValidatorOperationCap</Link>, include_candidate: bool): &<b>mut</b> <Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut_with_verified_cap">get_validator_mut_with_verified_cap</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    verified_cap: &ValidatorOperationCap,
    include_candidate: bool,
): &<b>mut</b> Validator \{
    <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_mut">get_active_or_pending_or_candidate_validator_mut</Link>(self, *verified_cap.verified_operation_cap_address(), include_candidate)
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_validator_mut_with_ctx"></Link>

## Function `get_validator_mut_with_ctx`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut_with_ctx">get_validator_mut_with_ctx</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): &<b>mut</b> <Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut_with_ctx">get_validator_mut_with_ctx</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    ctx: &TxContext,
): &<b>mut</b> Validator \{
    <b>let</b> validator_address = ctx.sender();
    <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_mut">get_active_or_pending_or_candidate_validator_mut</Link>(self, validator_address, <b>false</b>)
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_validator_mut_with_ctx_including_candidates"></Link>

## Function `get_validator_mut_with_ctx_including_candidates`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut_with_ctx_including_candidates">get_validator_mut_with_ctx_including_candidates</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): &<b>mut</b> <Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_mut_with_ctx_including_candidates">get_validator_mut_with_ctx_including_candidates</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    ctx: &TxContext,
): &<b>mut</b> Validator \{
    <b>let</b> validator_address = ctx.sender();
    <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_mut">get_active_or_pending_or_candidate_validator_mut</Link>(self, validator_address, <b>true</b>)
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_validator_ref"></Link>

## Function `get_validator_ref`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_ref">get_validator_ref</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, validator_address: <b>address</b>): &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_get_validator_ref">get_validator_ref</Link>(
    validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    validator_address: <b>address</b>,
): &Validator \{
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(validators, validator_address);
    <b>assert</b>!(validator_index_opt.is_some(), <Link to="validator_set#0x3_validator_set_ENotAValidator">ENotAValidator</Link>);
    <b>let</b> validator_index = validator_index_opt.extract();
    &validators[validator_index]
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_active_or_pending_or_candidate_validator_ref"></Link>

## Function `get_active_or_pending_or_candidate_validator_ref`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_ref">get_active_or_pending_or_candidate_validator_ref</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>, which_validator: u8): &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_ref">get_active_or_pending_or_candidate_validator_ref</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_address: <b>address</b>,
    which_validator: u8,
): &Validator \{
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(&self.active_validators, validator_address);
    <b>if</b> (validator_index_opt.is_some() || which_validator == <Link to="validator_set#0x3_validator_set_ACTIVE_VALIDATOR_ONLY">ACTIVE_VALIDATOR_ONLY</Link>) \{
        <b>let</b> validator_index = validator_index_opt.extract();
        <b>return</b> &self.active_validators[validator_index]
    };
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator_from_table_vec">find_validator_from_table_vec</Link>(&self.pending_active_validators, validator_address);
    <b>if</b> (validator_index_opt.is_some() || which_validator == <Link to="validator_set#0x3_validator_set_ACTIVE_OR_PENDING_VALIDATOR">ACTIVE_OR_PENDING_VALIDATOR</Link>) \{
        <b>let</b> validator_index = validator_index_opt.extract();
        <b>return</b> &self.pending_active_validators[validator_index]
    };
    self.validator_candidates[validator_address].load_validator_maybe_upgrade()
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_active_validator_ref"></Link>

## Function `get_active_validator_ref`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_get_active_validator_ref">get_active_validator_ref</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_get_active_validator_ref">get_active_validator_ref</Link>(
    self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_address: <b>address</b>,
): &Validator \{
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator">find_validator</Link>(&self.active_validators, validator_address);
    <b>assert</b>!(validator_index_opt.is_some(), <Link to="validator_set#0x3_validator_set_ENotAValidator">ENotAValidator</Link>);
    <b>let</b> validator_index = validator_index_opt.extract();
    &self.active_validators[validator_index]
}
</code></pre>



</details>

<Link id="0x3_validator_set_get_pending_validator_ref"></Link>

## Function `get_pending_validator_ref`



<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_get_pending_validator_ref">get_pending_validator_ref</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_address: <b>address</b>): &<Link to="validator#0x3_validator_Validator">validator::Validator</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_get_pending_validator_ref">get_pending_validator_ref</Link>(
    self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_address: <b>address</b>,
): &Validator \{
    <b>let</b> <b>mut</b> validator_index_opt = <Link to="validator_set#0x3_validator_set_find_validator_from_table_vec">find_validator_from_table_vec</Link>(&self.pending_active_validators, validator_address);
    <b>assert</b>!(validator_index_opt.is_some(), <Link to="validator_set#0x3_validator_set_ENotAPendingValidator">ENotAPendingValidator</Link>);
    <b>let</b> validator_index = validator_index_opt.extract();
    &self.pending_active_validators[validator_index]
}
</code></pre>



</details>

<Link id="0x3_validator_set_verify_cap"></Link>

## Function `verify_cap`

Verify the capability is valid for a Validator.
If 
active_validator_only is true, only verify the Cap for an active validator.
Otherwise, verify the Cap for au either active or pending validator.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_verify_cap">verify_cap</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, cap: &<Link to="validator_cap#0x3_validator_cap_UnverifiedValidatorOperationCap">validator_cap::UnverifiedValidatorOperationCap</Link>, which_validator: u8): <Link to="validator_cap#0x3_validator_cap_ValidatorOperationCap">validator_cap::ValidatorOperationCap</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_verify_cap">verify_cap</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    cap: &UnverifiedValidatorOperationCap,
    which_validator: u8,
): ValidatorOperationCap \{
    <b>let</b> cap_address = *cap.unverified_operation_cap_address();
    <b>let</b> <Link to="validator#0x3_validator">validator</Link> =
        <b>if</b> (which_validator == <Link to="validator_set#0x3_validator_set_ACTIVE_VALIDATOR_ONLY">ACTIVE_VALIDATOR_ONLY</Link>)
            <Link to="validator_set#0x3_validator_set_get_active_validator_ref">get_active_validator_ref</Link>(self, cap_address)
        <b>else</b>
            <Link to="validator_set#0x3_validator_set_get_active_or_pending_or_candidate_validator_ref">get_active_or_pending_or_candidate_validator_ref</Link>(self, cap_address, which_validator);
    <b>assert</b>!(<Link to="validator#0x3_validator">validator</Link>.operation_cap_id() == &<Link to="../iota-framework/object#0x2_object_id">object::id</Link>(cap), <Link to="validator_set#0x3_validator_set_EInvalidCap">EInvalidCap</Link>);
    <Link to="validator_cap#0x3_validator_cap_new_from_unverified">validator_cap::new_from_unverified</Link>(cap)
}
</code></pre>



</details>

<Link id="0x3_validator_set_process_pending_removals"></Link>

## Function `process_pending_removals`

Process the pending withdraw requests. For each pending request, the validator
is removed from 
validators and its staking pool is put into the 
inactive_validators table.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_pending_removals">process_pending_removals</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_pending_removals">process_pending_removals</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
    ctx: &<b>mut</b> TxContext,
) \{
    <Link to="validator_set#0x3_validator_set_sort_removal_list">sort_removal_list</Link>(&<b>mut</b> self.pending_removals);
    <b>while</b> (!self.pending_removals.is_empty()) \{
        <b>let</b> index = self.pending_removals.pop_back();
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = self.active_validators.remove(index);
        <Link to="validator_set#0x3_validator_set_process_validator_departure">process_validator_departure</Link>(self, <Link to="validator#0x3_validator">validator</Link>, validator_report_records, <b>true</b> /* the <Link to="validator#0x3_validator">validator</Link> removes itself voluntarily */, ctx);
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_process_validator_departure"></Link>

## Function `process_validator_departure`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_validator_departure">process_validator_departure</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, <Link to="validator#0x3_validator">validator</Link>: <Link to="validator#0x3_validator_Validator">validator::Validator</Link>, validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;, is_voluntary: bool, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_validator_departure">process_validator_departure</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    <b>mut</b> <Link to="validator#0x3_validator">validator</Link>: Validator,
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
    is_voluntary: bool,
    ctx: &<b>mut</b> TxContext,
) \{
    <b>let</b> new_epoch = ctx.epoch() + 1;
    <b>let</b> validator_address = <Link to="validator#0x3_validator">validator</Link>.iota_address();
    <b>let</b> validator_pool_id = staking_pool_id(&<Link to="validator#0x3_validator">validator</Link>);

    // Remove the <Link to="validator#0x3_validator">validator</Link> from our tables.
    self.staking_pool_mappings.remove(validator_pool_id);
    <b>if</b> (self.at_risk_validators.contains(&validator_address)) \{
        self.at_risk_validators.remove(&validator_address);
    };

    self.total_stake = self.total_stake - <Link to="validator#0x3_validator">validator</Link>.total_stake_amount();

    <Link to="validator_set#0x3_validator_set_clean_report_records_leaving_validator">clean_report_records_leaving_validator</Link>(validator_report_records, validator_address);

    <Link to="../iota-framework/event#0x2_event_emit">event::emit</Link>(
        <Link to="validator_set#0x3_validator_set_ValidatorLeaveEvent">ValidatorLeaveEvent</Link> \{
            epoch: new_epoch,
            validator_address,
            staking_pool_id: staking_pool_id(&<Link to="validator#0x3_validator">validator</Link>),
            is_voluntary,
        }
    );

    // Deactivate the <Link to="validator#0x3_validator">validator</Link> and its staking pool
    <Link to="validator#0x3_validator">validator</Link>.deactivate(new_epoch);
    self.inactive_validators.add(
        validator_pool_id,
        <Link to="validator_wrapper#0x3_validator_wrapper_create_v1">validator_wrapper::create_v1</Link>(<Link to="validator#0x3_validator">validator</Link>, ctx),
    );
}
</code></pre>



</details>

<Link id="0x3_validator_set_clean_report_records_leaving_validator"></Link>

## Function `clean_report_records_leaving_validator`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_clean_report_records_leaving_validator">clean_report_records_leaving_validator</Link>(validator_report_records: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;, leaving_validator_addr: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_clean_report_records_leaving_validator">clean_report_records_leaving_validator</Link>(
    validator_report_records: &<b>mut</b> VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
    leaving_validator_addr: <b>address</b>
) \{
    // Remove the records about this <Link to="validator#0x3_validator">validator</Link>
    <b>if</b> (validator_report_records.contains(&leaving_validator_addr)) \{
        validator_report_records.remove(&leaving_validator_addr);
    };

    // Remove the reports submitted by this <Link to="validator#0x3_validator">validator</Link>
    <b>let</b> reported_validators = validator_report_records.keys();
    <b>let</b> length = reported_validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> reported_validator_addr = &reported_validators[i];
        <b>let</b> reporters = &<b>mut</b> validator_report_records[reported_validator_addr];
        <b>if</b> (reporters.contains(&leaving_validator_addr)) \{
            reporters.remove(&leaving_validator_addr);
            <b>if</b> (reporters.is_empty()) \{
                validator_report_records.remove(reported_validator_addr);
            };
        };
        i = i + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_process_pending_validators"></Link>

## Function `process_pending_validators`

Process the pending new validators. They are activated and inserted into 
validators.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_pending_validators">process_pending_validators</Link>(self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, new_epoch: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_pending_validators">process_pending_validators</Link>(
    self: &<b>mut</b> <Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, new_epoch: u64,
) \{
    <b>while</b> (!self.pending_active_validators.is_empty()) \{
        <b>let</b> <b>mut</b> <Link to="validator#0x3_validator">validator</Link> = self.pending_active_validators.pop_back();
        <Link to="validator#0x3_validator">validator</Link>.activate(new_epoch);
        <Link to="../iota-framework/event#0x2_event_emit">event::emit</Link>(
            <Link to="validator_set#0x3_validator_set_ValidatorJoinEvent">ValidatorJoinEvent</Link> \{
                epoch: new_epoch,
                validator_address: <Link to="validator#0x3_validator">validator</Link>.iota_address(),
                staking_pool_id: staking_pool_id(&<Link to="validator#0x3_validator">validator</Link>),
            }
        );
        self.active_validators.push_back(<Link to="validator#0x3_validator">validator</Link>);
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_sort_removal_list"></Link>

## Function `sort_removal_list`

Sort all the pending removal indexes.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_sort_removal_list">sort_removal_list</Link>(withdraw_list: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_sort_removal_list">sort_removal_list</Link>(withdraw_list: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;) \{
    <b>let</b> length = withdraw_list.length();
    <b>let</b> <b>mut</b> i = 1;
    <b>while</b> (i &lt; length) \{
        <b>let</b> cur = withdraw_list[i];
        <b>let</b> <b>mut</b> j = i;
        <b>while</b> (j &gt; 0) \{
            j = j - 1;
            <b>if</b> (withdraw_list[j] &gt; cur) \{
                withdraw_list.swap(j, j + 1);
            } <b>else</b> \{
                <b>break</b>
            };
        };
        i = i + 1;
    };
}
</code></pre>



</details>

<Link id="0x3_validator_set_process_pending_stakes_and_withdraws"></Link>

## Function `process_pending_stakes_and_withdraws`

Process all active validators' pending stake deposits and withdraws.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_pending_stakes_and_withdraws">process_pending_stakes_and_withdraws</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, ctx: &<Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_process_pending_stakes_and_withdraws">process_pending_stakes_and_withdraws</Link>(
    validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, ctx: &TxContext
) \{
    <b>let</b> length = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &<b>mut</b> validators[i];
        <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_process_pending_stakes_and_withdraws">process_pending_stakes_and_withdraws</Link>(ctx);
        i = i + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_calculate_total_stakes"></Link>

## Function `calculate_total_stakes`

Calculate the total active validator stake.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_calculate_total_stakes">calculate_total_stakes</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_calculate_total_stakes">calculate_total_stakes</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;): u64 \{
    <b>let</b> <b>mut</b> stake = 0;
    <b>let</b> length = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> v = &validators[i];
        stake = stake + v.total_stake_amount();
        i = i + 1;
    };
    stake
}
</code></pre>



</details>

<Link id="0x3_validator_set_adjust_stake_and_gas_price"></Link>

## Function `adjust_stake_and_gas_price`

Process the pending stake changes for each validator.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_adjust_stake_and_gas_price">adjust_stake_and_gas_price</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_adjust_stake_and_gas_price">adjust_stake_and_gas_price</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;) \{
    <b>let</b> length = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &<b>mut</b> validators[i];
        <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_adjust_stake_and_gas_price">adjust_stake_and_gas_price</Link>();
        i = i + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_compute_reward_adjustments"></Link>

## Function `compute_reward_adjustments`

Compute both the individual reward adjustments and total reward adjustment for staking rewards.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_reward_adjustments">compute_reward_adjustments</Link>(slashed_validator_indices: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, reward_slashing_rate: u64, unadjusted_staking_reward_amounts: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;): (u64, <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;u64, u64&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_reward_adjustments">compute_reward_adjustments</Link>(
    <b>mut</b> slashed_validator_indices: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;,
    reward_slashing_rate: u64,
    unadjusted_staking_reward_amounts: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;,
): (
    u64, // sum of staking reward adjustments
    VecMap&lt;u64, u64&gt;, // mapping of individual <Link to="validator#0x3_validator">validator</Link>'s staking reward adjustment from index -&gt; amount
) \{
    <b>let</b> <b>mut</b> total_staking_reward_adjustment = 0;
    <b>let</b> <b>mut</b> individual_staking_reward_adjustments = <Link to="../iota-framework/vec_map#0x2_vec_map_empty">vec_map::empty</Link>();

    <b>while</b> (!slashed_validator_indices.is_empty()) \{
        <b>let</b> validator_index = slashed_validator_indices.pop_back();

        // Use the slashing rate <b>to</b> compute the amount of staking rewards slashed from this punished <Link to="validator#0x3_validator">validator</Link>.
        <b>let</b> unadjusted_staking_reward = unadjusted_staking_reward_amounts[validator_index];
        <b>let</b> staking_reward_adjustment_u128 =
            unadjusted_staking_reward <b>as</b> u128 * (reward_slashing_rate <b>as</b> u128)
            / <Link to="validator_set#0x3_validator_set_BASIS_POINT_DENOMINATOR">BASIS_POINT_DENOMINATOR</Link>;

        // Insert into individual mapping and record into the total adjustment sum.
        individual_staking_reward_adjustments.insert(validator_index, staking_reward_adjustment_u128 <b>as</b> u64);
        total_staking_reward_adjustment = total_staking_reward_adjustment + (staking_reward_adjustment_u128 <b>as</b> u64);
    };

    (total_staking_reward_adjustment, individual_staking_reward_adjustments)
}
</code></pre>



</details>

<Link id="0x3_validator_set_compute_slashed_validators"></Link>

## Function `compute_slashed_validators`

Process the validator report records of the epoch and return the addresses of the
non-performant validators according to the input threshold.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_slashed_validators">compute_slashed_validators</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, validator_report_records: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_slashed_validators">compute_slashed_validators</Link>(
    self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>,
    <b>mut</b> validator_report_records: VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt; \{
    <b>let</b> <b>mut</b> slashed_validators = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>while</b> (!validator_report_records.is_empty()) \{
        <b>let</b> (validator_address, reporters) = validator_report_records.pop();
        <b>assert</b>!(
            <Link to="validator_set#0x3_validator_set_is_active_validator_by_iota_address">is_active_validator_by_iota_address</Link>(self, validator_address),
            <Link to="validator_set#0x3_validator_set_ENonValidatorInReportRecords">ENonValidatorInReportRecords</Link>,
        );
        // Sum up the voting power of validators that have reported this <Link to="validator#0x3_validator">validator</Link> and check <b>if</b> it <b>has</b>
        // passed the slashing threshold.
        <b>let</b> reporter_votes = <Link to="validator_set#0x3_validator_set_sum_voting_power_by_addresses">sum_voting_power_by_addresses</Link>(&self.active_validators, &reporters.into_keys());
        <b>if</b> (reporter_votes &gt;= <Link to="voting_power#0x3_voting_power_quorum_threshold">voting_power::quorum_threshold</Link>()) \{
            slashed_validators.push_back(validator_address);
        }
    };
    slashed_validators
}
</code></pre>



</details>

<Link id="0x3_validator_set_compute_unadjusted_reward_distribution"></Link>

## Function `compute_unadjusted_reward_distribution`

Given the current list of active validators, the total stake and total reward,
calculate the amount of reward each validator should get, without taking into
account the tallying rule results.
Returns the unadjusted amounts of staking reward for each validator.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_unadjusted_reward_distribution">compute_unadjusted_reward_distribution</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, total_voting_power: u64, total_staking_reward: u64): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_unadjusted_reward_distribution">compute_unadjusted_reward_distribution</Link>(
    validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    total_voting_power: u64,
    total_staking_reward: u64,
): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt; \{
    <b>let</b> <b>mut</b> staking_reward_amounts = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>let</b> length = validators.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &validators[i];
        // Integer divisions will truncate the results. Because of this, we expect that at the end
        // there will be some reward remaining in `total_staking_reward`.
        // Use u128 <b>to</b> avoid multiplication overflow.
        <b>let</b> <Link to="voting_power#0x3_voting_power">voting_power</Link>: u128 = <Link to="validator#0x3_validator">validator</Link>.<Link to="voting_power#0x3_voting_power">voting_power</Link>() <b>as</b> u128;
        <b>let</b> reward_amount = <Link to="voting_power#0x3_voting_power">voting_power</Link> * (total_staking_reward <b>as</b> u128) / (total_voting_power <b>as</b> u128);
        staking_reward_amounts.push_back(reward_amount <b>as</b> u64);
        i = i + 1;
    };
    staking_reward_amounts
}
</code></pre>



</details>

<Link id="0x3_validator_set_compute_adjusted_reward_distribution"></Link>

## Function `compute_adjusted_reward_distribution`

Use the reward adjustment info to compute the adjusted rewards each validator should get.
Returns the staking rewards each validator gets.
The staking rewards are shared with the stakers.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_adjusted_reward_distribution">compute_adjusted_reward_distribution</Link>(validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, total_voting_power: u64, total_slashed_validator_voting_power: u64, unadjusted_staking_reward_amounts: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, total_staking_reward_adjustment: u64, individual_staking_reward_adjustments: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;u64, u64&gt;): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_compute_adjusted_reward_distribution">compute_adjusted_reward_distribution</Link>(
    validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    total_voting_power: u64,
    total_slashed_validator_voting_power: u64,
    unadjusted_staking_reward_amounts: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;,
    total_staking_reward_adjustment: u64,
    individual_staking_reward_adjustments: VecMap&lt;u64, u64&gt;,
): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt; \{
    <b>let</b> total_unslashed_validator_voting_power = total_voting_power - total_slashed_validator_voting_power;
    <b>let</b> <b>mut</b> adjusted_staking_reward_amounts = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];

    <b>let</b> length = validators.length();

    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &validators[i];
        // Integer divisions will truncate the results. Because of this, we expect that at the end
        // there will be some reward remaining in `total_reward`.
        // Use u128 <b>to</b> avoid multiplication overflow.
        <b>let</b> <Link to="voting_power#0x3_voting_power">voting_power</Link> = <Link to="validator#0x3_validator">validator</Link>.<Link to="voting_power#0x3_voting_power">voting_power</Link>() <b>as</b> u128;

        // Compute adjusted staking reward.
        <b>let</b> unadjusted_staking_reward_amount = unadjusted_staking_reward_amounts[i];
        <b>let</b> adjusted_staking_reward_amount =
            // If the <Link to="validator#0x3_validator">validator</Link> is one of the slashed ones, then subtract the adjustment.
            <b>if</b> (individual_staking_reward_adjustments.contains(&i)) \{
                <b>let</b> adjustment = individual_staking_reward_adjustments[&i];
                unadjusted_staking_reward_amount - adjustment
            } <b>else</b> \{
                // Otherwise the slashed rewards should be distributed among the unslashed
                // validators so add the corresponding adjustment.
                <b>let</b> adjustment = total_staking_reward_adjustment <b>as</b> u128 * <Link to="voting_power#0x3_voting_power">voting_power</Link>
                               / (total_unslashed_validator_voting_power <b>as</b> u128);
                unadjusted_staking_reward_amount + (adjustment <b>as</b> u64)
            };
        adjusted_staking_reward_amounts.push_back(adjusted_staking_reward_amount);

        i = i + 1;
    };

    adjusted_staking_reward_amounts
}
</code></pre>



</details>

<Link id="0x3_validator_set_distribute_reward"></Link>

## Function `distribute_reward`



<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_distribute_reward">distribute_reward</Link>(validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, adjusted_staking_reward_amounts: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, staking_rewards: &<b>mut</b> <Link to="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link to="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, ctx: &<b>mut</b> <Link to="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_distribute_reward">distribute_reward</Link>(
    validators: &<b>mut</b> <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    adjusted_staking_reward_amounts: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;,
    staking_rewards: &<b>mut</b> Balance&lt;IOTA&gt;,
    ctx: &<b>mut</b> TxContext
) \{
    <b>let</b> length = validators.length();
    <b>assert</b>!(length &gt; 0, <Link to="validator_set#0x3_validator_set_EValidatorSetEmpty">EValidatorSetEmpty</Link>);
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; length) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = &<b>mut</b> validators[i];
        <b>let</b> staking_reward_amount = adjusted_staking_reward_amounts[i];
        <b>let</b> <b>mut</b> staker_reward = staking_rewards.split(staking_reward_amount);

        // Validator takes a cut of the rewards <b>as</b> commission.
        <b>let</b> validator_commission_amount = (staking_reward_amount <b>as</b> u128) * (<Link to="validator#0x3_validator">validator</Link>.commission_rate() <b>as</b> u128) / <Link to="validator_set#0x3_validator_set_BASIS_POINT_DENOMINATOR">BASIS_POINT_DENOMINATOR</Link>;

        // The <Link to="validator#0x3_validator">validator</Link> reward = commission.
        <b>let</b> validator_reward = staker_reward.split(validator_commission_amount <b>as</b> u64);

        // Add rewards <b>to</b> the <Link to="validator#0x3_validator">validator</Link>. Don't try and distribute rewards though <b>if</b> the payout is zero.
        <b>if</b> (validator_reward.value() &gt; 0) \{
            <b>let</b> validator_address = <Link to="validator#0x3_validator">validator</Link>.iota_address();
            <b>let</b> rewards_stake = <Link to="validator#0x3_validator">validator</Link>.<Link to="validator_set#0x3_validator_set_request_add_stake">request_add_stake</Link>(validator_reward, validator_address, ctx);
            <Link to="../iota-framework/transfer#0x2_transfer_public_transfer">transfer::public_transfer</Link>(rewards_stake, validator_address);
        } <b>else</b> \{
            validator_reward.destroy_zero();
        };

        // Add rewards <b>to</b> stake staking pool <b>to</b> auto compound for stakers.
        <Link to="validator#0x3_validator">validator</Link>.deposit_stake_rewards(staker_reward);
        i = i + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_emit_validator_epoch_events"></Link>

## Function `emit_validator_epoch_events`

Emit events containing information of each validator for the epoch,
including stakes, rewards, performance, etc.


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_emit_validator_epoch_events">emit_validator_epoch_events</Link>(new_epoch: u64, vs: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, pool_staking_reward_amounts: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, report_records: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<b>address</b>, <Link to="../iota-framework/vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<b>address</b>&gt;&gt;, slashed_validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="validator_set#0x3_validator_set_emit_validator_epoch_events">emit_validator_epoch_events</Link>(
    new_epoch: u64,
    vs: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;,
    pool_staking_reward_amounts: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;,
    report_records: &VecMap&lt;<b>address</b>, VecSet&lt;<b>address</b>&gt;&gt;,
    slashed_validators: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;,
) \{
    <b>let</b> num_validators = vs.length();
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; num_validators) \{
        <b>let</b> v = &vs[i];
        <b>let</b> validator_address = v.iota_address();
        <b>let</b> tallying_rule_reporters =
            <b>if</b> (report_records.contains(&validator_address)) \{
                report_records[&validator_address].into_keys()
            } <b>else</b> \{
                <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[]
            };
        <b>let</b> tallying_rule_global_score =
            <b>if</b> (slashed_validators.contains(&validator_address)) 0
            <b>else</b> 1;
        <Link to="../iota-framework/event#0x2_event_emit">event::emit</Link>(
            <Link to="validator_set#0x3_validator_set_ValidatorEpochInfoEventV2">ValidatorEpochInfoEventV2</Link> \{
                epoch: new_epoch,
                validator_address,
                reference_gas_survey_quote: v.gas_price(),
                stake: v.total_stake_amount(),
                <Link to="voting_power#0x3_voting_power">voting_power</Link>: v.<Link to="voting_power#0x3_voting_power">voting_power</Link>(),
                commission_rate: v.commission_rate(),
                pool_staking_reward: pool_staking_reward_amounts[i],
                pool_token_exchange_rate: v.pool_token_exchange_rate_at_epoch(new_epoch),
                tallying_rule_reporters,
                tallying_rule_global_score,
            }
        );
        i = i + 1;
    }
}
</code></pre>



</details>

<Link id="0x3_validator_set_sum_voting_power_by_addresses"></Link>

## Function `sum_voting_power_by_addresses`

Sum up the total stake of a given list of validator addresses.


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_sum_voting_power_by_addresses">sum_voting_power_by_addresses</Link>(vs: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;, addresses: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_sum_voting_power_by_addresses">sum_voting_power_by_addresses</Link>(vs: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt;, addresses: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;): u64 \{
    <b>let</b> <b>mut</b> sum = 0;
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> length = addresses.length();
    <b>while</b> (i &lt; length) \{
        <b>let</b> <Link to="validator#0x3_validator">validator</Link> = <Link to="validator_set#0x3_validator_set_get_validator_ref">get_validator_ref</Link>(vs, addresses[i]);
        sum = sum + <Link to="validator#0x3_validator">validator</Link>.<Link to="voting_power#0x3_voting_power">voting_power</Link>();
        i = i + 1;
    };
    sum
}
</code></pre>



</details>

<Link id="0x3_validator_set_active_validators"></Link>

## Function `active_validators`

Return the active validators in 
self


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_active_validators">active_validators</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>): &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="validator#0x3_validator_Validator">validator::Validator</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_active_validators">active_validators</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>): &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Validator&gt; \{
    &self.active_validators
}
</code></pre>



</details>

<Link id="0x3_validator_set_is_validator_candidate"></Link>

## Function `is_validator_candidate`

Returns true if the 
addr is a validator candidate.


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_is_validator_candidate">is_validator_candidate</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, addr: <b>address</b>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_is_validator_candidate">is_validator_candidate</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, addr: <b>address</b>): bool \{
    self.validator_candidates.contains(addr)
}
</code></pre>



</details>

<Link id="0x3_validator_set_is_inactive_validator"></Link>

## Function `is_inactive_validator`

Returns true if the staking pool identified by 
staking_pool_id is of an inactive validator.


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_is_inactive_validator">is_inactive_validator</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>, staking_pool_id: <Link to="../iota-framework/object#0x2_object_ID">object::ID</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="validator_set#0x3_validator_set_is_inactive_validator">is_inactive_validator</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>, staking_pool_id: ID): bool \{
    self.inactive_validators.contains(staking_pool_id)
}
</code></pre>



</details>

<Link id="0x3_validator_set_active_validator_addresses"></Link>

## Function `active_validator_addresses`



<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link to="validator_set#0x3_validator_set_active_validator_addresses">active_validator_addresses</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">validator_set::ValidatorSet</Link>): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(package) <b>fun</b> <Link to="validator_set#0x3_validator_set_active_validator_addresses">active_validator_addresses</Link>(self: &<Link to="validator_set#0x3_validator_set_ValidatorSet">ValidatorSet</Link>): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<b>address</b>&gt; \{
    <b>let</b> vs = &self.active_validators;
    <b>let</b> <b>mut</b> res = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> length = vs.length();
    <b>while</b> (i &lt; length) \{
        <b>let</b> validator_address = vs[i].iota_address();
        res.push_back(validator_address);
        i = i + 1;
    };
    res
}
</code></pre>



</details>
