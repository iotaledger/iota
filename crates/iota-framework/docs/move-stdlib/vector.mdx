---
title: Module `0x1::vector`
---
import Link from '@docusaurus/Link';

A variable-sized container that can hold any type. Indexing is 0-based, and
vectors are growable. This module has many native functions.


-  [Constants](#@Constants_0)
-  [Function `empty`](#0x1_vector_empty)
-  [Function `length`](#0x1_vector_length)
-  [Function `borrow`](#0x1_vector_borrow)
-  [Function `push_back`](#0x1_vector_push_back)
-  [Function `borrow_mut`](#0x1_vector_borrow_mut)
-  [Function `pop_back`](#0x1_vector_pop_back)
-  [Function `destroy_empty`](#0x1_vector_destroy_empty)
-  [Function `swap`](#0x1_vector_swap)
-  [Function `singleton`](#0x1_vector_singleton)
-  [Function `reverse`](#0x1_vector_reverse)
-  [Function `append`](#0x1_vector_append)
-  [Function `is_empty`](#0x1_vector_is_empty)
-  [Function `contains`](#0x1_vector_contains)
-  [Function `index_of`](#0x1_vector_index_of)
-  [Function `remove`](#0x1_vector_remove)
-  [Function `insert`](#0x1_vector_insert)
-  [Function `swap_remove`](#0x1_vector_swap_remove)


<pre><code>
</code></pre>



<Link id="@Constants_0"></Link>

## Constants


<Link id="0x1_vector_EINDEX_OUT_OF_BOUNDS"></Link>

The index into the vector is out of bounds


<pre><code>
<b>const</b> <Link href="../move-stdlib/vector#0x1_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</Link>: u64 = 131072;
</code></pre>



<Link id="0x1_vector_empty"></Link>

## Function `empty`

Create an empty vector.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_empty">empty</Link>&lt;Element&gt;(): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_empty">empty</Link>&lt;Element&gt;(): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;;
</code></pre>



</details>

<Link id="0x1_vector_length"></Link>

## Function `length`

Return the length of the vector.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_length">length</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_length">length</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;): u64;
</code></pre>



</details>

<Link id="0x1_vector_borrow"></Link>

## Function `borrow`

Acquire an immutable reference to the <code>
i</code>th element of the vector <code>
v</code>.
Aborts if <code>
i</code> is out of bounds.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_borrow">borrow</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): &Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_borrow">borrow</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): &Element;
</code></pre>



</details>

<Link id="0x1_vector_push_back"></Link>

## Function `push_back`

Add element <code>
e</code> to the end of the vector <code>
v</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_push_back">push_back</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: Element)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_push_back">push_back</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: Element);
</code></pre>



</details>

<Link id="0x1_vector_borrow_mut"></Link>

## Function `borrow_mut`

Return a mutable reference to the <code>
i</code>th element in the vector <code>
v</code>.
Aborts if <code>
i</code> is out of bounds.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_borrow_mut">borrow_mut</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): &<b>mut</b> Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_borrow_mut">borrow_mut</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): &<b>mut</b> Element;
</code></pre>



</details>

<Link id="0x1_vector_pop_back"></Link>

## Function `pop_back`

Pop an element from the end of vector <code>
v</code>.
Aborts if <code>
v</code> is empty.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_pop_back">pop_back</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_pop_back">pop_back</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;): Element;
</code></pre>



</details>

<Link id="0x1_vector_destroy_empty"></Link>

## Function `destroy_empty`

Destroy the vector <code>
v</code>.
Aborts if <code>
v</code> is not empty.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_destroy_empty">destroy_empty</Link>&lt;Element&gt;(v: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_destroy_empty">destroy_empty</Link>&lt;Element&gt;(v: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;);
</code></pre>



</details>

<Link id="0x1_vector_swap"></Link>

## Function `swap`

Swaps the elements at the <code>
i</code>th and <code>
j</code>th indices in the vector <code>
v</code>.
Aborts if <code>
i</code> or <code>
j</code> is out of bounds.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_swap">swap</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64, j: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_swap">swap</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64, j: u64);
</code></pre>



</details>

<Link id="0x1_vector_singleton"></Link>

## Function `singleton`

Return an vector of size one containing element <code>
e</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_singleton">singleton</Link>&lt;Element&gt;(e: Element): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_singleton">singleton</Link>&lt;Element&gt;(e: Element): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt; \{
    <b>let</b> <b>mut</b> v = <Link href="../move-stdlib/vector#0x1_vector_empty">empty</Link>();
    v.<Link href="../move-stdlib/vector#0x1_vector_push_back">push_back</Link>(e);
    v
}
</code></pre>



</details>

<Link id="0x1_vector_reverse"></Link>

## Function `reverse`

Reverses the order of the elements in the vector <code>
v</code> in place.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_reverse">reverse</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_reverse">reverse</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;) \{
    <b>let</b> len = v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>();
    <b>if</b> (len == 0) <b>return</b> ();

    <b>let</b> <b>mut</b> front_index = 0;
    <b>let</b> <b>mut</b> back_index = len -1;
    <b>while</b> (front_index &lt; back_index) \{
        v.<Link href="../move-stdlib/vector#0x1_vector_swap">swap</Link>(front_index, back_index);
        front_index = front_index + 1;
        back_index = back_index - 1;
    }
}
</code></pre>



</details>

<Link id="0x1_vector_append"></Link>

## Function `append`

Pushes all of the elements of the <code>
other</code> vector into the <code>
lhs</code> vector.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_append">append</Link>&lt;Element&gt;(lhs: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, other: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_append">append</Link>&lt;Element&gt;(lhs: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, <b>mut</b> other: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;) \{
    other.<Link href="../move-stdlib/vector#0x1_vector_reverse">reverse</Link>();
    <b>while</b> (!other.<Link href="../move-stdlib/vector#0x1_vector_is_empty">is_empty</Link>()) lhs.<Link href="../move-stdlib/vector#0x1_vector_push_back">push_back</Link>(other.<Link href="../move-stdlib/vector#0x1_vector_pop_back">pop_back</Link>());
    other.<Link href="../move-stdlib/vector#0x1_vector_destroy_empty">destroy_empty</Link>();
}
</code></pre>



</details>

<Link id="0x1_vector_is_empty"></Link>

## Function `is_empty`

Return <code>
<b>true</b></code> if the vector <code>
v</code> has no elements and <code>
<b>false</b></code> otherwise.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_is_empty">is_empty</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_is_empty">is_empty</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;): bool \{
    v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>() == 0
}
</code></pre>



</details>

<Link id="0x1_vector_contains"></Link>

## Function `contains`

Return true if <code>
e</code> is in the vector <code>
v</code>.
Otherwise, returns false.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_contains">contains</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: &Element): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_contains">contains</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: &Element): bool \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>();
    <b>while</b> (i &lt; len) \{
        <b>if</b> (&v[i] == e) <b>return</b> <b>true</b>;
        i = i + 1;
    };
    <b>false</b>
}
</code></pre>



</details>

<Link id="0x1_vector_index_of"></Link>

## Function `index_of`

Return <code>
(<b>true</b>, i)</code> if <code>
e</code> is in the vector <code>
v</code> at index <code>
i</code>.
Otherwise, returns <code>
(<b>false</b>, 0)</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_index_of">index_of</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: &Element): (bool, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_index_of">index_of</Link>&lt;Element&gt;(v: &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: &Element): (bool, u64) \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> len = v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>();
    <b>while</b> (i &lt; len) \{
        <b>if</b> (&v[i] == e) <b>return</b> (<b>true</b>, i);
        i = i + 1;
    };
    (<b>false</b>, 0)
}
</code></pre>



</details>

<Link id="0x1_vector_remove"></Link>

## Function `remove`

Remove the <code>
i</code>th element of the vector <code>
v</code>, shifting all subsequent elements.
This is O(n) and preserves ordering of elements in the vector.
Aborts if <code>
i</code> is out of bounds.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_remove">remove</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_remove">remove</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, <b>mut</b> i: u64): Element \{
    <b>let</b> <b>mut</b> len = v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>();
    // i out of bounds; <b>abort</b>
    <b>if</b> (i &gt;= len) <b>abort</b> <Link href="../move-stdlib/vector#0x1_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</Link>;

    len = len - 1;
    <b>while</b> (i &lt; len) v.<Link href="../move-stdlib/vector#0x1_vector_swap">swap</Link>(i, \{ i = i + 1; i });
    v.<Link href="../move-stdlib/vector#0x1_vector_pop_back">pop_back</Link>()
}
</code></pre>



</details>

<Link id="0x1_vector_insert"></Link>

## Function `insert`

Insert <code>
e</code> at position <code>
i</code> in the vector <code>
v</code>.
If <code>
i</code> is in bounds, this shifts the old <code>
v[i]</code> and all subsequent elements to the right.
If <code>
i == v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>()</code>, this adds <code>
e</code> to the end of the vector.
This is O(n) and preserves ordering of elements in the vector.
Aborts if <code>
i &gt; v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>()</code>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_insert">insert</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: Element, i: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_insert">insert</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, e: Element, <b>mut</b> i: u64) \{
    <b>let</b> len = v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>();
    // i too big <b>abort</b>
    <b>if</b> (i &gt; len) <b>abort</b> <Link href="../move-stdlib/vector#0x1_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</Link>;

    v.<Link href="../move-stdlib/vector#0x1_vector_push_back">push_back</Link>(e);
    <b>while</b> (i &lt; len) \{
        v.<Link href="../move-stdlib/vector#0x1_vector_swap">swap</Link>(i, len);
        i = i + 1
    }
}
</code></pre>



</details>

<Link id="0x1_vector_swap_remove"></Link>

## Function `swap_remove`

Swap the <code>
i</code>th element of the vector <code>
v</code> with the last element and then pop the vector.
This is O(1), but does not preserve ordering of elements in the vector.
Aborts if <code>
i</code> is out of bounds.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_swap_remove">swap_remove</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/vector#0x1_vector_swap_remove">swap_remove</Link>&lt;Element&gt;(v: &<b>mut</b> <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;, i: u64): Element \{
    <b>assert</b>!(!v.<Link href="../move-stdlib/vector#0x1_vector_is_empty">is_empty</Link>(), <Link href="../move-stdlib/vector#0x1_vector_EINDEX_OUT_OF_BOUNDS">EINDEX_OUT_OF_BOUNDS</Link>);
    <b>let</b> last_idx = v.<Link href="../move-stdlib/vector#0x1_vector_length">length</Link>() - 1;
    v.<Link href="../move-stdlib/vector#0x1_vector_swap">swap</Link>(i, last_idx);
    v.<Link href="../move-stdlib/vector#0x1_vector_pop_back">pop_back</Link>()
}
</code></pre>



</details>
