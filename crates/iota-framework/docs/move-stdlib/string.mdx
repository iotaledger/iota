---
title: Module 0x1::string
sidebar_label: string
---
import Link from '@docusaurus/Link';

<Link id="0x1_string"/>
The 
<Link to="../move-stdlib/string#0x1_string">string</Link> module defines the 
<Link to="../move-stdlib/string#0x1_string_String">String</Link> type which represents UTF8 encoded strings.


-  [Struct `String`](#0x1_string_String)
-  [Constants](#@Constants_0)
-  [Function `utf8`](#0x1_string_utf8)
-  [Function `from_ascii`](#0x1_string_from_ascii)
-  [Function `to_ascii`](#0x1_string_to_ascii)
-  [Function `try_utf8`](#0x1_string_try_utf8)
-  [Function `bytes`](#0x1_string_bytes)
-  [Function `is_empty`](#0x1_string_is_empty)
-  [Function `length`](#0x1_string_length)
-  [Function `append`](#0x1_string_append)
-  [Function `append_utf8`](#0x1_string_append_utf8)
-  [Function `insert`](#0x1_string_insert)
-  [Function `sub_string`](#0x1_string_sub_string)
-  [Function `index_of`](#0x1_string_index_of)
-  [Function `internal_check_utf8`](#0x1_string_internal_check_utf8)
-  [Function `internal_is_char_boundary`](#0x1_string_internal_is_char_boundary)
-  [Function `internal_sub_string`](#0x1_string_internal_sub_string)
-  [Function `internal_index_of`](#0x1_string_internal_index_of)


<pre><code>
<b>use</b> <Link to="../move-stdlib/ascii#0x1_ascii">0x1::ascii</Link>;
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../move-stdlib/vector#0x1_vector">0x1::vector</Link>;
</code></pre>



<Link id="0x1_string_String"></Link>

## Struct `String`

A 
<Link to="../move-stdlib/string#0x1_string_String">String</Link> holds a sequence of bytes which is guaranteed to be in utf8 format.


<pre><code>
<b>struct</b> <Link to="../move-stdlib/string#0x1_string_String">String</Link> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x1_string_EINVALID_INDEX"></Link>

Index out of range.


<pre><code>
<b>const</b> <Link to="../move-stdlib/string#0x1_string_EINVALID_INDEX">EINVALID_INDEX</Link>: u64 = 2;
</code></pre>



<Link id="0x1_string_EINVALID_UTF8"></Link>

An invalid UTF8 encoding.


<pre><code>
<b>const</b> <Link to="../move-stdlib/string#0x1_string_EINVALID_UTF8">EINVALID_UTF8</Link>: u64 = 1;
</code></pre>



<Link id="0x1_string_utf8"></Link>

## Function `utf8`

Creates a new string from a sequence of bytes. Aborts if the bytes do not represent valid utf8.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_utf8">utf8</Link>(bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_utf8">utf8</Link>(bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <Link to="../move-stdlib/string#0x1_string_String">String</Link> \{
    <b>assert</b>!(<Link to="../move-stdlib/string#0x1_string_internal_check_utf8">internal_check_utf8</Link>(&bytes), <Link to="../move-stdlib/string#0x1_string_EINVALID_UTF8">EINVALID_UTF8</Link>);
    <Link to="../move-stdlib/string#0x1_string_String">String</Link> \{ bytes }
}
</code></pre>



</details>

<Link id="0x1_string_from_ascii"></Link>

## Function `from_ascii`

Convert an ASCII string to a UTF8 string


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_from_ascii">from_ascii</Link>(s: <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_from_ascii">from_ascii</Link>(s: <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>): <Link to="../move-stdlib/string#0x1_string_String">String</Link> \{
    <Link to="../move-stdlib/string#0x1_string_String">String</Link> \{ bytes: <Link to="../move-stdlib/ascii#0x1_ascii_into_bytes">ascii::into_bytes</Link>(s) }
}
</code></pre>



</details>

<Link id="0x1_string_to_ascii"></Link>

## Function `to_ascii`

Convert an UTF8 string to an ASCII string.
Aborts if 
s is not valid ASCII


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_to_ascii">to_ascii</Link>(s: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_to_ascii">to_ascii</Link>(s: <Link to="../move-stdlib/string#0x1_string_String">String</Link>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link> \{
    <b>let</b> <Link to="../move-stdlib/string#0x1_string_String">String</Link> \{ bytes } = s;
    <Link to="../move-stdlib/ascii#0x1_ascii_string">ascii::string</Link>(bytes)
}
</code></pre>



</details>

<Link id="0x1_string_try_utf8"></Link>

## Function `try_utf8`

Tries to create a new string from a sequence of bytes.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_try_utf8">try_utf8</Link>(bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_try_utf8">try_utf8</Link>(bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): Option&lt;<Link to="../move-stdlib/string#0x1_string_String">String</Link>&gt; \{
    <b>if</b> (<Link to="../move-stdlib/string#0x1_string_internal_check_utf8">internal_check_utf8</Link>(&bytes)) \{
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(<Link to="../move-stdlib/string#0x1_string_String">String</Link> \{ bytes })
    } <b>else</b> \{
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
    }
}
</code></pre>



</details>

<Link id="0x1_string_bytes"></Link>

## Function `bytes`

Returns a reference to the underlying byte vector.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_bytes">bytes</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_bytes">bytes</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">String</Link>): &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; \{
    &s.bytes
}
</code></pre>



</details>

<Link id="0x1_string_is_empty"></Link>

## Function `is_empty`

Checks whether this string is empty.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_is_empty">is_empty</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_is_empty">is_empty</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">String</Link>): bool \{
    s.bytes.<Link to="../move-stdlib/string#0x1_string_is_empty">is_empty</Link>()
}
</code></pre>



</details>

<Link id="0x1_string_length"></Link>

## Function `length`

Returns the length of this string, in bytes.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_length">length</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_length">length</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">String</Link>): u64 \{
    s.bytes.<Link to="../move-stdlib/string#0x1_string_length">length</Link>()
}
</code></pre>



</details>

<Link id="0x1_string_append"></Link>

## Function `append`

Appends a string.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_append">append</Link>(s: &<b>mut</b> <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, r: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_append">append</Link>(s: &<b>mut</b> <Link to="../move-stdlib/string#0x1_string_String">String</Link>, r: <Link to="../move-stdlib/string#0x1_string_String">String</Link>) \{
    s.bytes.<Link to="../move-stdlib/string#0x1_string_append">append</Link>(r.bytes)
}
</code></pre>



</details>

<Link id="0x1_string_append_utf8"></Link>

## Function `append_utf8`

Appends bytes which must be in valid utf8 format.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_append_utf8">append_utf8</Link>(s: &<b>mut</b> <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_append_utf8">append_utf8</Link>(s: &<b>mut</b> <Link to="../move-stdlib/string#0x1_string_String">String</Link>, bytes: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;) \{
    s.<Link to="../move-stdlib/string#0x1_string_append">append</Link>(<Link to="../move-stdlib/string#0x1_string_utf8">utf8</Link>(bytes))
}
</code></pre>



</details>

<Link id="0x1_string_insert"></Link>

## Function `insert`

Insert the other string at the byte index in given string. The index must be at a valid utf8 char
boundary.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_insert">insert</Link>(s: &<b>mut</b> <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, at: u64, o: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_insert">insert</Link>(s: &<b>mut</b> <Link to="../move-stdlib/string#0x1_string_String">String</Link>, at: u64, o: <Link to="../move-stdlib/string#0x1_string_String">String</Link>) \{
    <b>let</b> bytes = &s.bytes;
    <b>assert</b>!(at &lt;= bytes.<Link to="../move-stdlib/string#0x1_string_length">length</Link>() && <Link to="../move-stdlib/string#0x1_string_internal_is_char_boundary">internal_is_char_boundary</Link>(bytes, at), <Link to="../move-stdlib/string#0x1_string_EINVALID_INDEX">EINVALID_INDEX</Link>);
    <b>let</b> l = s.<Link to="../move-stdlib/string#0x1_string_length">length</Link>();
    <b>let</b> <b>mut</b> front = s.<Link to="../move-stdlib/string#0x1_string_sub_string">sub_string</Link>(0, at);
    <b>let</b> end = s.<Link to="../move-stdlib/string#0x1_string_sub_string">sub_string</Link>(at, l);
    front.<Link to="../move-stdlib/string#0x1_string_append">append</Link>(o);
    front.<Link to="../move-stdlib/string#0x1_string_append">append</Link>(end);
    *s = front;
}
</code></pre>



</details>

<Link id="0x1_string_sub_string"></Link>

## Function `sub_string`

Returns a sub-string using the given byte indices, where 
i is the first byte position and 
j is the start
of the first byte not included (or the length of the string). The indices must be at valid utf8 char boundaries,
guaranteeing that the result is valid utf8.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_sub_string">sub_string</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, i: u64, j: u64): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_sub_string">sub_string</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">String</Link>, i: u64, j: u64): <Link to="../move-stdlib/string#0x1_string_String">String</Link> \{
    <b>let</b> bytes = &s.bytes;
    <b>let</b> l = bytes.<Link to="../move-stdlib/string#0x1_string_length">length</Link>();
    <b>assert</b>!(
        j &lt;= l && i &lt;= j && <Link to="../move-stdlib/string#0x1_string_internal_is_char_boundary">internal_is_char_boundary</Link>(bytes, i) && <Link to="../move-stdlib/string#0x1_string_internal_is_char_boundary">internal_is_char_boundary</Link>(bytes, j),
        <Link to="../move-stdlib/string#0x1_string_EINVALID_INDEX">EINVALID_INDEX</Link>
    );
    <Link to="../move-stdlib/string#0x1_string_String">String</Link>\{bytes: <Link to="../move-stdlib/string#0x1_string_internal_sub_string">internal_sub_string</Link>(bytes, i, j)}
}
</code></pre>



</details>

<Link id="0x1_string_index_of"></Link>

## Function `index_of`

Computes the index of the first occurrence of a string. Returns 
<Link to="../move-stdlib/string#0x1_string_length">length</Link>(s) if no occurrence found.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_index_of">index_of</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, r: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_index_of">index_of</Link>(s: &<Link to="../move-stdlib/string#0x1_string_String">String</Link>, r: &<Link to="../move-stdlib/string#0x1_string_String">String</Link>): u64 \{
    <Link to="../move-stdlib/string#0x1_string_internal_index_of">internal_index_of</Link>(&s.bytes, &r.bytes)
}
</code></pre>



</details>

<Link id="0x1_string_internal_check_utf8"></Link>

## Function `internal_check_utf8`



<pre><code>
<b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_check_utf8">internal_check_utf8</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_check_utf8">internal_check_utf8</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): bool;
</code></pre>



</details>

<Link id="0x1_string_internal_is_char_boundary"></Link>

## Function `internal_is_char_boundary`



<pre><code>
<b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_is_char_boundary">internal_is_char_boundary</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, i: u64): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_is_char_boundary">internal_is_char_boundary</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, i: u64): bool;
</code></pre>



</details>

<Link id="0x1_string_internal_sub_string"></Link>

## Function `internal_sub_string`



<pre><code>
<b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_sub_string">internal_sub_string</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, i: u64, j: u64): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_sub_string">internal_sub_string</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, i: u64, j: u64): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;;
</code></pre>



</details>

<Link id="0x1_string_internal_index_of"></Link>

## Function `internal_index_of`



<pre><code>
<b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_index_of">internal_index_of</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, r: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>native</b> <b>fun</b> <Link to="../move-stdlib/string#0x1_string_internal_index_of">internal_index_of</Link>(v: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;, r: &<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): u64;
</code></pre>



</details>
