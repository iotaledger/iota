---
title: Module `0x1::type_name`
---
import Link from '@docusaurus/Link';

<Link id="0x1_type_name"/>
Functionality for converting Move types into values. Use with care!


-  [Struct `TypeName`](#0x1_type_name_TypeName)
-  [Constants](#@Constants_0)
-  [Function `get`](#0x1_type_name_get)
-  [Function `get_with_original_ids`](#0x1_type_name_get_with_original_ids)
-  [Function `is_primitive`](#0x1_type_name_is_primitive)
-  [Function `borrow_string`](#0x1_type_name_borrow_string)
-  [Function `get_address`](#0x1_type_name_get_address)
-  [Function `get_module`](#0x1_type_name_get_module)
-  [Function `into_string`](#0x1_type_name_into_string)


<pre><code>
<b>use</b> <Link to="../move-stdlib/address#0x1_address">0x1::address</Link>;
<b>use</b> <Link to="../move-stdlib/ascii#0x1_ascii">0x1::ascii</Link>;
</code></pre>



<Link id="0x1_type_name_TypeName"></Link>

## Struct `TypeName`



<pre><code>
<b>struct</b> <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
name: <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link></code>
</dt>
<dd>
 String representation of the type. All types are represented
 using their source syntax:
 "u8", "u64", "bool", "address", "vector", and so on for primitive types.
 Struct types are represented as fully qualified type names; e.g.
 <code>
00000000000000000000000000000001::string::String</code> or
 <code>
0000000000000000000000000000000a::module_name1::type_name1&lt;0000000000000000000000000000000a::module_name2::type_name2&lt;u64&gt;&gt;</code>
 Addresses are hex-encoded lowercase values of length ADDRESS_LENGTH (16, 20, or 32 depending on the Move platform)
</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x1_type_name_ASCII_C"></Link>

ASCII Character code for the <code>
c</code> (lowercase c) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_C">ASCII_C</Link>: u8 = 99;
</code></pre>



<Link id="0x1_type_name_ASCII_COLON"></Link>

ASCII Character code for the <code>
:</code> (colon) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_COLON">ASCII_COLON</Link>: u8 = 58;
</code></pre>



<Link id="0x1_type_name_ASCII_E"></Link>

ASCII Character code for the <code>
e</code> (lowercase e) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_E">ASCII_E</Link>: u8 = 101;
</code></pre>



<Link id="0x1_type_name_ASCII_O"></Link>

ASCII Character code for the <code>
o</code> (lowercase o) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_O">ASCII_O</Link>: u8 = 111;
</code></pre>



<Link id="0x1_type_name_ASCII_R"></Link>

ASCII Character code for the <code>
r</code> (lowercase r) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_R">ASCII_R</Link>: u8 = 114;
</code></pre>



<Link id="0x1_type_name_ASCII_T"></Link>

ASCII Character code for the <code>
t</code> (lowercase t) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_T">ASCII_T</Link>: u8 = 116;
</code></pre>



<Link id="0x1_type_name_ASCII_V"></Link>

ASCII Character code for the <code>
v</code> (lowercase v) symbol.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_V">ASCII_V</Link>: u8 = 118;
</code></pre>



<Link id="0x1_type_name_ENonModuleType"></Link>

The type is not from a package/module. It is a primitive type.


<pre><code>
<b>const</b> <Link to="../move-stdlib/type_name#0x1_type_name_ENonModuleType">ENonModuleType</Link>: u64 = 0;
</code></pre>



<Link id="0x1_type_name_get"></Link>

## Function `get`

Return a value representation of the type <code>
T</code>.  Package IDs
that appear in fully qualified type names in the output from
this function are defining IDs (the ID of the package in
storage that first introduced the type).


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get">get</Link>&lt;T&gt;(): <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get">get</Link>&lt;T&gt;(): <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>;
</code></pre>



</details>

<Link id="0x1_type_name_get_with_original_ids"></Link>

## Function `get_with_original_ids`

Return a value representation of the type <code>
T</code>.  Package IDs
that appear in fully qualified type names in the output from
this function are original IDs (the ID of the first version of
the package, even if the type in question was introduced in a
later upgrade).


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get_with_original_ids">get_with_original_ids</Link>&lt;T&gt;(): <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get_with_original_ids">get_with_original_ids</Link>&lt;T&gt;(): <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>;
</code></pre>



</details>

<Link id="0x1_type_name_is_primitive"></Link>

## Function `is_primitive`

Returns true iff the TypeName represents a primitive type, i.e. one of
u8, u16, u32, u64, u128, u256, bool, address, vector.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_is_primitive">is_primitive</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_is_primitive">is_primitive</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>): bool \{
    <b>let</b> bytes = self.name.as_bytes();
    bytes == &b"bool" ||
    bytes == &b"u8" ||
    bytes == &b"u16" ||
    bytes == &b"u32" ||
    bytes == &b"u64" ||
    bytes == &b"u128" ||
    bytes == &b"u256" ||
    bytes == &b"<b>address</b>" ||
    (bytes.length() &gt;= 6 &&
     bytes[0] == <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_V">ASCII_V</Link> &&
     bytes[1] == <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_E">ASCII_E</Link> &&
     bytes[2] == <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_C">ASCII_C</Link> &&
     bytes[3] == <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_T">ASCII_T</Link> &&
     bytes[4] == <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_O">ASCII_O</Link> &&
     bytes[5] == <Link to="../move-stdlib/type_name#0x1_type_name_ASCII_R">ASCII_R</Link>)

}
</code></pre>



</details>

<Link id="0x1_type_name_borrow_string"></Link>

## Function `borrow_string`

Get the String representation of <code>
self</code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_borrow_string">borrow_string</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>): &<Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_borrow_string">borrow_string</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>): &String \{
    &self.name
}
</code></pre>



</details>

<Link id="0x1_type_name_get_address"></Link>

## Function `get_address`

Get Address string (Base16 encoded), first part of the TypeName.
Aborts if given a primitive type.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get_address">get_address</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get_address">get_address</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>): String \{
    <b>assert</b>!(!self.<Link to="../move-stdlib/type_name#0x1_type_name_is_primitive">is_primitive</Link>(), <Link to="../move-stdlib/type_name#0x1_type_name_ENonModuleType">ENonModuleType</Link>);

    // Base16 (<Link to="../move-stdlib/string#0x1_string">string</Link>) representation of an <b>address</b> <b>has</b> 2 symbols per byte.
    <b>let</b> len = <Link to="../move-stdlib/address#0x1_address_length">address::length</Link>() * 2;
    <b>let</b> str_bytes = self.name.as_bytes();
    <b>let</b> <b>mut</b> addr_bytes = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>let</b> <b>mut</b> i = 0;

    // Read `len` bytes from the type name and push them <b>to</b> addr_bytes.
    <b>while</b> (i &lt; len) \{
        addr_bytes.push_back(str_bytes[i]);
        i = i + 1;
    };

    <Link to="../move-stdlib/ascii#0x1_ascii_string">ascii::string</Link>(addr_bytes)
}
</code></pre>



</details>

<Link id="0x1_type_name_get_module"></Link>

## Function `get_module`

Get name of the module.
Aborts if given a primitive type.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get_module">get_module</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_get_module">get_module</Link>(self: &<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>): String \{
    <b>assert</b>!(!self.<Link to="../move-stdlib/type_name#0x1_type_name_is_primitive">is_primitive</Link>(), <Link to="../move-stdlib/type_name#0x1_type_name_ENonModuleType">ENonModuleType</Link>);

    // Starts after <b>address</b> and a double colon: `&lt;addr <b>as</b> HEX&gt;::`
    <b>let</b> <b>mut</b> i = <Link to="../move-stdlib/address#0x1_address_length">address::length</Link>() * 2 + 2;
    <b>let</b> str_bytes = self.name.as_bytes();
    <b>let</b> <b>mut</b> module_name = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];

    <b>loop</b> \{
        <b>let</b> char = &str_bytes[i];
        <b>if</b> (char != &<Link to="../move-stdlib/type_name#0x1_type_name_ASCII_COLON">ASCII_COLON</Link>) \{
            module_name.push_back(*char);
            i = i + 1;
        } <b>else</b> \{
            <b>break</b>
        }
    };

    <Link to="../move-stdlib/ascii#0x1_ascii_string">ascii::string</Link>(module_name)
}
</code></pre>



</details>

<Link id="0x1_type_name_into_string"></Link>

## Function `into_string`

Convert <code>
self</code> into its inner String


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_into_string">into_string</Link>(self: <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>): <Link to="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../move-stdlib/type_name#0x1_type_name_into_string">into_string</Link>(self: <Link to="../move-stdlib/type_name#0x1_type_name_TypeName">TypeName</Link>): String \{
    self.name
}
</code></pre>



</details>
