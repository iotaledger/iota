---
title: Module `0x1::option`
---
import Link from '@docusaurus/Link';

This module defines the Option type and its methods to represent and handle an optional value.


-  [Struct `Option`](#0x1_option_Option)
-  [Constants](#@Constants_0)
-  [Function `none`](#0x1_option_none)
-  [Function `some`](#0x1_option_some)
-  [Function `is_none`](#0x1_option_is_none)
-  [Function `is_some`](#0x1_option_is_some)
-  [Function `contains`](#0x1_option_contains)
-  [Function `borrow`](#0x1_option_borrow)
-  [Function `borrow_with_default`](#0x1_option_borrow_with_default)
-  [Function `get_with_default`](#0x1_option_get_with_default)
-  [Function `fill`](#0x1_option_fill)
-  [Function `extract`](#0x1_option_extract)
-  [Function `borrow_mut`](#0x1_option_borrow_mut)
-  [Function `swap`](#0x1_option_swap)
-  [Function `swap_or_fill`](#0x1_option_swap_or_fill)
-  [Function `destroy_with_default`](#0x1_option_destroy_with_default)
-  [Function `destroy_some`](#0x1_option_destroy_some)
-  [Function `destroy_none`](#0x1_option_destroy_none)
-  [Function `to_vec`](#0x1_option_to_vec)


<pre><code>
<b>use</b> <Link href="../move-stdlib/vector#0x1_vector">0x1::vector</Link>;
</code></pre>



<Link id="0x1_option_Option"></Link>

## Struct `Option`

Abstraction of a value that may or may not be present. Implemented with a vector of size
zero or one because Move bytecode does not have ADTs.


<pre><code>
<b>struct</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
vec: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x1_option_EOPTION_IS_SET"></Link>

The <code>
<Link href="../move-stdlib/option#0x1_option_Option">Option</Link></code> is in an invalid state for the operation attempted.
The <code>
<Link href="../move-stdlib/option#0x1_option_Option">Option</Link></code> is <code>
Some</code> while it should be <code>
None</code>.


<pre><code>
<b>const</b> <Link href="../move-stdlib/option#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</Link>: u64 = 262144;
</code></pre>



<Link id="0x1_option_EOPTION_NOT_SET"></Link>

The <code>
<Link href="../move-stdlib/option#0x1_option_Option">Option</Link></code> is in an invalid state for the operation attempted.
The <code>
<Link href="../move-stdlib/option#0x1_option_Option">Option</Link></code> is <code>
None</code> while it should be <code>
Some</code>.


<pre><code>
<b>const</b> <Link href="../move-stdlib/option#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</Link>: u64 = 262145;
</code></pre>



<Link id="0x1_option_none"></Link>

## Function `none`

Return an empty <code>
<Link href="../move-stdlib/option#0x1_option_Option">Option</Link></code>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_none">none</Link>&lt;Element&gt;(): <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_none">none</Link>&lt;Element&gt;(): <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt; \{
    <Link href="../move-stdlib/option#0x1_option_Option">Option</Link> \{ vec: <Link href="../move-stdlib/vector#0x1_vector_empty">vector::empty</Link>() }
}
</code></pre>



</details>

<Link id="0x1_option_some"></Link>

## Function `some`

Return an <code>
<Link href="../move-stdlib/option#0x1_option_Option">Option</Link></code> containing <code>
e</code>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_some">some</Link>&lt;Element&gt;(e: Element): <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_some">some</Link>&lt;Element&gt;(e: Element): <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt; \{
    <Link href="../move-stdlib/option#0x1_option_Option">Option</Link> \{ vec: <Link href="../move-stdlib/vector#0x1_vector_singleton">vector::singleton</Link>(e) }
}
</code></pre>



</details>

<Link id="0x1_option_is_none"></Link>

## Function `is_none`

Return true if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_is_none">is_none</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_is_none">is_none</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): bool \{
    t.vec.is_empty()
}
</code></pre>



</details>

<Link id="0x1_option_is_some"></Link>

## Function `is_some`

Return true if <code>
t</code> holds a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): bool \{
    !t.vec.is_empty()
}
</code></pre>



</details>

<Link id="0x1_option_contains"></Link>

## Function `contains`

Return true if the value in <code>
t</code> is equal to <code>
e_ref</code>
Always returns <code>
<b>false</b></code> if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_contains">contains</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, e_ref: &Element): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_contains">contains</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;, e_ref: &Element): bool \{
    t.vec.<Link href="../move-stdlib/option#0x1_option_contains">contains</Link>(e_ref)
}
</code></pre>



</details>

<Link id="0x1_option_borrow"></Link>

## Function `borrow`

Return an immutable reference to the value inside <code>
t</code>
Aborts if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_borrow">borrow</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): &Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_borrow">borrow</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): &Element \{
    <b>assert</b>!(t.<Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>(), <Link href="../move-stdlib/option#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</Link>);
    &t.vec[0]
}
</code></pre>



</details>

<Link id="0x1_option_borrow_with_default"></Link>

## Function `borrow_with_default`

Return a reference to the value inside <code>
t</code> if it holds one
Return <code>
default_ref</code> if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_borrow_with_default">borrow_with_default</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, default_ref: &Element): &Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_borrow_with_default">borrow_with_default</Link>&lt;Element&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;, default_ref: &Element): &Element \{
    <b>let</b> vec_ref = &t.vec;
    <b>if</b> (vec_ref.is_empty()) default_ref
    <b>else</b> &vec_ref[0]
}
</code></pre>



</details>

<Link id="0x1_option_get_with_default"></Link>

## Function `get_with_default`

Return the value inside <code>
t</code> if it holds one
Return <code>
default</code> if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_get_with_default">get_with_default</Link>&lt;Element: <b>copy</b>, drop&gt;(t: &<Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, default: Element): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_get_with_default">get_with_default</Link>&lt;Element: <b>copy</b> + drop&gt;(
    t: &<Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;,
    default: Element,
): Element \{
    <b>let</b> vec_ref = &t.vec;
    <b>if</b> (vec_ref.is_empty()) default
    <b>else</b> vec_ref[0]
}
</code></pre>



</details>

<Link id="0x1_option_fill"></Link>

## Function `fill`

Convert the none option <code>
t</code> to a some option by adding <code>
e</code>.
Aborts if <code>
t</code> already holds a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_fill">fill</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, e: Element)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_fill">fill</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;, e: Element) \{
    <b>let</b> vec_ref = &<b>mut</b> t.vec;
    <b>if</b> (vec_ref.is_empty()) vec_ref.push_back(e)
    <b>else</b> <b>abort</b> <Link href="../move-stdlib/option#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</Link>
}
</code></pre>



</details>

<Link id="0x1_option_extract"></Link>

## Function `extract`

Convert a <code>
some</code> option to a <code>
none</code> by removing and returning the value stored inside <code>
t</code>
Aborts if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_extract">extract</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_extract">extract</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): Element \{
    <b>assert</b>!(t.<Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>(), <Link href="../move-stdlib/option#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</Link>);
    t.vec.pop_back()
}
</code></pre>



</details>

<Link id="0x1_option_borrow_mut"></Link>

## Function `borrow_mut`

Return a mutable reference to the value inside <code>
t</code>
Aborts if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_borrow_mut">borrow_mut</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): &<b>mut</b> Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_borrow_mut">borrow_mut</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): &<b>mut</b> Element \{
    <b>assert</b>!(t.<Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>(), <Link href="../move-stdlib/option#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</Link>);
    &<b>mut</b> t.vec[0]
}
</code></pre>



</details>

<Link id="0x1_option_swap"></Link>

## Function `swap`

Swap the old value inside <code>
t</code> with <code>
e</code> and return the old value
Aborts if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_swap">swap</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, e: Element): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_swap">swap</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;, e: Element): Element \{
    <b>assert</b>!(t.<Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>(), <Link href="../move-stdlib/option#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</Link>);
    <b>let</b> vec_ref = &<b>mut</b> t.vec;
    <b>let</b> old_value = vec_ref.pop_back();
    vec_ref.push_back(e);
    old_value
}
</code></pre>



</details>

<Link id="0x1_option_swap_or_fill"></Link>

## Function `swap_or_fill`

Swap the old value inside <code>
t</code> with <code>
e</code> and return the old value;
or if there is no old value, fill it with <code>
e</code>.
Different from swap(), swap_or_fill() allows for <code>
t</code> not holding a value.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_swap_or_fill">swap_or_fill</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, e: Element): <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_swap_or_fill">swap_or_fill</Link>&lt;Element&gt;(t: &<b>mut</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;, e: Element): <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt; \{
    <b>let</b> vec_ref = &<b>mut</b> t.vec;
    <b>let</b> old_value = <b>if</b> (vec_ref.is_empty()) <Link href="../move-stdlib/option#0x1_option_none">none</Link>()
        <b>else</b> <Link href="../move-stdlib/option#0x1_option_some">some</Link>(vec_ref.pop_back());
    vec_ref.push_back(e);
    old_value
}
</code></pre>



</details>

<Link id="0x1_option_destroy_with_default"></Link>

## Function `destroy_with_default`

Destroys <code>
t.</code> If <code>
t</code> holds a value, return it. Returns <code>
default</code> otherwise


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_destroy_with_default">destroy_with_default</Link>&lt;Element: drop&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;, default: Element): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_destroy_with_default">destroy_with_default</Link>&lt;Element: drop&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;, default: Element): Element \{
    <b>let</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link> \{ <b>mut</b> vec } = t;
    <b>if</b> (vec.is_empty()) default
    <b>else</b> vec.pop_back()
}
</code></pre>



</details>

<Link id="0x1_option_destroy_some"></Link>

## Function `destroy_some`

Unpack <code>
t</code> and return its contents
Aborts if <code>
t</code> does not hold a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_destroy_some">destroy_some</Link>&lt;Element&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): Element
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_destroy_some">destroy_some</Link>&lt;Element&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): Element \{
    <b>assert</b>!(t.<Link href="../move-stdlib/option#0x1_option_is_some">is_some</Link>(), <Link href="../move-stdlib/option#0x1_option_EOPTION_NOT_SET">EOPTION_NOT_SET</Link>);
    <b>let</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link> \{ <b>mut</b> vec } = t;
    <b>let</b> elem = vec.pop_back();
    vec.destroy_empty();
    elem
}
</code></pre>



</details>

<Link id="0x1_option_destroy_none"></Link>

## Function `destroy_none`

Unpack <code>
t</code>
Aborts if <code>
t</code> holds a value


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_destroy_none">destroy_none</Link>&lt;Element&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_destroy_none">destroy_none</Link>&lt;Element&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;) \{
    <b>assert</b>!(t.<Link href="../move-stdlib/option#0x1_option_is_none">is_none</Link>(), <Link href="../move-stdlib/option#0x1_option_EOPTION_IS_SET">EOPTION_IS_SET</Link>);
    <b>let</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link> \{ vec } = t;
    vec.destroy_empty()
}
</code></pre>



</details>

<Link id="0x1_option_to_vec"></Link>

## Function `to_vec`

Convert <code>
t</code> into a vector of length 1 if it is <code>
Some</code>,
and an empty vector otherwise


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_to_vec">to_vec</Link>&lt;Element&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;Element&gt;): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../move-stdlib/option#0x1_option_to_vec">to_vec</Link>&lt;Element&gt;(t: <Link href="../move-stdlib/option#0x1_option_Option">Option</Link>&lt;Element&gt;): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;Element&gt; \{
    <b>let</b> <Link href="../move-stdlib/option#0x1_option_Option">Option</Link> \{ vec } = t;
    vec
}
</code></pre>



</details>
