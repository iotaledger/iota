---
title: Module 0x2::token
sidebar_label: token
---
import Link from '@docusaurus/Link';

<Link id="0x2_token"/>
The Token module which implements a Closed Loop Token with a configurable
policy. The policy is defined by a set of rules that must be satisfied for
an action to be performed on the token.

The module is designed to be used with a 
TreasuryCap to allow for minting
and burning of the 
<Link to="token#0x2_token_Token">Token</Link>s. And can act as a replacement / extension or a
companion to existing open-loop (
Coin) systems.

```
Module:      iota::balance       iota::coin             iota::token
Main type:   `Balance<T>`         `Coin<T>`               `Token<T>`
Capability:  `Supply<T>`  <---->  `TreasuryCap<T>` <----> `TreasuryCap<T>`
Abilities:   store              key + store           key
```

The Token system allows for fine-grained control over the actions performed
on the token. And hence it is highly suitable for applications that require
control over the currency which a simple open-loop system can't provide.


-  [Resource `Token`](#0x2_token_Token)
-  [Resource `TokenPolicyCap`](#0x2_token_TokenPolicyCap)
-  [Resource `TokenPolicy`](#0x2_token_TokenPolicy)
-  [Struct `ActionRequest`](#0x2_token_ActionRequest)
-  [Struct `RuleKey`](#0x2_token_RuleKey)
-  [Struct `TokenPolicyCreated`](#0x2_token_TokenPolicyCreated)
-  [Constants](#@Constants_0)
-  [Function `new_policy`](#0x2_token_new_policy)
-  [Function `share_policy`](#0x2_token_share_policy)
-  [Function `transfer`](#0x2_token_transfer)
-  [Function `spend`](#0x2_token_spend)
-  [Function `to_coin`](#0x2_token_to_coin)
-  [Function `from_coin`](#0x2_token_from_coin)
-  [Function `join`](#0x2_token_join)
-  [Function `split`](#0x2_token_split)
-  [Function `zero`](#0x2_token_zero)
-  [Function `destroy_zero`](#0x2_token_destroy_zero)
-  [Function `keep`](#0x2_token_keep)
-  [Function `new_request`](#0x2_token_new_request)
-  [Function `confirm_request`](#0x2_token_confirm_request)
-  [Function `confirm_request_mut`](#0x2_token_confirm_request_mut)
-  [Function `confirm_with_policy_cap`](#0x2_token_confirm_with_policy_cap)
-  [Function `confirm_with_treasury_cap`](#0x2_token_confirm_with_treasury_cap)
-  [Function `add_approval`](#0x2_token_add_approval)
-  [Function `add_rule_config`](#0x2_token_add_rule_config)
-  [Function `rule_config`](#0x2_token_rule_config)
-  [Function `rule_config_mut`](#0x2_token_rule_config_mut)
-  [Function `remove_rule_config`](#0x2_token_remove_rule_config)
-  [Function `has_rule_config`](#0x2_token_has_rule_config)
-  [Function `has_rule_config_with_type`](#0x2_token_has_rule_config_with_type)
-  [Function `allow`](#0x2_token_allow)
-  [Function `disallow`](#0x2_token_disallow)
-  [Function `add_rule_for_action`](#0x2_token_add_rule_for_action)
-  [Function `remove_rule_for_action`](#0x2_token_remove_rule_for_action)
-  [Function `mint`](#0x2_token_mint)
-  [Function `burn`](#0x2_token_burn)
-  [Function `flush`](#0x2_token_flush)
-  [Function `is_allowed`](#0x2_token_is_allowed)
-  [Function `rules`](#0x2_token_rules)
-  [Function `spent_balance`](#0x2_token_spent_balance)
-  [Function `value`](#0x2_token_value)
-  [Function `transfer_action`](#0x2_token_transfer_action)
-  [Function `spend_action`](#0x2_token_spend_action)
-  [Function `to_coin_action`](#0x2_token_to_coin_action)
-  [Function `from_coin_action`](#0x2_token_from_coin_action)
-  [Function `action`](#0x2_token_action)
-  [Function `amount`](#0x2_token_amount)
-  [Function `sender`](#0x2_token_sender)
-  [Function `recipient`](#0x2_token_recipient)
-  [Function `approvals`](#0x2_token_approvals)
-  [Function `spent`](#0x2_token_spent)
-  [Function `key`](#0x2_token_key)


<pre><code>
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../move-stdlib/string#0x1_string">0x1::string</Link>;
<b>use</b> <Link to="../move-stdlib/type_name#0x1_type_name">0x1::type_name</Link>;
<b>use</b> <Link to="balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link to="coin#0x2_coin">0x2::coin</Link>;
<b>use</b> <Link to="dynamic_field#0x2_dynamic_field">0x2::dynamic_field</Link>;
<b>use</b> <Link to="event#0x2_event">0x2::event</Link>;
<b>use</b> <Link to="object#0x2_object">0x2::object</Link>;
<b>use</b> <Link to="transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link to="tx_context#0x2_tx_context">0x2::tx_context</Link>;
<b>use</b> <Link to="vec_map#0x2_vec_map">0x2::vec_map</Link>;
<b>use</b> <Link to="vec_set#0x2_vec_set">0x2::vec_set</Link>;
</code></pre>



<Link id="0x2_token_Token"></Link>

## Resource `Token`

A single 
<Link to="token#0x2_token_Token">Token</Link> with 
Balance inside. Can only be owned by an address,
and actions performed on it must be confirmed in a matching 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

id: <Link to="object#0x2_object_UID">object::UID</Link>
</dt>
<dd>

</dd>
<dt>

<Link to="balance#0x2_balance">balance</Link>: <Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;
</dt>
<dd>
 The Balance of the 
<Link to="token#0x2_token_Token">Token</Link>.
</dd>
</dl>


</details>

<Link id="0x2_token_TokenPolicyCap"></Link>

## Resource `TokenPolicyCap`

A Capability that manages a single 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> specified in the 
for
field. Created together with 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> in the 
new function.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt; <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

id: <Link to="object#0x2_object_UID">object::UID</Link>
</dt>
<dd>

</dd>
<dt>

for: <Link to="object#0x2_object_ID">object::ID</Link>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_token_TokenPolicy"></Link>

## Resource `TokenPolicy`


<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> represents a set of rules that define what actions can be
performed on a 
<Link to="token#0x2_token_Token">Token</Link> and which 
Rules must be satisfied for the
action to succeed.

- For the sake of availability, 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> is a 
key-only object.
- Each 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> is managed by a matching 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>.
- For an action to become available, there needs to be a record in the

rules VecMap. To allow an action to be performed freely, there's an

allow function that can be called by the 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> owner.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

id: <Link to="object#0x2_object_UID">object::UID</Link>
</dt>
<dd>

</dd>
<dt>

spent_balance: <Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;
</dt>
<dd>
 The balance that is effectively spent by the user on the "spend"
 action. However, actual decrease of the supply can only be done by
 the 
TreasuryCap owner when 
flush is called.

 This balance is effectively spent and cannot be accessed by anyone
 but the 
TreasuryCap owner.
</dd>
<dt>

rules: <Link to="vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;&gt;
</dt>
<dd>
 The set of rules that define what actions can be performed on the
 token. For each "action" there's a set of Rules that must be
 satisfied for the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> to be confirmed.
</dd>
</dl>


</details>

<Link id="0x2_token_ActionRequest"></Link>

## Struct `ActionRequest`

A request to perform an "Action" on a token. Stores the information
about the action to be performed and must be consumed by the 
confirm_request
or 
confirm_request_mut functions when the Rules are satisfied.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

name: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</dt>
<dd>
 Name of the Action to look up in the Policy. Name can be one of the
 default actions: 
<Link to="transfer#0x2_transfer">transfer</Link>, 
spend, 
to_coin, 
from_coin or a
 custom action.
</dd>
<dt>

amount: u64
</dt>
<dd>
 Amount is present in all of the txs
</dd>
<dt>

sender: <b>address</b>
</dt>
<dd>
 Sender is a permanent field always
</dd>
<dt>

recipient: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;
</dt>
<dd>
 Recipient is only available in 
<Link to="transfer#0x2_transfer">transfer</Link> action.
</dd>
<dt>

spent_balance: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;&gt;
</dt>
<dd>
 The balance to be "spent" in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>, only available
 in the 
spend action.
</dd>
<dt>

approvals: <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;
</dt>
<dd>
 Collected approvals (stamps) from completed 
Rules. They're matched
 against 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.rules to determine if the request can be
 confirmed.
</dd>
</dl>


</details>

<Link id="0x2_token_RuleKey"></Link>

## Struct `RuleKey`

Dynamic field key for the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> to store the 
Config for a
specific action 
Rule. There can be only one configuration per

Rule per 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;T&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

is_protected: bool
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_token_TokenPolicyCreated"></Link>

## Struct `TokenPolicyCreated`

An event emitted when a 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> is created and shared. Because

<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> can only be shared (and potentially frozen in the future),
we emit this event in the 
share_policy function and mark it as mutable.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_TokenPolicyCreated">TokenPolicyCreated</Link>&lt;T&gt; <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>

id: <Link to="object#0x2_object_ID">object::ID</Link>
</dt>
<dd>
 ID of the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> that was created.
</dd>
<dt>

is_mutable: bool
</dt>
<dd>
 Whether the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> is "shared" (mutable) or "frozen"
 (immutable) - TBD.
</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x2_token_ENotAuthorized"></Link>

Trying to perform an admin action with a wrong cap.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>: u64 = 2;
</code></pre>



<Link id="0x2_token_EBalanceTooLow"></Link>

The balance is too low to perform the action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_EBalanceTooLow">EBalanceTooLow</Link>: u64 = 3;
</code></pre>



<Link id="0x2_token_ECantConsumeBalance"></Link>

The balance is not zero when trying to confirm with 
TransferPolicyCap.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ECantConsumeBalance">ECantConsumeBalance</Link>: u64 = 5;
</code></pre>



<Link id="0x2_token_ENoConfig"></Link>

Rule is trying to access a missing config (with type).


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>: u64 = 6;
</code></pre>



<Link id="0x2_token_ENotApproved"></Link>

The rule was not approved.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENotApproved">ENotApproved</Link>: u64 = 1;
</code></pre>



<Link id="0x2_token_ENotZero"></Link>

The balance is not zero.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENotZero">ENotZero</Link>: u64 = 4;
</code></pre>



<Link id="0x2_token_EUnknownAction"></Link>

The action is not allowed (defined) in the policy.


<pre><code>
<b>const</b> <Link to="token#0x2_token_EUnknownAction">EUnknownAction</Link>: u64 = 0;
</code></pre>



<Link id="0x2_token_EUseImmutableConfirm"></Link>

Using 
confirm_request_mut without 
spent_balance. Immutable version
of the function must be used instead.


<pre><code>
<b>const</b> <Link to="token#0x2_token_EUseImmutableConfirm">EUseImmutableConfirm</Link>: u64 = 7;
</code></pre>



<Link id="0x2_token_FROM_COIN"></Link>

A Tag for the 
from_coin action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_FROM_COIN">FROM_COIN</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [102, 114, 111, 109, 95, 99, 111, 105, 110];
</code></pre>



<Link id="0x2_token_SPEND"></Link>

A Tag for the 
spend action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_SPEND">SPEND</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [115, 112, 101, 110, 100];
</code></pre>



<Link id="0x2_token_TO_COIN"></Link>

A Tag for the 
to_coin action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_TO_COIN">TO_COIN</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [116, 111, 95, 99, 111, 105, 110];
</code></pre>



<Link id="0x2_token_TRANSFER"></Link>

A Tag for the 
<Link to="transfer#0x2_transfer">transfer</Link> action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_TRANSFER">TRANSFER</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [116, 114, 97, 110, 115, 102, 101, 114];
</code></pre>



<Link id="0x2_token_new_policy"></Link>

## Function `new_policy`

Create a new 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> and a matching 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>.
The 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> must then be shared using the 
share_policy method.


TreasuryCap guarantees full ownership over the currency, and is unique,
hence it is safe to use it for authorization.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_policy">new_policy</Link>&lt;T&gt;(_treasury_cap: &<Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, <Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_policy">new_policy</Link>&lt;T&gt;(
    _treasury_cap: &TreasuryCap&lt;T&gt;, ctx: &<b>mut</b> TxContext
): (<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, <Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;) \{
    <b>let</b> policy = <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        spent_balance: <Link to="balance#0x2_balance_zero">balance::zero</Link>(),
        rules: <Link to="vec_map#0x2_vec_map_empty">vec_map::empty</Link>()
    };

    <b>let</b> cap = <Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        `for`: <Link to="object#0x2_object_id">object::id</Link>(&policy)
    };

    (policy, cap)
}
</code></pre>



</details>

<Link id="0x2_token_share_policy"></Link>

## Function `share_policy`

Share the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>. Due to 
key-only restriction, it must be
shared after initialization.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_share_policy">share_policy</Link>&lt;T&gt;(policy: <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_share_policy">share_policy</Link>&lt;T&gt;(policy: <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;) \{
    <Link to="event#0x2_event_emit">event::emit</Link>(<Link to="token#0x2_token_TokenPolicyCreated">TokenPolicyCreated</Link>&lt;T&gt; \{
        id: <Link to="object#0x2_object_id">object::id</Link>(&policy),
        is_mutable: <b>true</b>,
    });

    <Link to="transfer#0x2_transfer_share_object">transfer::share_object</Link>(policy)
}
</code></pre>



</details>

<Link id="0x2_token_transfer"></Link>

## Function `transfer`

Transfer a 
<Link to="token#0x2_token_Token">Token</Link> to a 
recipient. Creates an 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> for the
"transfer" action. The 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> contains the 
recipient field
to be used in verification.


<pre><code>
<b>public</b> <b>fun</b> <Link to="transfer#0x2_transfer">transfer</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, recipient: <b>address</b>, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="transfer#0x2_transfer">transfer</Link>&lt;T&gt;(
    t: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, recipient: <b>address</b>, ctx: &<b>mut</b> TxContext
): <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt; \{
    <b>let</b> amount = t.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>();
    <Link to="transfer#0x2_transfer_transfer">transfer::transfer</Link>(t, recipient);

    <Link to="token#0x2_token_new_request">new_request</Link>(
        <Link to="token#0x2_token_transfer_action">transfer_action</Link>(),
        amount,
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(recipient),
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
        ctx
    )
}
</code></pre>



</details>

<Link id="0x2_token_spend"></Link>

## Function `spend`

Spend a 
<Link to="token#0x2_token_Token">Token</Link> by unwrapping it and storing the 
Balance in the

<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> for the "spend" action. The 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> contains
the 
spent_balance field to be used in verification.

Spend action requires 
confirm_request_mut to be called to confirm the
request and join the spent balance with the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.spent_balance.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend">spend</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend">spend</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, ctx: &<b>mut</b> TxContext): <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt; \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = t;
    id.delete();

    <Link to="token#0x2_token_new_request">new_request</Link>(
        <Link to="token#0x2_token_spend_action">spend_action</Link>(),
        <Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>(),
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(<Link to="balance#0x2_balance">balance</Link>),
        ctx
    )
}
</code></pre>



</details>

<Link id="0x2_token_to_coin"></Link>

## Function `to_coin`

Convert 
<Link to="token#0x2_token_Token">Token</Link> into an open 
Coin. Creates an 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> for the
"to_coin" action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin">to_coin</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="coin#0x2_coin_Coin">coin::Coin</Link>&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin">to_coin</Link>&lt;T&gt;(
    t: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, ctx: &<b>mut</b> TxContext
): (Coin&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = t;
    <b>let</b> amount = <Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>();
    id.delete();

    (
        <Link to="balance#0x2_balance">balance</Link>.into_coin(ctx),
        <Link to="token#0x2_token_new_request">new_request</Link>(
            <Link to="token#0x2_token_to_coin_action">to_coin_action</Link>(),
            amount,
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            ctx
        )
    )
}
</code></pre>



</details>

<Link id="0x2_token_from_coin"></Link>

## Function `from_coin`

Convert an open 
Coin into a 
<Link to="token#0x2_token_Token">Token</Link>. Creates an 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> for
the "from_coin" action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin">from_coin</Link>&lt;T&gt;(<Link to="coin#0x2_coin">coin</Link>: <Link to="coin#0x2_coin_Coin">coin::Coin</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin">from_coin</Link>&lt;T&gt;(
    <Link to="coin#0x2_coin">coin</Link>: Coin&lt;T&gt;, ctx: &<b>mut</b> TxContext
): (<Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;) \{
    <b>let</b> amount = <Link to="coin#0x2_coin">coin</Link>.<Link to="token#0x2_token_value">value</Link>();
    <b>let</b> <Link to="token#0x2_token">token</Link> = <Link to="token#0x2_token_Token">Token</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        <Link to="balance#0x2_balance">balance</Link>: <Link to="coin#0x2_coin">coin</Link>.into_balance()
    };

    (
        <Link to="token#0x2_token">token</Link>,
        <Link to="token#0x2_token_new_request">new_request</Link>(
            <Link to="token#0x2_token_from_coin_action">from_coin_action</Link>(),
            amount,
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            ctx
        )
    )
}
</code></pre>



</details>

<Link id="0x2_token_join"></Link>

## Function `join`

Join two 
<Link to="token#0x2_token_Token">Token</Link>s into one, always available.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_join">join</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, another: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_join">join</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, another: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = another;
    <Link to="token#0x2_token">token</Link>.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_join">join</Link>(<Link to="balance#0x2_balance">balance</Link>);
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_token_split"></Link>

## Function `split`

Split a 
<Link to="token#0x2_token_Token">Token</Link> with 
amount.
Aborts if the 
<Link to="token#0x2_token_Token">Token</Link>.<Link to="balance#0x2_balance">balance</Link> is lower than 
amount.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_split">split</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, amount: u64, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_split">split</Link>&lt;T&gt;(
    <Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, amount: u64, ctx: &<b>mut</b> TxContext
): <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; \{
    <b>assert</b>!(<Link to="token#0x2_token">token</Link>.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>() &gt;= amount, <Link to="token#0x2_token_EBalanceTooLow">EBalanceTooLow</Link>);
    <Link to="token#0x2_token_Token">Token</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        <Link to="balance#0x2_balance">balance</Link>: <Link to="token#0x2_token">token</Link>.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_split">split</Link>(amount),
    }
}
</code></pre>



</details>

<Link id="0x2_token_zero"></Link>

## Function `zero`

Create a zero 
<Link to="token#0x2_token_Token">Token</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_zero">zero</Link>&lt;T&gt;(ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_zero">zero</Link>&lt;T&gt;(ctx: &<b>mut</b> TxContext): <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; \{
    <Link to="token#0x2_token_Token">Token</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        <Link to="balance#0x2_balance">balance</Link>: <Link to="balance#0x2_balance_zero">balance::zero</Link>(),
    }
}
</code></pre>



</details>

<Link id="0x2_token_destroy_zero"></Link>

## Function `destroy_zero`

Destroy an empty 
<Link to="token#0x2_token_Token">Token</Link>, fails if the balance is non-zero.
Aborts if the 
<Link to="token#0x2_token_Token">Token</Link>.<Link to="balance#0x2_balance">balance</Link> is not zero.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_destroy_zero">destroy_zero</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_destroy_zero">destroy_zero</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = <Link to="token#0x2_token">token</Link>;
    <b>assert</b>!(<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>() == 0, <Link to="token#0x2_token_ENotZero">ENotZero</Link>);
    <Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_destroy_zero">destroy_zero</Link>();
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_token_keep"></Link>

## Function `keep`

Transfer the 
<Link to="token#0x2_token_Token">Token</Link> to the transaction sender.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_keep">keep</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_keep">keep</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, ctx: &<b>mut</b> TxContext) \{
    <Link to="transfer#0x2_transfer_transfer">transfer::transfer</Link>(<Link to="token#0x2_token">token</Link>, ctx.<Link to="token#0x2_token_sender">sender</Link>())
}
</code></pre>



</details>

<Link id="0x2_token_new_request"></Link>

## Function `new_request`

Create a new 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.
Publicly available method to allow for custom actions.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_request">new_request</Link>&lt;T&gt;(name: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, amount: u64, recipient: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;, spent_balance: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;&gt;, ctx: &<Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_request">new_request</Link>&lt;T&gt;(
    name: String,
    amount: u64,
    recipient: Option&lt;<b>address</b>&gt;,
    spent_balance: Option&lt;Balance&lt;T&gt;&gt;,
    ctx: &TxContext
): <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt; \{
    <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name,
        amount,
        recipient,
        spent_balance,
        sender: ctx.<Link to="token#0x2_token_sender">sender</Link>(),
        approvals: <Link to="vec_set#0x2_vec_set_empty">vec_set::empty</Link>(),
    }
}
</code></pre>



</details>

<Link id="0x2_token_confirm_request"></Link>

## Function `confirm_request`

Confirm the request against the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> and return the parameters
of the request: (Name, Amount, Sender, Recipient).

Cannot be used for 
spend and similar actions that deliver 
spent_balance
to the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>. For those actions use 
confirm_request_mut.

Aborts if:
- the action is not allowed (missing record in 
rules)
- action contains 
spent_balance (use 
confirm_request_mut)
- the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> does not meet the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> rules for the action


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request">confirm_request</Link>&lt;T&gt;(policy: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request">confirm_request</Link>&lt;T&gt;(
    policy: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>assert</b>!(request.spent_balance.is_none(), <Link to="token#0x2_token_ECantConsumeBalance">ECantConsumeBalance</Link>);
    <b>assert</b>!(policy.rules.contains(&request.name), <Link to="token#0x2_token_EUnknownAction">EUnknownAction</Link>);

    <b>let</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name, approvals,
        spent_balance,
        amount, sender, recipient,
    } = request;

    spent_balance.destroy_none();

    <b>let</b> rules = &(*policy.rules.get(&name)).into_keys();
    <b>let</b> rules_len = rules.length();
    <b>let</b> <b>mut</b> i = 0;

    <b>while</b> (i &lt; rules_len) \{
        <b>let</b> rule = &rules[i];
        <b>assert</b>!(approvals.contains(rule), <Link to="token#0x2_token_ENotApproved">ENotApproved</Link>);
        i = i + 1;
    };

    (name, amount, sender, recipient)
}
</code></pre>



</details>

<Link id="0x2_token_confirm_request_mut"></Link>

## Function `confirm_request_mut`

Confirm the request against the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> and return the parameters
of the request: (Name, Amount, Sender, Recipient).

Unlike 
confirm_request this function requires mutable access to the

<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> and must be used on 
spend action. After dealing with the
spent balance it calls 
confirm_request internally.

See 
confirm_request for the list of abort conditions.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request_mut">confirm_request_mut</Link>&lt;T&gt;(policy: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request_mut">confirm_request_mut</Link>&lt;T&gt;(
    policy: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    <b>mut</b> request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>assert</b>!(policy.rules.contains(&request.name), <Link to="token#0x2_token_EUnknownAction">EUnknownAction</Link>);
    <b>assert</b>!(request.spent_balance.is_some(), <Link to="token#0x2_token_EUseImmutableConfirm">EUseImmutableConfirm</Link>);

    policy.spent_balance.<Link to="token#0x2_token_join">join</Link>(request.spent_balance.extract());

    <Link to="token#0x2_token_confirm_request">confirm_request</Link>(policy, request, ctx)
}
</code></pre>



</details>

<Link id="0x2_token_confirm_with_policy_cap"></Link>

## Function `confirm_with_policy_cap`

Confirm an 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> as the 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> owner. This function
allows 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> owner to perform Capability-gated actions ignoring
the ruleset specified in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.

Aborts if request contains 
spent_balance due to inability of the

<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> to decrease supply. For scenarios like this a

TreasuryCap is required (see 
confirm_with_treasury_cap).


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_policy_cap">confirm_with_policy_cap</Link>&lt;T&gt;(_policy_cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_policy_cap">confirm_with_policy_cap</Link>&lt;T&gt;(
    _policy_cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>assert</b>!(request.spent_balance.is_none(), <Link to="token#0x2_token_ECantConsumeBalance">ECantConsumeBalance</Link>);

    <b>let</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name, amount, sender, recipient, approvals: _, spent_balance
    } = request;

    spent_balance.destroy_none();

    (name, amount, sender, recipient)
}
</code></pre>



</details>

<Link id="0x2_token_confirm_with_treasury_cap"></Link>

## Function `confirm_with_treasury_cap`

Confirm an 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> as the 
TreasuryCap owner. This function
allows 
TreasuryCap owner to perform Capability-gated actions ignoring
the ruleset specified in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.

Unlike 
confirm_with_policy_cap this function allows 
spent_balance
to be consumed, decreasing the 
total_supply of the 
<Link to="token#0x2_token_Token">Token</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_treasury_cap">confirm_with_treasury_cap</Link>&lt;T&gt;(treasury_cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_treasury_cap">confirm_with_treasury_cap</Link>&lt;T&gt;(
    treasury_cap: &<b>mut</b> TreasuryCap&lt;T&gt;,
    request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>let</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name, amount, sender, recipient, approvals: _,
        spent_balance
    } = request;

    <b>if</b> (spent_balance.is_some()) \{
        treasury_cap.supply_mut().decrease_supply(spent_balance.destroy_some());
    } <b>else</b> \{
        spent_balance.destroy_none();
    };

    (name, amount, sender, recipient)
}
</code></pre>



</details>

<Link id="0x2_token_add_approval"></Link>

## Function `add_approval`

Add an "approval" to the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link> by providing a Witness.
Intended to be used by Rules to add their own approvals, however, can
be used to add arbitrary approvals to the request (not only the ones
required by the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>).


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_approval">add_approval</Link>&lt;T, W: drop&gt;(_t: W, request: &<b>mut</b> <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_approval">add_approval</Link>&lt;T, W: drop&gt;(
    _t: W, request: &<b>mut</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> TxContext
) \{
    request.approvals.insert(<Link to="../move-stdlib/type_name#0x1_type_name_get">type_name::get</Link>&lt;W&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_add_rule_config"></Link>

## Function `add_rule_config`

Add a 
Config for a 
Rule in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>. Rule configuration is
independent from the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.rules and needs to be managed by the
Rule itself. Configuration is stored per 
Rule and not per 
Rule per

Action to allow reuse in different actions.

- Rule witness guarantees that the 
Config is approved by the Rule.
- 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> guarantees that the 
Config setup is initiated by
the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> owner.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_config">add_rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(_rule: Rule, self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, config: Config, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_config">add_rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(
    _rule: Rule,
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    config: Config,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    df::add(&<b>mut</b> self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;(), config)
}
</code></pre>



</details>

<Link id="0x2_token_rule_config"></Link>

## Function `rule_config`

Get a 
Config for a 
Rule in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>. Requires 
Rule
witness, hence can only be read by the 
Rule itself. This requirement
guarantees safety of the stored 
Config and allows for simpler dynamic
field management inside the Rule Config (custom type keys are not needed
for access gating).

Aborts if the Config is not present.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config">rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(_rule: Rule, self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): &Config
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config">rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(
    _rule: Rule, self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;
): &Config \{
    <b>assert</b>!(<Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config&gt;(self), <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>);
    df::borrow(&self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_rule_config_mut"></Link>

## Function `rule_config_mut`

Get mutable access to the 
Config for a 
Rule in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.
Requires 
Rule witness, hence can only be read by the 
Rule itself,
as well as 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> to guarantee that the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> owner
is the one who initiated the 
Config modification.

Aborts if:
- the Config is not present
- 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> is not matching the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config_mut">rule_config_mut</Link>&lt;T, Rule: drop, Config: store&gt;(_rule: Rule, self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;): &<b>mut</b> Config
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config_mut">rule_config_mut</Link>&lt;T, Rule: drop, Config: store&gt;(
    _rule: Rule, self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;
): &<b>mut</b> Config \{
    <b>assert</b>!(<Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config&gt;(self), <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>);
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    df::borrow_mut(&<b>mut</b> self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_remove_rule_config"></Link>

## Function `remove_rule_config`

Remove a 
Config for a 
Rule in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.
Unlike the 
add_rule_config, this function does not require a 
Rule
witness, hence can be performed by the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> owner on their own.

Rules need to make sure that the 
Config is present when performing
verification of the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.

Aborts if:
- the Config is not present
- 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> is not matching the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_config">remove_rule_config</Link>&lt;T, Rule, Config: store&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): Config
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_config">remove_rule_config</Link>&lt;T, Rule, Config: store&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): Config \{
    <b>assert</b>!(<Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config&gt;(self), <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>);
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    df::remove(&<b>mut</b> self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_has_rule_config"></Link>

## Function `has_rule_config`

Check if a config for a 
Rule is set in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> without
checking the type of the 
Config.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config">has_rule_config</Link>&lt;T, Rule&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config">has_rule_config</Link>&lt;T, Rule&gt;(self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;): bool \{
    df::exists_&lt;<Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;Rule&gt;&gt;(&self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_has_rule_config_with_type"></Link>

## Function `has_rule_config_with_type`

Check if a 
Config for a 
Rule is set in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> and that
it matches the type provided.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config: store&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config: store&gt;(
    self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;
): bool \{
    df::exists_with_type&lt;<Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;Rule&gt;, Config&gt;(&self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_allow"></Link>

## Function `allow`

Allows an 
action to be performed on the 
<Link to="token#0x2_token_Token">Token</Link> freely by adding an
empty set of 
Rules for the 
action.

Aborts if the 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> is not matching the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_allow">allow</Link>&lt;T&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_allow">allow</Link>&lt;T&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    self.rules.insert(action, <Link to="vec_set#0x2_vec_set_empty">vec_set::empty</Link>());
}
</code></pre>



</details>

<Link id="0x2_token_disallow"></Link>

## Function `disallow`

Completely disallows an 
action on the 
<Link to="token#0x2_token_Token">Token</Link> by removing the record
from the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.rules.

Aborts if the 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> is not matching the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_disallow">disallow</Link>&lt;T&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_disallow">disallow</Link>&lt;T&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    self.rules.remove(&action);
}
</code></pre>



</details>

<Link id="0x2_token_add_rule_for_action"></Link>

## Function `add_rule_for_action`

Adds a Rule for an action with 
name in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.

Aborts if the 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> is not matching the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_for_action">add_rule_for_action</Link>&lt;T, Rule: drop&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_for_action">add_rule_for_action</Link>&lt;T, Rule: drop&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    <b>if</b> (!self.rules.contains(&action)) \{
        <Link to="token#0x2_token_allow">allow</Link>(self, cap, action, ctx);
    };

    self.rules.get_mut(&action).insert(<Link to="../move-stdlib/type_name#0x1_type_name_get">type_name::get</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_remove_rule_for_action"></Link>

## Function `remove_rule_for_action`

Removes a rule for an action with 
name in the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>. Returns
the config object to be handled by the sender (or a Rule itself).

Aborts if the 
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> is not matching the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_for_action">remove_rule_for_action</Link>&lt;T, Rule: drop&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_for_action">remove_rule_for_action</Link>&lt;T, Rule: drop&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);

    self.rules.get_mut(&action).remove(&<Link to="../move-stdlib/type_name#0x1_type_name_get">type_name::get</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_mint"></Link>

## Function `mint`

Mint a 
<Link to="token#0x2_token_Token">Token</Link> with a given 
amount using the 
TreasuryCap.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_mint">mint</Link>&lt;T&gt;(cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, amount: u64, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_mint">mint</Link>&lt;T&gt;(
    cap: &<b>mut</b> TreasuryCap&lt;T&gt;, amount: u64, ctx: &<b>mut</b> TxContext
): <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; \{
    <b>let</b> <Link to="balance#0x2_balance">balance</Link> = cap.supply_mut().increase_supply(amount);
    <Link to="token#0x2_token_Token">Token</Link> \{ id: <Link to="object#0x2_object_new">object::new</Link>(ctx), <Link to="balance#0x2_balance">balance</Link> }
}
</code></pre>



</details>

<Link id="0x2_token_burn"></Link>

## Function `burn`

Burn a 
<Link to="token#0x2_token_Token">Token</Link> using the 
TreasuryCap.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_burn">burn</Link>&lt;T&gt;(cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, <Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_burn">burn</Link>&lt;T&gt;(cap: &<b>mut</b> TreasuryCap&lt;T&gt;, <Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = <Link to="token#0x2_token">token</Link>;
    cap.supply_mut().decrease_supply(<Link to="balance#0x2_balance">balance</Link>);
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_token_flush"></Link>

## Function `flush`

Flush the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.spent_balance into the 
TreasuryCap. This
action is only available to the 
TreasuryCap owner.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_flush">flush</Link>&lt;T&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_flush">flush</Link>&lt;T&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<b>mut</b> TreasuryCap&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): u64 \{
    <b>let</b> amount = self.spent_balance.<Link to="token#0x2_token_value">value</Link>();
    <b>let</b> <Link to="balance#0x2_balance">balance</Link> = self.spent_balance.<Link to="token#0x2_token_split">split</Link>(amount);
    cap.supply_mut().decrease_supply(<Link to="balance#0x2_balance">balance</Link>)
}
</code></pre>



</details>

<Link id="0x2_token_is_allowed"></Link>

## Function `is_allowed`

Check whether an action is present in the rules VecMap.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_is_allowed">is_allowed</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, action: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_is_allowed">is_allowed</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, action: &String): bool \{
    self.rules.contains(action)
}
</code></pre>



</details>

<Link id="0x2_token_rules"></Link>

## Function `rules`

Returns the rules required for a specific action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rules">rules</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, action: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rules">rules</Link>&lt;T&gt;(
    self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, action: &String
): VecSet&lt;TypeName&gt; \{
    *self.rules.get(action)
}
</code></pre>



</details>

<Link id="0x2_token_spent_balance"></Link>

## Function `spent_balance`

Returns the 
spent_balance of the 
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent_balance">spent_balance</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent_balance">spent_balance</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;): u64 \{
    self.spent_balance.<Link to="token#0x2_token_value">value</Link>()
}
</code></pre>



</details>

<Link id="0x2_token_value"></Link>

## Function `value`

Returns the 
<Link to="balance#0x2_balance">balance</Link> of the 
<Link to="token#0x2_token_Token">Token</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_value">value</Link>&lt;T&gt;(t: &<Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_value">value</Link>&lt;T&gt;(t: &<Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;): u64 \{
    t.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>()
}
</code></pre>



</details>

<Link id="0x2_token_transfer_action"></Link>

## Function `transfer_action`

Name of the Transfer action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_transfer_action">transfer_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_transfer_action">transfer_action</Link>(): String \{
    <b>let</b> transfer_str = <Link to="token#0x2_token_TRANSFER">TRANSFER</Link>;
    transfer_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_spend_action"></Link>

## Function `spend_action`

Name of the 
Spend action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend_action">spend_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend_action">spend_action</Link>(): String \{
    <b>let</b> spend_str = <Link to="token#0x2_token_SPEND">SPEND</Link>;
    spend_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_to_coin_action"></Link>

## Function `to_coin_action`

Name of the 
ToCoin action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin_action">to_coin_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin_action">to_coin_action</Link>(): String \{
    <b>let</b> to_coin_str = <Link to="token#0x2_token_TO_COIN">TO_COIN</Link>;
    to_coin_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_from_coin_action"></Link>

## Function `from_coin_action`

Name of the 
FromCoin action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin_action">from_coin_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin_action">from_coin_action</Link>(): String \{
    <b>let</b> from_coin_str = <Link to="token#0x2_token_FROM_COIN">FROM_COIN</Link>;
    from_coin_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_action"></Link>

## Function `action`

The Action in the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_action">action</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_action">action</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): String \{ self.name }
</code></pre>



</details>

<Link id="0x2_token_amount"></Link>

## Function `amount`

Amount of the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_amount">amount</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_amount">amount</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): u64 \{ self.amount }
</code></pre>



</details>

<Link id="0x2_token_sender"></Link>

## Function `sender`

Sender of the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_sender">sender</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_sender">sender</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): <b>address</b> \{ self.sender }
</code></pre>



</details>

<Link id="0x2_token_recipient"></Link>

## Function `recipient`

Recipient of the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_recipient">recipient</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_recipient">recipient</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): Option&lt;<b>address</b>&gt; \{
    self.recipient
}
</code></pre>



</details>

<Link id="0x2_token_approvals"></Link>

## Function `approvals`

Approvals of the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_approvals">approvals</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_approvals">approvals</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): VecSet&lt;TypeName&gt; \{
    self.approvals
}
</code></pre>



</details>

<Link id="0x2_token_spent"></Link>

## Function `spent`

Burned balance of the 
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent">spent</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent">spent</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): Option&lt;u64&gt; \{
    <b>if</b> (self.spent_balance.is_some()) \{
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(self.spent_balance.<Link to="borrow#0x2_borrow">borrow</Link>().<Link to="token#0x2_token_value">value</Link>())
    } <b>else</b> \{
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
    }
}
</code></pre>



</details>

<Link id="0x2_token_key"></Link>

## Function `key`

Create a new 
<Link to="token#0x2_token_RuleKey">RuleKey</Link> for a 
Rule. The 
is_protected field is kept
for potential future use, if Rules were to have a freely modifiable
storage as addition / replacement for the 
Config system.

The goal of 
is_protected is to potentially allow Rules store a mutable
version of their configuration and mutate state on user action.


<pre><code>
<b>fun</b> <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;(): <Link to="token#0x2_token_RuleKey">token::RuleKey</Link>&lt;Rule&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;(): <Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;Rule&gt; \{ <Link to="token#0x2_token_RuleKey">RuleKey</Link> \{ is_protected: <b>true</b> } }
</code></pre>



</details>
