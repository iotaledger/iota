---
title: Module `0x2::token`
---
import Link from '@docusaurus/Link';

<Link id="0x2_token"/>
The Token module which implements a Closed Loop Token with a configurable
policy. The policy is defined by a set of rules that must be satisfied for
an action to be performed on the token.

The module is designed to be used with a <code>
TreasuryCap</code> to allow for minting
and burning of the <code>
<Link to="token#0x2_token_Token">Token</Link></code>s. And can act as a replacement / extension or a
companion to existing open-loop (<code>
Coin</code>) systems.

```
Module:      iota::balance       iota::coin             iota::token
Main type:   `Balance<T>`         `Coin<T>`               `Token<T>`
Capability:  `Supply<T>`  <---->  `TreasuryCap<T>` <----> `TreasuryCap<T>`
Abilities:   store              key + store           key
```

The Token system allows for fine-grained control over the actions performed
on the token. And hence it is highly suitable for applications that require
control over the currency which a simple open-loop system can't provide.


-  [Resource `Token`](#0x2_token_Token)
-  [Resource `TokenPolicyCap`](#0x2_token_TokenPolicyCap)
-  [Resource `TokenPolicy`](#0x2_token_TokenPolicy)
-  [Struct `ActionRequest`](#0x2_token_ActionRequest)
-  [Struct `RuleKey`](#0x2_token_RuleKey)
-  [Struct `TokenPolicyCreated`](#0x2_token_TokenPolicyCreated)
-  [Constants](#@Constants_0)
-  [Function `new_policy`](#0x2_token_new_policy)
-  [Function `share_policy`](#0x2_token_share_policy)
-  [Function `transfer`](#0x2_token_transfer)
-  [Function `spend`](#0x2_token_spend)
-  [Function `to_coin`](#0x2_token_to_coin)
-  [Function `from_coin`](#0x2_token_from_coin)
-  [Function `join`](#0x2_token_join)
-  [Function `split`](#0x2_token_split)
-  [Function `zero`](#0x2_token_zero)
-  [Function `destroy_zero`](#0x2_token_destroy_zero)
-  [Function `keep`](#0x2_token_keep)
-  [Function `new_request`](#0x2_token_new_request)
-  [Function `confirm_request`](#0x2_token_confirm_request)
-  [Function `confirm_request_mut`](#0x2_token_confirm_request_mut)
-  [Function `confirm_with_policy_cap`](#0x2_token_confirm_with_policy_cap)
-  [Function `confirm_with_treasury_cap`](#0x2_token_confirm_with_treasury_cap)
-  [Function `add_approval`](#0x2_token_add_approval)
-  [Function `add_rule_config`](#0x2_token_add_rule_config)
-  [Function `rule_config`](#0x2_token_rule_config)
-  [Function `rule_config_mut`](#0x2_token_rule_config_mut)
-  [Function `remove_rule_config`](#0x2_token_remove_rule_config)
-  [Function `has_rule_config`](#0x2_token_has_rule_config)
-  [Function `has_rule_config_with_type`](#0x2_token_has_rule_config_with_type)
-  [Function `allow`](#0x2_token_allow)
-  [Function `disallow`](#0x2_token_disallow)
-  [Function `add_rule_for_action`](#0x2_token_add_rule_for_action)
-  [Function `remove_rule_for_action`](#0x2_token_remove_rule_for_action)
-  [Function `mint`](#0x2_token_mint)
-  [Function `burn`](#0x2_token_burn)
-  [Function `flush`](#0x2_token_flush)
-  [Function `is_allowed`](#0x2_token_is_allowed)
-  [Function `rules`](#0x2_token_rules)
-  [Function `spent_balance`](#0x2_token_spent_balance)
-  [Function `value`](#0x2_token_value)
-  [Function `transfer_action`](#0x2_token_transfer_action)
-  [Function `spend_action`](#0x2_token_spend_action)
-  [Function `to_coin_action`](#0x2_token_to_coin_action)
-  [Function `from_coin_action`](#0x2_token_from_coin_action)
-  [Function `action`](#0x2_token_action)
-  [Function `amount`](#0x2_token_amount)
-  [Function `sender`](#0x2_token_sender)
-  [Function `recipient`](#0x2_token_recipient)
-  [Function `approvals`](#0x2_token_approvals)
-  [Function `spent`](#0x2_token_spent)
-  [Function `key`](#0x2_token_key)


<pre><code>
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../move-stdlib/string#0x1_string">0x1::string</Link>;
<b>use</b> <Link to="../move-stdlib/type_name#0x1_type_name">0x1::type_name</Link>;
<b>use</b> <Link to="balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link to="coin#0x2_coin">0x2::coin</Link>;
<b>use</b> <Link to="dynamic_field#0x2_dynamic_field">0x2::dynamic_field</Link>;
<b>use</b> <Link to="event#0x2_event">0x2::event</Link>;
<b>use</b> <Link to="object#0x2_object">0x2::object</Link>;
<b>use</b> <Link to="transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link to="tx_context#0x2_tx_context">0x2::tx_context</Link>;
<b>use</b> <Link to="vec_map#0x2_vec_map">0x2::vec_map</Link>;
<b>use</b> <Link to="vec_set#0x2_vec_set">0x2::vec_set</Link>;
</code></pre>



<Link id="0x2_token_Token"></Link>

## Resource `Token`

A single <code>
<Link to="token#0x2_token_Token">Token</Link></code> with <code>
Balance</code> inside. Can only be owned by an address,
and actions performed on it must be confirmed in a matching <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link to="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link to="balance#0x2_balance">balance</Link>: <Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;</code>
</dt>
<dd>
 The Balance of the <code>
<Link to="token#0x2_token_Token">Token</Link></code>.
</dd>
</dl>


</details>

<Link id="0x2_token_TokenPolicyCap"></Link>

## Resource `TokenPolicyCap`

A Capability that manages a single <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> specified in the <code>
for</code>
field. Created together with <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> in the <code>
new</code> function.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt; <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link to="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
for: <Link to="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_token_TokenPolicy"></Link>

## Resource `TokenPolicy`

<code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> represents a set of rules that define what actions can be
performed on a <code>
<Link to="token#0x2_token_Token">Token</Link></code> and which <code>
Rules</code> must be satisfied for the
action to succeed.

- For the sake of availability, <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> is a <code>
key</code>-only object.
- Each <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> is managed by a matching <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code>.
- For an action to become available, there needs to be a record in the
<code>
rules</code> VecMap. To allow an action to be performed freely, there's an
<code>
allow</code> function that can be called by the <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> owner.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link to="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
spent_balance: <Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;</code>
</dt>
<dd>
 The balance that is effectively spent by the user on the "spend"
 action. However, actual decrease of the supply can only be done by
 the <code>
TreasuryCap</code> owner when <code>
flush</code> is called.

 This balance is effectively spent and cannot be accessed by anyone
 but the <code>
TreasuryCap</code> owner.
</dd>
<dt>
<code>
rules: <Link to="vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;&gt;</code>
</dt>
<dd>
 The set of rules that define what actions can be performed on the
 token. For each "action" there's a set of Rules that must be
 satisfied for the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> to be confirmed.
</dd>
</dl>


</details>

<Link id="0x2_token_ActionRequest"></Link>

## Struct `ActionRequest`

A request to perform an "Action" on a token. Stores the information
about the action to be performed and must be consumed by the <code>
confirm_request</code>
or <code>
confirm_request_mut</code> functions when the Rules are satisfied.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
name: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link></code>
</dt>
<dd>
 Name of the Action to look up in the Policy. Name can be one of the
 default actions: <code>
<Link to="transfer#0x2_transfer">transfer</Link></code>, <code>
spend</code>, <code>
to_coin</code>, <code>
from_coin</code> or a
 custom action.
</dd>
<dt>
<code>
amount: u64</code>
</dt>
<dd>
 Amount is present in all of the txs
</dd>
<dt>
<code>
sender: <b>address</b></code>
</dt>
<dd>
 Sender is a permanent field always
</dd>
<dt>
<code>
recipient: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;</code>
</dt>
<dd>
 Recipient is only available in <code>
<Link to="transfer#0x2_transfer">transfer</Link></code> action.
</dd>
<dt>
<code>
spent_balance: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;&gt;</code>
</dt>
<dd>
 The balance to be "spent" in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>, only available
 in the <code>
spend</code> action.
</dd>
<dt>
<code>
approvals: <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;</code>
</dt>
<dd>
 Collected approvals (stamps) from completed <code>
Rules</code>. They're matched
 against <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.rules</code> to determine if the request can be
 confirmed.
</dd>
</dl>


</details>

<Link id="0x2_token_RuleKey"></Link>

## Struct `RuleKey`

Dynamic field key for the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> to store the <code>
Config</code> for a
specific action <code>
Rule</code>. There can be only one configuration per
<code>
Rule</code> per <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;T&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
is_protected: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_token_TokenPolicyCreated"></Link>

## Struct `TokenPolicyCreated`

An event emitted when a <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> is created and shared. Because
<code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> can only be shared (and potentially frozen in the future),
we emit this event in the <code>
share_policy</code> function and mark it as mutable.


<pre><code>
<b>struct</b> <Link to="token#0x2_token_TokenPolicyCreated">TokenPolicyCreated</Link>&lt;T&gt; <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link to="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 ID of the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> that was created.
</dd>
<dt>
<code>
is_mutable: bool</code>
</dt>
<dd>
 Whether the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> is "shared" (mutable) or "frozen"
 (immutable) - TBD.
</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x2_token_ENotAuthorized"></Link>

Trying to perform an admin action with a wrong cap.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>: u64 = 2;
</code></pre>



<Link id="0x2_token_EBalanceTooLow"></Link>

The balance is too low to perform the action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_EBalanceTooLow">EBalanceTooLow</Link>: u64 = 3;
</code></pre>



<Link id="0x2_token_ECantConsumeBalance"></Link>

The balance is not zero when trying to confirm with <code>
TransferPolicyCap</code>.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ECantConsumeBalance">ECantConsumeBalance</Link>: u64 = 5;
</code></pre>



<Link id="0x2_token_ENoConfig"></Link>

Rule is trying to access a missing config (with type).


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>: u64 = 6;
</code></pre>



<Link id="0x2_token_ENotApproved"></Link>

The rule was not approved.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENotApproved">ENotApproved</Link>: u64 = 1;
</code></pre>



<Link id="0x2_token_ENotZero"></Link>

The balance is not zero.


<pre><code>
<b>const</b> <Link to="token#0x2_token_ENotZero">ENotZero</Link>: u64 = 4;
</code></pre>



<Link id="0x2_token_EUnknownAction"></Link>

The action is not allowed (defined) in the policy.


<pre><code>
<b>const</b> <Link to="token#0x2_token_EUnknownAction">EUnknownAction</Link>: u64 = 0;
</code></pre>



<Link id="0x2_token_EUseImmutableConfirm"></Link>

Using <code>
confirm_request_mut</code> without <code>
spent_balance</code>. Immutable version
of the function must be used instead.


<pre><code>
<b>const</b> <Link to="token#0x2_token_EUseImmutableConfirm">EUseImmutableConfirm</Link>: u64 = 7;
</code></pre>



<Link id="0x2_token_FROM_COIN"></Link>

A Tag for the <code>
from_coin</code> action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_FROM_COIN">FROM_COIN</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [102, 114, 111, 109, 95, 99, 111, 105, 110];
</code></pre>



<Link id="0x2_token_SPEND"></Link>

A Tag for the <code>
spend</code> action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_SPEND">SPEND</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [115, 112, 101, 110, 100];
</code></pre>



<Link id="0x2_token_TO_COIN"></Link>

A Tag for the <code>
to_coin</code> action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_TO_COIN">TO_COIN</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [116, 111, 95, 99, 111, 105, 110];
</code></pre>



<Link id="0x2_token_TRANSFER"></Link>

A Tag for the <code>
<Link to="transfer#0x2_transfer">transfer</Link></code> action.


<pre><code>
<b>const</b> <Link to="token#0x2_token_TRANSFER">TRANSFER</Link>: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; = [116, 114, 97, 110, 115, 102, 101, 114];
</code></pre>



<Link id="0x2_token_new_policy"></Link>

## Function `new_policy`

Create a new <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> and a matching <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code>.
The <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> must then be shared using the <code>
share_policy</code> method.

<code>
TreasuryCap</code> guarantees full ownership over the currency, and is unique,
hence it is safe to use it for authorization.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_policy">new_policy</Link>&lt;T&gt;(_treasury_cap: &<Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, <Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_policy">new_policy</Link>&lt;T&gt;(
    _treasury_cap: &TreasuryCap&lt;T&gt;, ctx: &<b>mut</b> TxContext
): (<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, <Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;) \{
    <b>let</b> policy = <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        spent_balance: <Link to="balance#0x2_balance_zero">balance::zero</Link>(),
        rules: <Link to="vec_map#0x2_vec_map_empty">vec_map::empty</Link>()
    };

    <b>let</b> cap = <Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        `for`: <Link to="object#0x2_object_id">object::id</Link>(&policy)
    };

    (policy, cap)
}
</code></pre>



</details>

<Link id="0x2_token_share_policy"></Link>

## Function `share_policy`

Share the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>. Due to <code>
key</code>-only restriction, it must be
shared after initialization.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_share_policy">share_policy</Link>&lt;T&gt;(policy: <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_share_policy">share_policy</Link>&lt;T&gt;(policy: <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;) \{
    <Link to="event#0x2_event_emit">event::emit</Link>(<Link to="token#0x2_token_TokenPolicyCreated">TokenPolicyCreated</Link>&lt;T&gt; \{
        id: <Link to="object#0x2_object_id">object::id</Link>(&policy),
        is_mutable: <b>true</b>,
    });

    <Link to="transfer#0x2_transfer_share_object">transfer::share_object</Link>(policy)
}
</code></pre>



</details>

<Link id="0x2_token_transfer"></Link>

## Function `transfer`

Transfer a <code>
<Link to="token#0x2_token_Token">Token</Link></code> to a <code>
recipient</code>. Creates an <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> for the
"transfer" action. The <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> contains the <code>
recipient</code> field
to be used in verification.


<pre><code>
<b>public</b> <b>fun</b> <Link to="transfer#0x2_transfer">transfer</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, recipient: <b>address</b>, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="transfer#0x2_transfer">transfer</Link>&lt;T&gt;(
    t: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, recipient: <b>address</b>, ctx: &<b>mut</b> TxContext
): <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt; \{
    <b>let</b> amount = t.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>();
    <Link to="transfer#0x2_transfer_transfer">transfer::transfer</Link>(t, recipient);

    <Link to="token#0x2_token_new_request">new_request</Link>(
        <Link to="token#0x2_token_transfer_action">transfer_action</Link>(),
        amount,
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(recipient),
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
        ctx
    )
}
</code></pre>



</details>

<Link id="0x2_token_spend"></Link>

## Function `spend`

Spend a <code>
<Link to="token#0x2_token_Token">Token</Link></code> by unwrapping it and storing the <code>
Balance</code> in the
<code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> for the "spend" action. The <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> contains
the <code>
spent_balance</code> field to be used in verification.

Spend action requires <code>
confirm_request_mut</code> to be called to confirm the
request and join the spent balance with the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.spent_balance</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend">spend</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend">spend</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, ctx: &<b>mut</b> TxContext): <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt; \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = t;
    id.delete();

    <Link to="token#0x2_token_new_request">new_request</Link>(
        <Link to="token#0x2_token_spend_action">spend_action</Link>(),
        <Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>(),
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(<Link to="balance#0x2_balance">balance</Link>),
        ctx
    )
}
</code></pre>



</details>

<Link id="0x2_token_to_coin"></Link>

## Function `to_coin`

Convert <code>
<Link to="token#0x2_token_Token">Token</Link></code> into an open <code>
Coin</code>. Creates an <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> for the
"to_coin" action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin">to_coin</Link>&lt;T&gt;(t: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="coin#0x2_coin_Coin">coin::Coin</Link>&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin">to_coin</Link>&lt;T&gt;(
    t: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, ctx: &<b>mut</b> TxContext
): (Coin&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = t;
    <b>let</b> amount = <Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>();
    id.delete();

    (
        <Link to="balance#0x2_balance">balance</Link>.into_coin(ctx),
        <Link to="token#0x2_token_new_request">new_request</Link>(
            <Link to="token#0x2_token_to_coin_action">to_coin_action</Link>(),
            amount,
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            ctx
        )
    )
}
</code></pre>



</details>

<Link id="0x2_token_from_coin"></Link>

## Function `from_coin`

Convert an open <code>
Coin</code> into a <code>
<Link to="token#0x2_token_Token">Token</Link></code>. Creates an <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> for
the "from_coin" action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin">from_coin</Link>&lt;T&gt;(<Link to="coin#0x2_coin">coin</Link>: <Link to="coin#0x2_coin_Coin">coin::Coin</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin">from_coin</Link>&lt;T&gt;(
    <Link to="coin#0x2_coin">coin</Link>: Coin&lt;T&gt;, ctx: &<b>mut</b> TxContext
): (<Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;) \{
    <b>let</b> amount = <Link to="coin#0x2_coin">coin</Link>.<Link to="token#0x2_token_value">value</Link>();
    <b>let</b> <Link to="token#0x2_token">token</Link> = <Link to="token#0x2_token_Token">Token</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        <Link to="balance#0x2_balance">balance</Link>: <Link to="coin#0x2_coin">coin</Link>.into_balance()
    };

    (
        <Link to="token#0x2_token">token</Link>,
        <Link to="token#0x2_token_new_request">new_request</Link>(
            <Link to="token#0x2_token_from_coin_action">from_coin_action</Link>(),
            amount,
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>(),
            ctx
        )
    )
}
</code></pre>



</details>

<Link id="0x2_token_join"></Link>

## Function `join`

Join two <code>
<Link to="token#0x2_token_Token">Token</Link></code>s into one, always available.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_join">join</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, another: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_join">join</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, another: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = another;
    <Link to="token#0x2_token">token</Link>.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_join">join</Link>(<Link to="balance#0x2_balance">balance</Link>);
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_token_split"></Link>

## Function `split`

Split a <code>
<Link to="token#0x2_token_Token">Token</Link></code> with <code>
amount</code>.
Aborts if the <code>
<Link to="token#0x2_token_Token">Token</Link>.<Link to="balance#0x2_balance">balance</Link></code> is lower than <code>
amount</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_split">split</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, amount: u64, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_split">split</Link>&lt;T&gt;(
    <Link to="token#0x2_token">token</Link>: &<b>mut</b> <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, amount: u64, ctx: &<b>mut</b> TxContext
): <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; \{
    <b>assert</b>!(<Link to="token#0x2_token">token</Link>.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>() &gt;= amount, <Link to="token#0x2_token_EBalanceTooLow">EBalanceTooLow</Link>);
    <Link to="token#0x2_token_Token">Token</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        <Link to="balance#0x2_balance">balance</Link>: <Link to="token#0x2_token">token</Link>.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_split">split</Link>(amount),
    }
}
</code></pre>



</details>

<Link id="0x2_token_zero"></Link>

## Function `zero`

Create a zero <code>
<Link to="token#0x2_token_Token">Token</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_zero">zero</Link>&lt;T&gt;(ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_zero">zero</Link>&lt;T&gt;(ctx: &<b>mut</b> TxContext): <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; \{
    <Link to="token#0x2_token_Token">Token</Link> \{
        id: <Link to="object#0x2_object_new">object::new</Link>(ctx),
        <Link to="balance#0x2_balance">balance</Link>: <Link to="balance#0x2_balance_zero">balance::zero</Link>(),
    }
}
</code></pre>



</details>

<Link id="0x2_token_destroy_zero"></Link>

## Function `destroy_zero`

Destroy an empty <code>
<Link to="token#0x2_token_Token">Token</Link></code>, fails if the balance is non-zero.
Aborts if the <code>
<Link to="token#0x2_token_Token">Token</Link>.<Link to="balance#0x2_balance">balance</Link></code> is not zero.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_destroy_zero">destroy_zero</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_destroy_zero">destroy_zero</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = <Link to="token#0x2_token">token</Link>;
    <b>assert</b>!(<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>() == 0, <Link to="token#0x2_token_ENotZero">ENotZero</Link>);
    <Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_destroy_zero">destroy_zero</Link>();
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_token_keep"></Link>

## Function `keep`

Transfer the <code>
<Link to="token#0x2_token_Token">Token</Link></code> to the transaction sender.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_keep">keep</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_keep">keep</Link>&lt;T&gt;(<Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;, ctx: &<b>mut</b> TxContext) \{
    <Link to="transfer#0x2_transfer_transfer">transfer::transfer</Link>(<Link to="token#0x2_token">token</Link>, ctx.<Link to="token#0x2_token_sender">sender</Link>())
}
</code></pre>



</details>

<Link id="0x2_token_new_request"></Link>

## Function `new_request`

Create a new <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.
Publicly available method to allow for custom actions.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_request">new_request</Link>&lt;T&gt;(name: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, amount: u64, recipient: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;, spent_balance: <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<Link to="balance#0x2_balance_Balance">balance::Balance</Link>&lt;T&gt;&gt;, ctx: &<Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_new_request">new_request</Link>&lt;T&gt;(
    name: String,
    amount: u64,
    recipient: Option&lt;<b>address</b>&gt;,
    spent_balance: Option&lt;Balance&lt;T&gt;&gt;,
    ctx: &TxContext
): <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt; \{
    <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name,
        amount,
        recipient,
        spent_balance,
        sender: ctx.<Link to="token#0x2_token_sender">sender</Link>(),
        approvals: <Link to="vec_set#0x2_vec_set_empty">vec_set::empty</Link>(),
    }
}
</code></pre>



</details>

<Link id="0x2_token_confirm_request"></Link>

## Function `confirm_request`

Confirm the request against the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> and return the parameters
of the request: (Name, Amount, Sender, Recipient).

Cannot be used for <code>
spend</code> and similar actions that deliver <code>
spent_balance</code>
to the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>. For those actions use <code>
confirm_request_mut</code>.

Aborts if:
- the action is not allowed (missing record in <code>
rules</code>)
- action contains <code>
spent_balance</code> (use <code>
confirm_request_mut</code>)
- the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> does not meet the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> rules for the action


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request">confirm_request</Link>&lt;T&gt;(policy: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request">confirm_request</Link>&lt;T&gt;(
    policy: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>assert</b>!(request.spent_balance.is_none(), <Link to="token#0x2_token_ECantConsumeBalance">ECantConsumeBalance</Link>);
    <b>assert</b>!(policy.rules.contains(&request.name), <Link to="token#0x2_token_EUnknownAction">EUnknownAction</Link>);

    <b>let</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name, approvals,
        spent_balance,
        amount, sender, recipient,
    } = request;

    spent_balance.destroy_none();

    <b>let</b> rules = &(*policy.rules.get(&name)).into_keys();
    <b>let</b> rules_len = rules.length();
    <b>let</b> <b>mut</b> i = 0;

    <b>while</b> (i &lt; rules_len) \{
        <b>let</b> rule = &rules[i];
        <b>assert</b>!(approvals.contains(rule), <Link to="token#0x2_token_ENotApproved">ENotApproved</Link>);
        i = i + 1;
    };

    (name, amount, sender, recipient)
}
</code></pre>



</details>

<Link id="0x2_token_confirm_request_mut"></Link>

## Function `confirm_request_mut`

Confirm the request against the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> and return the parameters
of the request: (Name, Amount, Sender, Recipient).

Unlike <code>
confirm_request</code> this function requires mutable access to the
<code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> and must be used on <code>
spend</code> action. After dealing with the
spent balance it calls <code>
confirm_request</code> internally.

See <code>
confirm_request</code> for the list of abort conditions.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request_mut">confirm_request_mut</Link>&lt;T&gt;(policy: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_request_mut">confirm_request_mut</Link>&lt;T&gt;(
    policy: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    <b>mut</b> request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>assert</b>!(policy.rules.contains(&request.name), <Link to="token#0x2_token_EUnknownAction">EUnknownAction</Link>);
    <b>assert</b>!(request.spent_balance.is_some(), <Link to="token#0x2_token_EUseImmutableConfirm">EUseImmutableConfirm</Link>);

    policy.spent_balance.<Link to="token#0x2_token_join">join</Link>(request.spent_balance.extract());

    <Link to="token#0x2_token_confirm_request">confirm_request</Link>(policy, request, ctx)
}
</code></pre>



</details>

<Link id="0x2_token_confirm_with_policy_cap"></Link>

## Function `confirm_with_policy_cap`

Confirm an <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> as the <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> owner. This function
allows <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> owner to perform Capability-gated actions ignoring
the ruleset specified in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.

Aborts if request contains <code>
spent_balance</code> due to inability of the
<code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> to decrease supply. For scenarios like this a
<code>
TreasuryCap</code> is required (see <code>
confirm_with_treasury_cap</code>).


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_policy_cap">confirm_with_policy_cap</Link>&lt;T&gt;(_policy_cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_policy_cap">confirm_with_policy_cap</Link>&lt;T&gt;(
    _policy_cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>assert</b>!(request.spent_balance.is_none(), <Link to="token#0x2_token_ECantConsumeBalance">ECantConsumeBalance</Link>);

    <b>let</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name, amount, sender, recipient, approvals: _, spent_balance
    } = request;

    spent_balance.destroy_none();

    (name, amount, sender, recipient)
}
</code></pre>



</details>

<Link id="0x2_token_confirm_with_treasury_cap"></Link>

## Function `confirm_with_treasury_cap`

Confirm an <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> as the <code>
TreasuryCap</code> owner. This function
allows <code>
TreasuryCap</code> owner to perform Capability-gated actions ignoring
the ruleset specified in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.

Unlike <code>
confirm_with_policy_cap</code> this function allows <code>
spent_balance</code>
to be consumed, decreasing the <code>
total_supply</code> of the <code>
<Link to="token#0x2_token_Token">Token</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_treasury_cap">confirm_with_treasury_cap</Link>&lt;T&gt;(treasury_cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, request: <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, u64, <b>address</b>, <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_confirm_with_treasury_cap">confirm_with_treasury_cap</Link>&lt;T&gt;(
    treasury_cap: &<b>mut</b> TreasuryCap&lt;T&gt;,
    request: <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): (String, u64, <b>address</b>, Option&lt;<b>address</b>&gt;) \{
    <b>let</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link> \{
        name, amount, sender, recipient, approvals: _,
        spent_balance
    } = request;

    <b>if</b> (spent_balance.is_some()) \{
        treasury_cap.supply_mut().decrease_supply(spent_balance.destroy_some());
    } <b>else</b> \{
        spent_balance.destroy_none();
    };

    (name, amount, sender, recipient)
}
</code></pre>



</details>

<Link id="0x2_token_add_approval"></Link>

## Function `add_approval`

Add an "approval" to the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code> by providing a Witness.
Intended to be used by Rules to add their own approvals, however, can
be used to add arbitrary approvals to the request (not only the ones
required by the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>).


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_approval">add_approval</Link>&lt;T, W: drop&gt;(_t: W, request: &<b>mut</b> <Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_approval">add_approval</Link>&lt;T, W: drop&gt;(
    _t: W, request: &<b>mut</b> <Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;, _ctx: &<b>mut</b> TxContext
) \{
    request.approvals.insert(<Link to="../move-stdlib/type_name#0x1_type_name_get">type_name::get</Link>&lt;W&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_add_rule_config"></Link>

## Function `add_rule_config`

Add a <code>
Config</code> for a <code>
Rule</code> in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>. Rule configuration is
independent from the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.rules</code> and needs to be managed by the
Rule itself. Configuration is stored per <code>
Rule</code> and not per <code>
Rule</code> per
<code>
Action</code> to allow reuse in different actions.

- Rule witness guarantees that the <code>
Config</code> is approved by the Rule.
- <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> guarantees that the <code>
Config</code> setup is initiated by
the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> owner.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_config">add_rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(_rule: Rule, self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, config: Config, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_config">add_rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(
    _rule: Rule,
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    config: Config,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    df::add(&<b>mut</b> self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;(), config)
}
</code></pre>



</details>

<Link id="0x2_token_rule_config"></Link>

## Function `rule_config`

Get a <code>
Config</code> for a <code>
Rule</code> in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>. Requires <code>
Rule</code>
witness, hence can only be read by the <code>
Rule</code> itself. This requirement
guarantees safety of the stored <code>
Config</code> and allows for simpler dynamic
field management inside the Rule Config (custom type keys are not needed
for access gating).

Aborts if the Config is not present.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config">rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(_rule: Rule, self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): &Config
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config">rule_config</Link>&lt;T, Rule: drop, Config: store&gt;(
    _rule: Rule, self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;
): &Config \{
    <b>assert</b>!(<Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config&gt;(self), <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>);
    df::borrow(&self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_rule_config_mut"></Link>

## Function `rule_config_mut`

Get mutable access to the <code>
Config</code> for a <code>
Rule</code> in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.
Requires <code>
Rule</code> witness, hence can only be read by the <code>
Rule</code> itself,
as well as <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> to guarantee that the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> owner
is the one who initiated the <code>
Config</code> modification.

Aborts if:
- the Config is not present
- <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> is not matching the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config_mut">rule_config_mut</Link>&lt;T, Rule: drop, Config: store&gt;(_rule: Rule, self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;): &<b>mut</b> Config
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rule_config_mut">rule_config_mut</Link>&lt;T, Rule: drop, Config: store&gt;(
    _rule: Rule, self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;
): &<b>mut</b> Config \{
    <b>assert</b>!(<Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config&gt;(self), <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>);
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    df::borrow_mut(&<b>mut</b> self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_remove_rule_config"></Link>

## Function `remove_rule_config`

Remove a <code>
Config</code> for a <code>
Rule</code> in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.
Unlike the <code>
add_rule_config</code>, this function does not require a <code>
Rule</code>
witness, hence can be performed by the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> owner on their own.

Rules need to make sure that the <code>
Config</code> is present when performing
verification of the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.

Aborts if:
- the Config is not present
- <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> is not matching the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_config">remove_rule_config</Link>&lt;T, Rule, Config: store&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): Config
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_config">remove_rule_config</Link>&lt;T, Rule, Config: store&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): Config \{
    <b>assert</b>!(<Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config&gt;(self), <Link to="token#0x2_token_ENoConfig">ENoConfig</Link>);
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    df::remove(&<b>mut</b> self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_has_rule_config"></Link>

## Function `has_rule_config`

Check if a config for a <code>
Rule</code> is set in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> without
checking the type of the <code>
Config</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config">has_rule_config</Link>&lt;T, Rule&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config">has_rule_config</Link>&lt;T, Rule&gt;(self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;): bool \{
    df::exists_&lt;<Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;Rule&gt;&gt;(&self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_has_rule_config_with_type"></Link>

## Function `has_rule_config_with_type`

Check if a <code>
Config</code> for a <code>
Rule</code> is set in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code> and that
it matches the type provided.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config: store&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_has_rule_config_with_type">has_rule_config_with_type</Link>&lt;T, Rule, Config: store&gt;(
    self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;
): bool \{
    df::exists_with_type&lt;<Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;Rule&gt;, Config&gt;(&self.id, <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_allow"></Link>

## Function `allow`

Allows an <code>
action</code> to be performed on the <code>
<Link to="token#0x2_token_Token">Token</Link></code> freely by adding an
empty set of <code>
Rules</code> for the <code>
action</code>.

Aborts if the <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> is not matching the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_allow">allow</Link>&lt;T&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_allow">allow</Link>&lt;T&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    self.rules.insert(action, <Link to="vec_set#0x2_vec_set_empty">vec_set::empty</Link>());
}
</code></pre>



</details>

<Link id="0x2_token_disallow"></Link>

## Function `disallow`

Completely disallows an <code>
action</code> on the <code>
<Link to="token#0x2_token_Token">Token</Link></code> by removing the record
from the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.rules</code>.

Aborts if the <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> is not matching the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_disallow">disallow</Link>&lt;T&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_disallow">disallow</Link>&lt;T&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    self.rules.remove(&action);
}
</code></pre>



</details>

<Link id="0x2_token_add_rule_for_action"></Link>

## Function `add_rule_for_action`

Adds a Rule for an action with <code>
name</code> in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.

Aborts if the <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> is not matching the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_for_action">add_rule_for_action</Link>&lt;T, Rule: drop&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_add_rule_for_action">add_rule_for_action</Link>&lt;T, Rule: drop&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);
    <b>if</b> (!self.rules.contains(&action)) \{
        <Link to="token#0x2_token_allow">allow</Link>(self, cap, action, ctx);
    };

    self.rules.get_mut(&action).insert(<Link to="../move-stdlib/type_name#0x1_type_name_get">type_name::get</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_remove_rule_for_action"></Link>

## Function `remove_rule_for_action`

Removes a rule for an action with <code>
name</code> in the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>. Returns
the config object to be handled by the sender (or a Rule itself).

Aborts if the <code>
<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link></code> is not matching the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_for_action">remove_rule_for_action</Link>&lt;T, Rule: drop&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<Link to="token#0x2_token_TokenPolicyCap">token::TokenPolicyCap</Link>&lt;T&gt;, action: <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_remove_rule_for_action">remove_rule_for_action</Link>&lt;T, Rule: drop&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<Link to="token#0x2_token_TokenPolicyCap">TokenPolicyCap</Link>&lt;T&gt;,
    action: String,
    _ctx: &<b>mut</b> TxContext
) \{
    <b>assert</b>!(<Link to="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link to="token#0x2_token_ENotAuthorized">ENotAuthorized</Link>);

    self.rules.get_mut(&action).remove(&<Link to="../move-stdlib/type_name#0x1_type_name_get">type_name::get</Link>&lt;Rule&gt;())
}
</code></pre>



</details>

<Link id="0x2_token_mint"></Link>

## Function `mint`

Mint a <code>
<Link to="token#0x2_token_Token">Token</Link></code> with a given <code>
amount</code> using the <code>
TreasuryCap</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_mint">mint</Link>&lt;T&gt;(cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, amount: u64, ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_mint">mint</Link>&lt;T&gt;(
    cap: &<b>mut</b> TreasuryCap&lt;T&gt;, amount: u64, ctx: &<b>mut</b> TxContext
): <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt; \{
    <b>let</b> <Link to="balance#0x2_balance">balance</Link> = cap.supply_mut().increase_supply(amount);
    <Link to="token#0x2_token_Token">Token</Link> \{ id: <Link to="object#0x2_object_new">object::new</Link>(ctx), <Link to="balance#0x2_balance">balance</Link> }
}
</code></pre>



</details>

<Link id="0x2_token_burn"></Link>

## Function `burn`

Burn a <code>
<Link to="token#0x2_token_Token">Token</Link></code> using the <code>
TreasuryCap</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_burn">burn</Link>&lt;T&gt;(cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, <Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_burn">burn</Link>&lt;T&gt;(cap: &<b>mut</b> TreasuryCap&lt;T&gt;, <Link to="token#0x2_token">token</Link>: <Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;) \{
    <b>let</b> <Link to="token#0x2_token_Token">Token</Link> \{ id, <Link to="balance#0x2_balance">balance</Link> } = <Link to="token#0x2_token">token</Link>;
    cap.supply_mut().decrease_supply(<Link to="balance#0x2_balance">balance</Link>);
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_token_flush"></Link>

## Function `flush`

Flush the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>.spent_balance</code> into the <code>
TreasuryCap</code>. This
action is only available to the <code>
TreasuryCap</code> owner.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_flush">flush</Link>&lt;T&gt;(self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, cap: &<b>mut</b> <Link to="coin#0x2_coin_TreasuryCap">coin::TreasuryCap</Link>&lt;T&gt;, _ctx: &<b>mut</b> <Link to="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_flush">flush</Link>&lt;T&gt;(
    self: &<b>mut</b> <Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;,
    cap: &<b>mut</b> TreasuryCap&lt;T&gt;,
    _ctx: &<b>mut</b> TxContext
): u64 \{
    <b>let</b> amount = self.spent_balance.<Link to="token#0x2_token_value">value</Link>();
    <b>let</b> <Link to="balance#0x2_balance">balance</Link> = self.spent_balance.<Link to="token#0x2_token_split">split</Link>(amount);
    cap.supply_mut().decrease_supply(<Link to="balance#0x2_balance">balance</Link>)
}
</code></pre>



</details>

<Link id="0x2_token_is_allowed"></Link>

## Function `is_allowed`

Check whether an action is present in the rules VecMap.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_is_allowed">is_allowed</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, action: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_is_allowed">is_allowed</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, action: &String): bool \{
    self.rules.contains(action)
}
</code></pre>



</details>

<Link id="0x2_token_rules"></Link>

## Function `rules`

Returns the rules required for a specific action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rules">rules</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;, action: &<Link to="../move-stdlib/string#0x1_string_String">string::String</Link>): <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_rules">rules</Link>&lt;T&gt;(
    self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;, action: &String
): VecSet&lt;TypeName&gt; \{
    *self.rules.get(action)
}
</code></pre>



</details>

<Link id="0x2_token_spent_balance"></Link>

## Function `spent_balance`

Returns the <code>
spent_balance</code> of the <code>
<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent_balance">spent_balance</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">token::TokenPolicy</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent_balance">spent_balance</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_TokenPolicy">TokenPolicy</Link>&lt;T&gt;): u64 \{
    self.spent_balance.<Link to="token#0x2_token_value">value</Link>()
}
</code></pre>



</details>

<Link id="0x2_token_value"></Link>

## Function `value`

Returns the <code>
<Link to="balance#0x2_balance">balance</Link></code> of the <code>
<Link to="token#0x2_token_Token">Token</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_value">value</Link>&lt;T&gt;(t: &<Link to="token#0x2_token_Token">token::Token</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_value">value</Link>&lt;T&gt;(t: &<Link to="token#0x2_token_Token">Token</Link>&lt;T&gt;): u64 \{
    t.<Link to="balance#0x2_balance">balance</Link>.<Link to="token#0x2_token_value">value</Link>()
}
</code></pre>



</details>

<Link id="0x2_token_transfer_action"></Link>

## Function `transfer_action`

Name of the Transfer action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_transfer_action">transfer_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_transfer_action">transfer_action</Link>(): String \{
    <b>let</b> transfer_str = <Link to="token#0x2_token_TRANSFER">TRANSFER</Link>;
    transfer_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_spend_action"></Link>

## Function `spend_action`

Name of the <code>
Spend</code> action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend_action">spend_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spend_action">spend_action</Link>(): String \{
    <b>let</b> spend_str = <Link to="token#0x2_token_SPEND">SPEND</Link>;
    spend_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_to_coin_action"></Link>

## Function `to_coin_action`

Name of the <code>
ToCoin</code> action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin_action">to_coin_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_to_coin_action">to_coin_action</Link>(): String \{
    <b>let</b> to_coin_str = <Link to="token#0x2_token_TO_COIN">TO_COIN</Link>;
    to_coin_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_from_coin_action"></Link>

## Function `from_coin_action`

Name of the <code>
FromCoin</code> action.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin_action">from_coin_action</Link>(): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_from_coin_action">from_coin_action</Link>(): String \{
    <b>let</b> from_coin_str = <Link to="token#0x2_token_FROM_COIN">FROM_COIN</Link>;
    from_coin_str.to_string()
}
</code></pre>



</details>

<Link id="0x2_token_action"></Link>

## Function `action`

The Action in the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_action">action</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="../move-stdlib/string#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_action">action</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): String \{ self.name }
</code></pre>



</details>

<Link id="0x2_token_amount"></Link>

## Function `amount`

Amount of the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_amount">amount</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_amount">amount</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): u64 \{ self.amount }
</code></pre>



</details>

<Link id="0x2_token_sender"></Link>

## Function `sender`

Sender of the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_sender">sender</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_sender">sender</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): <b>address</b> \{ self.sender }
</code></pre>



</details>

<Link id="0x2_token_recipient"></Link>

## Function `recipient`

Recipient of the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_recipient">recipient</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;<b>address</b>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_recipient">recipient</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): Option&lt;<b>address</b>&gt; \{
    self.recipient
}
</code></pre>



</details>

<Link id="0x2_token_approvals"></Link>

## Function `approvals`

Approvals of the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_approvals">approvals</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="vec_set#0x2_vec_set_VecSet">vec_set::VecSet</Link>&lt;<Link to="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_approvals">approvals</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): VecSet&lt;TypeName&gt; \{
    self.approvals
}
</code></pre>



</details>

<Link id="0x2_token_spent"></Link>

## Function `spent`

Burned balance of the <code>
<Link to="token#0x2_token_ActionRequest">ActionRequest</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent">spent</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">token::ActionRequest</Link>&lt;T&gt;): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="token#0x2_token_spent">spent</Link>&lt;T&gt;(self: &<Link to="token#0x2_token_ActionRequest">ActionRequest</Link>&lt;T&gt;): Option&lt;u64&gt; \{
    <b>if</b> (self.spent_balance.is_some()) \{
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(self.spent_balance.<Link to="borrow#0x2_borrow">borrow</Link>().<Link to="token#0x2_token_value">value</Link>())
    } <b>else</b> \{
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
    }
}
</code></pre>



</details>

<Link id="0x2_token_key"></Link>

## Function `key`

Create a new <code>
<Link to="token#0x2_token_RuleKey">RuleKey</Link></code> for a <code>
Rule</code>. The <code>
is_protected</code> field is kept
for potential future use, if Rules were to have a freely modifiable
storage as addition / replacement for the <code>
Config</code> system.

The goal of <code>
is_protected</code> is to potentially allow Rules store a mutable
version of their configuration and mutate state on user action.


<pre><code>
<b>fun</b> <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;(): <Link to="token#0x2_token_RuleKey">token::RuleKey</Link>&lt;Rule&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link to="token#0x2_token_key">key</Link>&lt;Rule&gt;(): <Link to="token#0x2_token_RuleKey">RuleKey</Link>&lt;Rule&gt; \{ <Link to="token#0x2_token_RuleKey">RuleKey</Link> \{ is_protected: <b>true</b> } }
</code></pre>



</details>
