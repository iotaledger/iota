---
title: Module `0x2::kiosk`
---
import Link from '@docusaurus/Link';

<Link id="0x2_kiosk"/>
Kiosk is a primitive for building safe, decentralized and trustless trading
experiences. It allows storing and trading any types of assets as long as
the creator of these assets implements a <code>
TransferPolicy</code> for them.


<Link id="@Principles_and_philosophy:_0"></Link>

#### Principles and philosophy:


- Kiosk provides guarantees of "true ownership"; - just like single owner
objects, assets stored in the Kiosk can only be managed by the Kiosk owner.
Only the owner can <code>
place</code>, <code>
take</code>, <code>
list</code>, perform any other actions on
assets in the Kiosk.

- Kiosk aims to be generic - allowing for a small set of default behaviors
and not imposing any restrictions on how the assets can be traded. The only
default scenario is a <code>
list</code> + <code>
purchase</code> flow; any other trading logic can
be implemented on top using the <code>
list_with_purchase_cap</code> (and a matching
<code>
purchase_with_cap</code>) flow.

- For every transaction happening with a third party a <code>
TransferRequest</code> is
created - this way creators are fully in control of the trading experience.


<Link id="@Asset_states_in_the_Kiosk:_1"></Link>

#### Asset states in the Kiosk:


- <code>
placed</code> -  An asset is <code>
place</code>d into the Kiosk and can be <code>
take</code>n out by
the Kiosk owner; it's freely tradable and modifiable via the <code>
borrow_mut</code>
and <code>
borrow_val</code> functions.

- <code>
locked</code> - Similar to <code>
placed</code> except that <code>
take</code> is disabled and the only
way to move the asset out of the Kiosk is to <code>
list</code> it or
<code>
list_with_purchase_cap</code> therefore performing a trade (isiotang a
<code>
TransferRequest</code>). The check on the <code>
lock</code> function makes sure that the
<code>
TransferPolicy</code> exists to not lock the item in a <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> forever.

- <code>
listed</code> - A <code>
place</code>d or a <code>
lock</code>ed item can be <code>
list</code>ed for a fixed price
allowing anyone to <code>
purchase</code> it from the Kiosk. While listed, an item can
not be taken or modified. However, an immutable borrow via <code>
<Link href="borrow#0x2_borrow">borrow</Link></code> call is
still available. The <code>
delist</code> function returns the asset to the previous
state.

- <code>
listed_exclusively</code> - An item is listed via the <code>
list_with_purchase_cap</code>
function (and a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> is created). While listed this way, an item
can not be <code>
delist</code>-ed unless a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> is returned. All actions
available at this item state require a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code>:

1. <code>
purchase_with_cap</code> - to purchase the item for a price equal or higher
than the <code>
min_price</code> set in the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code>.
2. <code>
return_purchase_cap</code> - to return the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> and return the asset
into the previous state.

When an item is listed exclusively it cannot be modified nor taken and
losing a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> would lock the item in the Kiosk forever. Therefore,
it is recommended to only use <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> functionality in trusted
applications and not use it for direct trading (eg sending to another
account).


<Link id="@Using_multiple_Transfer_Policies_for_different_'tracks':_2"></Link>

#### Using multiple Transfer Policies for different 'tracks':


Every <code>
purchase</code> or <code>
purchase_with_purchase_cap</code> creates a <code>
TransferRequest</code>
hot potato which must be resolved in a matching <code>
TransferPolicy</code> for the
transaction to pass. While the default scenario implies that there should be
a single <code>
TransferPolicy&lt;T&gt;</code> for <code>
T</code>; it is possible to have multiple, each
one having its own set of rules.


<Link id="@Examples:_3"></Link>

#### Examples:


- I create one <code>
TransferPolicy</code> with "Royalty Rule" for everyone
- I create a special <code>
TransferPolicy</code> for bearers of a "Club Membership"
object so they don't have to pay anything
- I create and wrap a <code>
TransferPolicy</code> so that players of my game can
transfer items between <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>s in game without any charge (and maybe not
even paying the price with a 0 IOTA PurchaseCap)

```
Kiosk -> (Item, TransferRequest)
... TransferRequest ------> Common Transfer Policy
... TransferRequest ------> In-game Wrapped Transfer Policy
... TransferRequest ------> Club Membership Transfer Policy
```

See <code>
<Link href="transfer_policy#0x2_transfer_policy">transfer_policy</Link></code> module for more details on how they function.


        -  [Principles and philosophy:](#@Principles_and_philosophy:_0)
        -  [Asset states in the Kiosk:](#@Asset_states_in_the_Kiosk:_1)
        -  [Using multiple Transfer Policies for different 'tracks':](#@Using_multiple_Transfer_Policies_for_different_'tracks':_2)
        -  [Examples:](#@Examples:_3)
-  [Resource `Kiosk`](#0x2_kiosk_Kiosk)
-  [Resource `KioskOwnerCap`](#0x2_kiosk_KioskOwnerCap)
-  [Resource `PurchaseCap`](#0x2_kiosk_PurchaseCap)
-  [Struct `Borrow`](#0x2_kiosk_Borrow)
-  [Struct `Item`](#0x2_kiosk_Item)
-  [Struct `Listing`](#0x2_kiosk_Listing)
-  [Struct `Lock`](#0x2_kiosk_Lock)
-  [Struct `ItemListed`](#0x2_kiosk_ItemListed)
-  [Struct `ItemPurchased`](#0x2_kiosk_ItemPurchased)
-  [Struct `ItemDelisted`](#0x2_kiosk_ItemDelisted)
-  [Constants](#@Constants_4)
-  [Function `default`](#0x2_kiosk_default)
-  [Function `new`](#0x2_kiosk_new)
-  [Function `close_and_withdraw`](#0x2_kiosk_close_and_withdraw)
-  [Function `set_owner`](#0x2_kiosk_set_owner)
-  [Function `set_owner_custom`](#0x2_kiosk_set_owner_custom)
-  [Function `place`](#0x2_kiosk_place)
-  [Function `lock`](#0x2_kiosk_lock)
-  [Function `take`](#0x2_kiosk_take)
-  [Function `list`](#0x2_kiosk_list)
-  [Function `place_and_list`](#0x2_kiosk_place_and_list)
-  [Function `delist`](#0x2_kiosk_delist)
-  [Function `purchase`](#0x2_kiosk_purchase)
-  [Function `list_with_purchase_cap`](#0x2_kiosk_list_with_purchase_cap)
-  [Function `purchase_with_cap`](#0x2_kiosk_purchase_with_cap)
-  [Function `return_purchase_cap`](#0x2_kiosk_return_purchase_cap)
-  [Function `withdraw`](#0x2_kiosk_withdraw)
-  [Function `lock_internal`](#0x2_kiosk_lock_internal)
-  [Function `place_internal`](#0x2_kiosk_place_internal)
-  [Function `uid_mut_internal`](#0x2_kiosk_uid_mut_internal)
-  [Function `has_item`](#0x2_kiosk_has_item)
-  [Function `has_item_with_type`](#0x2_kiosk_has_item_with_type)
-  [Function `is_locked`](#0x2_kiosk_is_locked)
-  [Function `is_listed`](#0x2_kiosk_is_listed)
-  [Function `is_listed_exclusively`](#0x2_kiosk_is_listed_exclusively)
-  [Function `has_access`](#0x2_kiosk_has_access)
-  [Function `uid_mut_as_owner`](#0x2_kiosk_uid_mut_as_owner)
-  [Function `set_allow_extensions`](#0x2_kiosk_set_allow_extensions)
-  [Function `uid`](#0x2_kiosk_uid)
-  [Function `uid_mut`](#0x2_kiosk_uid_mut)
-  [Function `owner`](#0x2_kiosk_owner)
-  [Function `item_count`](#0x2_kiosk_item_count)
-  [Function `profits_amount`](#0x2_kiosk_profits_amount)
-  [Function `profits_mut`](#0x2_kiosk_profits_mut)
-  [Function `borrow`](#0x2_kiosk_borrow)
-  [Function `borrow_mut`](#0x2_kiosk_borrow_mut)
-  [Function `borrow_val`](#0x2_kiosk_borrow_val)
-  [Function `return_val`](#0x2_kiosk_return_val)
-  [Function `kiosk_owner_cap_for`](#0x2_kiosk_kiosk_owner_cap_for)
-  [Function `purchase_cap_kiosk`](#0x2_kiosk_purchase_cap_kiosk)
-  [Function `purchase_cap_item`](#0x2_kiosk_purchase_cap_item)
-  [Function `purchase_cap_min_price`](#0x2_kiosk_purchase_cap_min_price)


<pre><code>
<b>use</b> <Link href="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link href="balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link href="coin#0x2_coin">0x2::coin</Link>;
<b>use</b> <Link href="dynamic_field#0x2_dynamic_field">0x2::dynamic_field</Link>;
<b>use</b> <Link href="dynamic_object_field#0x2_dynamic_object_field">0x2::dynamic_object_field</Link>;
<b>use</b> <Link href="event#0x2_event">0x2::event</Link>;
<b>use</b> <Link href="iota#0x2_iota">0x2::iota</Link>;
<b>use</b> <Link href="object#0x2_object">0x2::object</Link>;
<b>use</b> <Link href="transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link href="transfer_policy#0x2_transfer_policy">0x2::transfer_policy</Link>;
<b>use</b> <Link href="tx_context#0x2_tx_context">0x2::tx_context</Link>;
</code></pre>



<Link id="0x2_kiosk_Kiosk"></Link>

## Resource `Kiosk`

An object which allows selling collectibles within "kiosk" ecosystem.
By default gives the functionality to list an item openly - for anyone
to purchase providing the guarantees for creators that every transfer
needs to be approved via the <code>
TransferPolicy</code>.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link> <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
profits: <Link href="balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link href="iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>
 Balance of the Kiosk - all profits from sales go here.
</dd>
<dt>
<code>
owner: <b>address</b></code>
</dt>
<dd>
 Always point to <code>
sender</code> of the transaction.
 Can be changed by calling <code>
set_owner</code> with Cap.
</dd>
<dt>
<code>
item_count: u32</code>
</dt>
<dd>
 Number of items stored in a Kiosk. Used to allow unpacking
 an empty Kiosk if it was wrapped or has a single owner.
</dd>
<dt>
<code>
allow_extensions: bool</code>
</dt>
<dd>
 [DEPRECATED] Please, don't use the <code>
allow_extensions</code> and the matching
 <code>
set_allow_extensions</code> function - it is a legacy feature that is being
 replaced by the <code>
<Link href="kiosk_extension#0x2_kiosk_extension">kiosk_extension</Link></code> module and its Extensions API.

 Exposes <code>
uid_mut</code> publicly when set to <code>
<b>true</b></code>, set to <code>
<b>false</b></code> by default.
</dd>
</dl>


</details>

<Link id="0x2_kiosk_KioskOwnerCap"></Link>

## Resource `KioskOwnerCap`

A Capability granting the bearer a right to <code>
place</code> and <code>
take</code> items
from the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> as well as to <code>
list</code> them and <code>
list_with_purchase_cap</code>.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link> <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
for: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_PurchaseCap"></Link>

## Resource `PurchaseCap`

A capability which locks an item and gives a permission to
purchase it from a <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> for any price no less than <code>
min_price</code>.

Allows exclusive listing: only bearer of the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> can
purchase the asset. However, the capability should be used
carefully as losing it would lock the asset in the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.

The main application for the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> is building extensions
on top of the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T: store, key&gt; <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
kiosk_id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 ID of the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> the cap belongs to.
</dd>
<dt>
<code>
item_id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 ID of the listed item.
</dd>
<dt>
<code>
min_price: u64</code>
</dt>
<dd>
 Minimum price for which the item can be purchased.
</dd>
</dl>


</details>

<Link id="0x2_kiosk_Borrow"></Link>

## Struct `Borrow`

Hot potato to ensure an item was returned after being taken using
the <code>
borrow_val</code> call.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_Borrow">Borrow</Link>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
kiosk_id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
item_id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_Item"></Link>

## Struct `Item`

Dynamic field key for an item placed into the kiosk.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_Item">Item</Link> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_Listing"></Link>

## Struct `Listing`

Dynamic field key for an active offer to purchase the T. If an
item is listed without a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code>, exclusive is set to <code>
<b>false</b></code>.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
is_exclusive: bool</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_Lock"></Link>

## Struct `Lock`

Dynamic field key which marks that an item is locked in the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> and
can't be <code>
take</code>n. The item then can only be listed / sold via the PurchaseCap.
Lock is released on <code>
purchase</code>.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_Lock">Lock</Link> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_ItemListed"></Link>

## Struct `ItemListed`

Emitted when an item was listed by the safe owner. Can be used
to track available offers anywhere on the network; the event is
type-indexed which allows for searching for offers of a specific <code>
T</code>


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_ItemListed">ItemListed</Link>&lt;T: store, key&gt; <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
<Link href="kiosk#0x2_kiosk">kiosk</Link>: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_ItemPurchased"></Link>

## Struct `ItemPurchased`

Emitted when an item was purchased from the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>. Can be used
to track finalized sales across the network. The event is emitted
in both cases: when an item is purchased via the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> or
when it's purchased directly (via <code>
list</code> + <code>
purchase</code>).

The <code>
price</code> is also emitted and might differ from the <code>
price</code> set
in the <code>
<Link href="kiosk#0x2_kiosk_ItemListed">ItemListed</Link></code> event. This is because the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> only
sets a minimum price for the item, and the actual price is defined
by the trading module / extension.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_ItemPurchased">ItemPurchased</Link>&lt;T: store, key&gt; <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
<Link href="kiosk#0x2_kiosk">kiosk</Link>: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_kiosk_ItemDelisted"></Link>

## Struct `ItemDelisted`

Emitted when an item was delisted by the safe owner. Can be used
to close tracked offers.


<pre><code>
<b>struct</b> <Link href="kiosk#0x2_kiosk_ItemDelisted">ItemDelisted</Link>&lt;T: store, key&gt; <b>has</b> <b>copy</b>, drop
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
<Link href="kiosk#0x2_kiosk">kiosk</Link>: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
id: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_4"></Link>

## Constants


<Link id="0x2_kiosk_ENotEnough"></Link>

Trying to withdraw higher amount than stored.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_ENotEnough">ENotEnough</Link>: u64 = 2;
</code></pre>



<Link id="0x2_kiosk_ENotOwner"></Link>

Trying to withdraw profits and sender is not owner.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>: u64 = 0;
</code></pre>



<Link id="0x2_kiosk_EAlreadyListed"></Link>

Trying to exclusively list an already listed item.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EAlreadyListed">EAlreadyListed</Link>: u64 = 6;
</code></pre>



<Link id="0x2_kiosk_EIncorrectAmount"></Link>

Coin paid does not match the offer price.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EIncorrectAmount">EIncorrectAmount</Link>: u64 = 1;
</code></pre>



<Link id="0x2_kiosk_EItemIsListed"></Link>

Taking or mutably borrowing an item that is listed.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EItemIsListed">EItemIsListed</Link>: u64 = 9;
</code></pre>



<Link id="0x2_kiosk_EItemLocked"></Link>

Attempt to <code>
take</code> an item that is locked.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EItemLocked">EItemLocked</Link>: u64 = 8;
</code></pre>



<Link id="0x2_kiosk_EItemMismatch"></Link>

Item does not match <code>
<Link href="kiosk#0x2_kiosk_Borrow">Borrow</Link></code> in <code>
return_val</code>.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EItemMismatch">EItemMismatch</Link>: u64 = 10;
</code></pre>



<Link id="0x2_kiosk_EItemNotFound"></Link>

An is not found while trying to borrow.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>: u64 = 11;
</code></pre>



<Link id="0x2_kiosk_EListedExclusively"></Link>

Attempt to take an item that has a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> issued.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EListedExclusively">EListedExclusively</Link>: u64 = 4;
</code></pre>



<Link id="0x2_kiosk_ENotEmpty"></Link>

Trying to close a Kiosk and it has items in it.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_ENotEmpty">ENotEmpty</Link>: u64 = 3;
</code></pre>



<Link id="0x2_kiosk_ENotListed"></Link>

Delisting an item that is not listed.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_ENotListed">ENotListed</Link>: u64 = 12;
</code></pre>



<Link id="0x2_kiosk_EUidAccessNotAllowed"></Link>

Trying to call <code>
uid_mut</code> when <code>
allow_extensions</code> set to false.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EUidAccessNotAllowed">EUidAccessNotAllowed</Link>: u64 = 7;
</code></pre>



<Link id="0x2_kiosk_EWrongKiosk"></Link>

<code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> does not match the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.


<pre><code>
<b>const</b> <Link href="kiosk#0x2_kiosk_EWrongKiosk">EWrongKiosk</Link>: u64 = 5;
</code></pre>



<Link id="0x2_kiosk_default"></Link>

## Function `default`

Creates a new Kiosk in a default configuration: sender receives the
<code>
<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link></code> and becomes the Owner, the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> is shared.


<pre><code>
entry <b>fun</b> <Link href="kiosk#0x2_kiosk_default">default</Link>(ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
entry <b>fun</b> <Link href="kiosk#0x2_kiosk_default">default</Link>(ctx: &<b>mut</b> TxContext) \{
    <b>let</b> (<Link href="kiosk#0x2_kiosk">kiosk</Link>, cap) = <Link href="kiosk#0x2_kiosk_new">new</Link>(ctx);
    iota::transfer::transfer(cap, ctx.sender());
    iota::transfer::share_object(<Link href="kiosk#0x2_kiosk">kiosk</Link>);
}
</code></pre>



</details>

<Link id="0x2_kiosk_new"></Link>

## Function `new`

Creates a new <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> with a matching <code>
<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_new">new</Link>(ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, <Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_new">new</Link>(ctx: &<b>mut</b> TxContext): (<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, <Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>) \{
    <b>let</b> <Link href="kiosk#0x2_kiosk">kiosk</Link> = <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link> \{
        id: <Link href="object#0x2_object_new">object::new</Link>(ctx),
        profits: <Link href="balance#0x2_balance_zero">balance::zero</Link>(),
        owner: ctx.sender(),
        item_count: 0,
        allow_extensions: <b>false</b>
    };

    <b>let</b> cap = <Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link> \{
        id: <Link href="object#0x2_object_new">object::new</Link>(ctx),
        `for`: <Link href="object#0x2_object_id">object::id</Link>(&<Link href="kiosk#0x2_kiosk">kiosk</Link>)
    };

    (<Link href="kiosk#0x2_kiosk">kiosk</Link>, cap)
}
</code></pre>



</details>

<Link id="0x2_kiosk_close_and_withdraw"></Link>

## Function `close_and_withdraw`

Unpacks and destroys a Kiosk returning the profits (even if "0").
Can only be performed by the bearer of the <code>
<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link></code> in the
case where there's no items inside and a <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> is not shared.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_close_and_withdraw">close_and_withdraw</Link>(self: <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: <Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link href="iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_close_and_withdraw">close_and_withdraw</Link>(
    self: <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: <Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, ctx: &<b>mut</b> TxContext
): Coin&lt;IOTA&gt; \{
    <b>let</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link> \{ id, profits, owner: _, item_count, allow_extensions: _ } = self;
    <b>let</b> <Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link> \{ id: cap_id, `for` } = cap;

    <b>assert</b>!(id.to_inner() == `for`, <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(item_count == 0, <Link href="kiosk#0x2_kiosk_ENotEmpty">ENotEmpty</Link>);

    cap_id.delete();
    id.delete();

    profits.into_coin(ctx)
}
</code></pre>



</details>

<Link id="0x2_kiosk_set_owner"></Link>

## Function `set_owner`

Change the <code>
owner</code> field to the transaction sender.
The change is purely cosmetical and does not affect any of the
basic kiosk functions unless some logic for this is implemented
in a third party module.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_set_owner">set_owner</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, ctx: &<Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_set_owner">set_owner</Link>(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, ctx: &TxContext
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    self.owner = ctx.sender();
}
</code></pre>



</details>

<Link id="0x2_kiosk_set_owner_custom"></Link>

## Function `set_owner_custom`

Update the <code>
owner</code> field with a custom address. Can be used for
implementing a custom logic that relies on the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> owner.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_set_owner_custom">set_owner_custom</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, owner: <b>address</b>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_set_owner_custom">set_owner_custom</Link>(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, owner: <b>address</b>
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    self.owner = owner
}
</code></pre>



</details>

<Link id="0x2_kiosk_place"></Link>

## Function `place`

Place any object into a Kiosk.
Performs an authorization check to make sure only owner can do that.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_place">place</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, item: T)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_place">place</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, item: T
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    self.<Link href="kiosk#0x2_kiosk_place_internal">place_internal</Link>(item)
}
</code></pre>



</details>

<Link id="0x2_kiosk_lock"></Link>

## Function `lock`

Place an item to the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> and issue a <code>
<Link href="kiosk#0x2_kiosk_Lock">Lock</Link></code> for it. Once placed this
way, an item can only be listed either with a <code>
list</code> function or with a
<code>
list_with_purchase_cap</code>.

Requires policy for <code>
T</code> to make sure that there's an issued <code>
TransferPolicy</code>
and the item can be sold, otherwise the asset might be locked forever.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_lock">lock</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, _policy: &<Link href="transfer_policy#0x2_transfer_policy_TransferPolicy">transfer_policy::TransferPolicy</Link>&lt;T&gt;, item: T)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_lock">lock</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, _policy: &TransferPolicy&lt;T&gt;, item: T
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    self.<Link href="kiosk#0x2_kiosk_lock_internal">lock_internal</Link>(item)
}
</code></pre>



</details>

<Link id="0x2_kiosk_take"></Link>

## Function `take`

Take any object from the Kiosk.
Performs an authorization check to make sure only owner can do that.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_take">take</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_take">take</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID
): T \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_locked">is_locked</Link>(id), <Link href="kiosk#0x2_kiosk_EItemLocked">EItemLocked</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_listed_exclusively">is_listed_exclusively</Link>(id), <Link href="kiosk#0x2_kiosk_EListedExclusively">EListedExclusively</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item">has_item</Link>(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);

    self.item_count = self.item_count - 1;
    df::remove_if_exists&lt;<Link href="kiosk#0x2_kiosk_Listing">Listing</Link>, u64&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>false</b> });
    dof::remove(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_list"></Link>

## Function `list`

List the item by setting a price and making it available for purchase.
Performs an authorization check to make sure only owner can sell.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_list">list</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>, price: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_list">list</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID, price: u64
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item_with_type">has_item_with_type</Link>&lt;T&gt;(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_listed_exclusively">is_listed_exclusively</Link>(id), <Link href="kiosk#0x2_kiosk_EListedExclusively">EListedExclusively</Link>);

    df::add(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>false</b> }, price);
    <Link href="event#0x2_event_emit">event::emit</Link>(<Link href="kiosk#0x2_kiosk_ItemListed">ItemListed</Link>&lt;T&gt; \{ <Link href="kiosk#0x2_kiosk">kiosk</Link>: <Link href="object#0x2_object_id">object::id</Link>(self), id, price })
}
</code></pre>



</details>

<Link id="0x2_kiosk_place_and_list"></Link>

## Function `place_and_list`

Calls <code>
place</code> and <code>
list</code> together - simplifies the flow.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_place_and_list">place_and_list</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, item: T, price: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_place_and_list">place_and_list</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, item: T, price: u64
) \{
    <b>let</b> id = <Link href="object#0x2_object_id">object::id</Link>(&item);
    self.<Link href="kiosk#0x2_kiosk_place">place</Link>(cap, item);
    self.<Link href="kiosk#0x2_kiosk_list">list</Link>&lt;T&gt;(cap, id, price)
}
</code></pre>



</details>

<Link id="0x2_kiosk_delist"></Link>

## Function `delist`

Remove an existing listing from the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> and keep the item in the
user Kiosk. Can only be performed by the owner of the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_delist">delist</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_delist">delist</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item_with_type">has_item_with_type</Link>&lt;T&gt;(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_listed_exclusively">is_listed_exclusively</Link>(id), <Link href="kiosk#0x2_kiosk_EListedExclusively">EListedExclusively</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_is_listed">is_listed</Link>(id), <Link href="kiosk#0x2_kiosk_ENotListed">ENotListed</Link>);

    df::remove&lt;<Link href="kiosk#0x2_kiosk_Listing">Listing</Link>, u64&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>false</b> });
    <Link href="event#0x2_event_emit">event::emit</Link>(<Link href="kiosk#0x2_kiosk_ItemDelisted">ItemDelisted</Link>&lt;T&gt; \{ <Link href="kiosk#0x2_kiosk">kiosk</Link>: <Link href="object#0x2_object_id">object::id</Link>(self), id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_purchase"></Link>

## Function `purchase`

Make a trade: pay the owner of the item and request a Transfer to the <code>
target</code>
kiosk (to prevent item being taken by the approving party).

Received <code>
TransferRequest</code> needs to be handled by the publisher of the T,
if they have a method implemented that allows a trade, it is possible to
request their approval (by calling some function) so that the trade can be
finalized.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase">purchase</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>, payment: <Link href="coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link href="iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;): (T, <Link href="transfer_policy#0x2_transfer_policy_TransferRequest">transfer_policy::TransferRequest</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase">purchase</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, id: ID, payment: Coin&lt;IOTA&gt;
): (T, TransferRequest&lt;T&gt;) \{
    <b>let</b> price = df::remove&lt;<Link href="kiosk#0x2_kiosk_Listing">Listing</Link>, u64&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>false</b> });
    <b>let</b> inner = dof::remove&lt;<Link href="kiosk#0x2_kiosk_Item">Item</Link>, T&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id });

    self.item_count = self.item_count - 1;
    <b>assert</b>!(price == payment.value(), <Link href="kiosk#0x2_kiosk_EIncorrectAmount">EIncorrectAmount</Link>);
    df::remove_if_exists&lt;<Link href="kiosk#0x2_kiosk_Lock">Lock</Link>, bool&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Lock">Lock</Link> \{ id });
    <Link href="coin#0x2_coin_put">coin::put</Link>(&<b>mut</b> self.profits, payment);

    <Link href="event#0x2_event_emit">event::emit</Link>(<Link href="kiosk#0x2_kiosk_ItemPurchased">ItemPurchased</Link>&lt;T&gt; \{ <Link href="kiosk#0x2_kiosk">kiosk</Link>: <Link href="object#0x2_object_id">object::id</Link>(self), id, price });

    (inner, <Link href="transfer_policy#0x2_transfer_policy_new_request">transfer_policy::new_request</Link>(id, price, <Link href="object#0x2_object_id">object::id</Link>(self)))
}
</code></pre>



</details>

<Link id="0x2_kiosk_list_with_purchase_cap"></Link>

## Function `list_with_purchase_cap`

Creates a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> which gives the right to purchase an item
for any price equal or higher than the <code>
min_price</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_list_with_purchase_cap">list_with_purchase_cap</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>, min_price: u64, ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="kiosk#0x2_kiosk_PurchaseCap">kiosk::PurchaseCap</Link>&lt;T&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_list_with_purchase_cap">list_with_purchase_cap</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID, min_price: u64, ctx: &<b>mut</b> TxContext
): <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt; \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item_with_type">has_item_with_type</Link>&lt;T&gt;(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_listed">is_listed</Link>(id), <Link href="kiosk#0x2_kiosk_EAlreadyListed">EAlreadyListed</Link>);

    df::add(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>true</b> }, min_price);

    <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt; \{
        min_price,
        item_id: id,
        id: <Link href="object#0x2_object_new">object::new</Link>(ctx),
        kiosk_id: <Link href="object#0x2_object_id">object::id</Link>(self),
    }
}
</code></pre>



</details>

<Link id="0x2_kiosk_purchase_with_cap"></Link>

## Function `purchase_with_cap`

Unpack the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> and call <code>
purchase</code>. Sets the payment amount
as the price for the listing making sure it's no less than <code>
min_amount</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_with_cap">purchase_with_cap</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, purchase_cap: <Link href="kiosk#0x2_kiosk_PurchaseCap">kiosk::PurchaseCap</Link>&lt;T&gt;, payment: <Link href="coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link href="iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;): (T, <Link href="transfer_policy#0x2_transfer_policy_TransferRequest">transfer_policy::TransferRequest</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_with_cap">purchase_with_cap</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, purchase_cap: <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt;, payment: Coin&lt;IOTA&gt;
): (T, TransferRequest&lt;T&gt;) \{
    <b>let</b> <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link> \{ id, item_id, kiosk_id, min_price } = purchase_cap;
    id.delete();

    <b>let</b> id = item_id;
    <b>let</b> paid = payment.value();
    <b>assert</b>!(paid &gt;= min_price, <Link href="kiosk#0x2_kiosk_EIncorrectAmount">EIncorrectAmount</Link>);
    <b>assert</b>!(<Link href="object#0x2_object_id">object::id</Link>(self) == kiosk_id, <Link href="kiosk#0x2_kiosk_EWrongKiosk">EWrongKiosk</Link>);

    df::remove&lt;<Link href="kiosk#0x2_kiosk_Listing">Listing</Link>, u64&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>true</b> });

    <Link href="coin#0x2_coin_put">coin::put</Link>(&<b>mut</b> self.profits, payment);
    self.item_count = self.item_count - 1;
    df::remove_if_exists&lt;<Link href="kiosk#0x2_kiosk_Lock">Lock</Link>, bool&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Lock">Lock</Link> \{ id });
    <b>let</b> item = dof::remove&lt;<Link href="kiosk#0x2_kiosk_Item">Item</Link>, T&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id });

    (item, <Link href="transfer_policy#0x2_transfer_policy_new_request">transfer_policy::new_request</Link>(id, paid, <Link href="object#0x2_object_id">object::id</Link>(self)))
}
</code></pre>



</details>

<Link id="0x2_kiosk_return_purchase_cap"></Link>

## Function `return_purchase_cap`

Return the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> without making a purchase; remove an active offer and
allow the item for taking. Can only be returned to its <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>, aborts otherwise.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_return_purchase_cap">return_purchase_cap</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, purchase_cap: <Link href="kiosk#0x2_kiosk_PurchaseCap">kiosk::PurchaseCap</Link>&lt;T&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_return_purchase_cap">return_purchase_cap</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, purchase_cap: <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt;
) \{
    <b>let</b> <Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link> \{ id, item_id, kiosk_id, min_price: _ } = purchase_cap;

    <b>assert</b>!(<Link href="object#0x2_object_id">object::id</Link>(self) == kiosk_id, <Link href="kiosk#0x2_kiosk_EWrongKiosk">EWrongKiosk</Link>);
    df::remove&lt;<Link href="kiosk#0x2_kiosk_Listing">Listing</Link>, u64&gt;(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id: item_id, is_exclusive: <b>true</b> });
    id.delete()
}
</code></pre>



</details>

<Link id="0x2_kiosk_withdraw"></Link>

## Function `withdraw`

Withdraw profits from the Kiosk.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_withdraw">withdraw</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, amount: <Link href="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;, ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link href="iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_withdraw">withdraw</Link>(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, amount: Option&lt;u64&gt;, ctx: &<b>mut</b> TxContext
): Coin&lt;IOTA&gt; \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);

    <b>let</b> amount = <b>if</b> (amount.is_some()) \{
        <b>let</b> amt = amount.destroy_some();
        <b>assert</b>!(amt &lt;= self.profits.value(), <Link href="kiosk#0x2_kiosk_ENotEnough">ENotEnough</Link>);
        amt
    } <b>else</b> \{
        self.profits.value()
    };

    <Link href="coin#0x2_coin_take">coin::take</Link>(&<b>mut</b> self.profits, amount, ctx)
}
</code></pre>



</details>

<Link id="0x2_kiosk_lock_internal"></Link>

## Function `lock_internal`

Internal: "lock" an item disabling the <code>
take</code> action.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link href="kiosk#0x2_kiosk_lock_internal">lock_internal</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, item: T)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(<Link href="package#0x2_package">package</Link>) <b>fun</b> <Link href="kiosk#0x2_kiosk_lock_internal">lock_internal</Link>&lt;T: key + store&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, item: T) \{
    df::add(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Lock">Lock</Link> \{ id: <Link href="object#0x2_object_id">object::id</Link>(&item) }, <b>true</b>);
    self.<Link href="kiosk#0x2_kiosk_place_internal">place_internal</Link>(item)
}
</code></pre>



</details>

<Link id="0x2_kiosk_place_internal"></Link>

## Function `place_internal`

Internal: "place" an item to the Kiosk and increment the item count.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link href="kiosk#0x2_kiosk_place_internal">place_internal</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, item: T)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(<Link href="package#0x2_package">package</Link>) <b>fun</b> <Link href="kiosk#0x2_kiosk_place_internal">place_internal</Link>&lt;T: key + store&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, item: T) \{
    self.item_count = self.item_count + 1;
    dof::add(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id: <Link href="object#0x2_object_id">object::id</Link>(&item) }, item)
}
</code></pre>



</details>

<Link id="0x2_kiosk_uid_mut_internal"></Link>

## Function `uid_mut_internal`

Internal: get a mutable access to the UID.


<pre><code>
<b>public</b>(<b>friend</b>) <b>fun</b> <Link href="kiosk#0x2_kiosk_uid_mut_internal">uid_mut_internal</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>): &<b>mut</b> <Link href="object#0x2_object_UID">object::UID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b>(<Link href="package#0x2_package">package</Link>) <b>fun</b> <Link href="kiosk#0x2_kiosk_uid_mut_internal">uid_mut_internal</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>): &<b>mut</b> UID \{
    &<b>mut</b> self.id
}
</code></pre>



</details>

<Link id="0x2_kiosk_has_item"></Link>

## Function `has_item`

Check whether the <code>
item</code> is present in the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_has_item">has_item</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_has_item">has_item</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, id: ID): bool \{
    dof::exists_(&self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_has_item_with_type"></Link>

## Function `has_item_with_type`

Check whether the <code>
item</code> is present in the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> and has type T.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_has_item_with_type">has_item_with_type</Link>&lt;T: store, key&gt;(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_has_item_with_type">has_item_with_type</Link>&lt;T: key + store&gt;(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, id: ID): bool \{
    dof::exists_with_type&lt;<Link href="kiosk#0x2_kiosk_Item">Item</Link>, T&gt;(&self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_is_locked"></Link>

## Function `is_locked`

Check whether an item with the <code>
id</code> is locked in the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>. Meaning
that the only two actions that can be performed on it are <code>
list</code> and
<code>
list_with_purchase_cap</code>, it cannot be <code>
take</code>n out of the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_is_locked">is_locked</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_is_locked">is_locked</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, id: ID): bool \{
    df::exists_(&self.id, <Link href="kiosk#0x2_kiosk_Lock">Lock</Link> \{ id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_is_listed"></Link>

## Function `is_listed`

Check whether an <code>
item</code> is listed (exclusively or non exclusively).


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_is_listed">is_listed</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_is_listed">is_listed</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, id: ID): bool \{
    df::exists_(&self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>false</b> })
    || self.<Link href="kiosk#0x2_kiosk_is_listed_exclusively">is_listed_exclusively</Link>(id)
}
</code></pre>



</details>

<Link id="0x2_kiosk_is_listed_exclusively"></Link>

## Function `is_listed_exclusively`

Check whether there's a <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code> issued for an item.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_is_listed_exclusively">is_listed_exclusively</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_is_listed_exclusively">is_listed_exclusively</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, id: ID): bool \{
    df::exists_(&self.id, <Link href="kiosk#0x2_kiosk_Listing">Listing</Link> \{ id, is_exclusive: <b>true</b> })
}
</code></pre>



</details>

<Link id="0x2_kiosk_has_access"></Link>

## Function `has_access`

Check whether the <code>
<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link></code> matches the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>): bool \{
    <Link href="object#0x2_object_id">object::id</Link>(self) == cap.`for`
}
</code></pre>



</details>

<Link id="0x2_kiosk_uid_mut_as_owner"></Link>

## Function `uid_mut_as_owner`

Access the <code>
UID</code> using the <code>
<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_uid_mut_as_owner">uid_mut_as_owner</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>): &<b>mut</b> <Link href="object#0x2_object_UID">object::UID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_uid_mut_as_owner">uid_mut_as_owner</Link>(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>
): &<b>mut</b> UID \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    &<b>mut</b> self.id
}
</code></pre>



</details>

<Link id="0x2_kiosk_set_allow_extensions"></Link>

## Function `set_allow_extensions`

[DEPRECATED]
Allow or disallow <code>
uid</code> and <code>
uid_mut</code> access via the <code>
allow_extensions</code>
setting.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_set_allow_extensions">set_allow_extensions</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, allow_extensions: bool)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_set_allow_extensions">set_allow_extensions</Link>(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, allow_extensions: bool
) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    self.allow_extensions = allow_extensions;
}
</code></pre>



</details>

<Link id="0x2_kiosk_uid"></Link>

## Function `uid`

Get the immutable <code>
UID</code> for dynamic field access.
Always enabled.

Given the &UID can be used for reading keys and authorization,
its access


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_uid">uid</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>): &<Link href="object#0x2_object_UID">object::UID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_uid">uid</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>): &UID \{
    &self.id
}
</code></pre>



</details>

<Link id="0x2_kiosk_uid_mut"></Link>

## Function `uid_mut`

Get the mutable <code>
UID</code> for dynamic field access and extensions.
Aborts if <code>
allow_extensions</code> set to <code>
<b>false</b></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_uid_mut">uid_mut</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>): &<b>mut</b> <Link href="object#0x2_object_UID">object::UID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_uid_mut">uid_mut</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>): &<b>mut</b> UID \{
    <b>assert</b>!(self.allow_extensions, <Link href="kiosk#0x2_kiosk_EUidAccessNotAllowed">EUidAccessNotAllowed</Link>);
    &<b>mut</b> self.id
}
</code></pre>



</details>

<Link id="0x2_kiosk_owner"></Link>

## Function `owner`

Get the owner of the Kiosk.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_owner">owner</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_owner">owner</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>): <b>address</b> \{
    self.owner
}
</code></pre>



</details>

<Link id="0x2_kiosk_item_count"></Link>

## Function `item_count`

Get the number of items stored in a Kiosk.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_item_count">item_count</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>): u32
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_item_count">item_count</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>): u32 \{
    self.item_count
}
</code></pre>



</details>

<Link id="0x2_kiosk_profits_amount"></Link>

## Function `profits_amount`

Get the amount of profits collected by selling items.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_profits_amount">profits_amount</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_profits_amount">profits_amount</Link>(self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>): u64 \{
    self.profits.value()
}
</code></pre>



</details>

<Link id="0x2_kiosk_profits_mut"></Link>

## Function `profits_mut`

Get mutable access to <code>
profits</code> - owner only action.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_profits_mut">profits_mut</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>): &<b>mut</b> <Link href="balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link href="iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_profits_mut">profits_mut</Link>(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>): &<b>mut</b> Balance&lt;IOTA&gt; \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    &<b>mut</b> self.profits
}
</code></pre>



</details>

<Link id="0x2_kiosk_borrow"></Link>

## Function `borrow`

Immutably borrow an item from the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>. Any item can be <code>
<Link href="borrow#0x2_borrow">borrow</Link></code>ed
at any time.


<pre><code>
<b>public</b> <b>fun</b> <Link href="borrow#0x2_borrow">borrow</Link>&lt;T: store, key&gt;(self: &<Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): &T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="borrow#0x2_borrow">borrow</Link>&lt;T: key + store&gt;(
    self: &<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID
): &T \{
    <b>assert</b>!(<Link href="object#0x2_object_id">object::id</Link>(self) == cap.`for`, <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item">has_item</Link>(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);

    dof::borrow(&self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_borrow_mut"></Link>

## Function `borrow_mut`

Mutably borrow an item from the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>.
Item can be <code>
borrow_mut</code>ed only if it's not <code>
is_listed</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_borrow_mut">borrow_mut</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): &<b>mut</b> T
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_borrow_mut">borrow_mut</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID
): &<b>mut</b> T \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item">has_item</Link>(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_listed">is_listed</Link>(id), <Link href="kiosk#0x2_kiosk_EItemIsListed">EItemIsListed</Link>);

    dof::borrow_mut(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id })
}
</code></pre>



</details>

<Link id="0x2_kiosk_borrow_val"></Link>

## Function `borrow_val`

Take the item from the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code> with a guarantee that it will be returned.
Item can be <code>
borrow_val</code>-ed only if it's not <code>
is_listed</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_borrow_val">borrow_val</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>, id: <Link href="object#0x2_object_ID">object::ID</Link>): (T, <Link href="kiosk#0x2_kiosk_Borrow">kiosk::Borrow</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_borrow_val">borrow_val</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>, id: ID
): (T, <Link href="kiosk#0x2_kiosk_Borrow">Borrow</Link>) \{
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_access">has_access</Link>(cap), <Link href="kiosk#0x2_kiosk_ENotOwner">ENotOwner</Link>);
    <b>assert</b>!(self.<Link href="kiosk#0x2_kiosk_has_item">has_item</Link>(id), <Link href="kiosk#0x2_kiosk_EItemNotFound">EItemNotFound</Link>);
    <b>assert</b>!(!self.<Link href="kiosk#0x2_kiosk_is_listed">is_listed</Link>(id), <Link href="kiosk#0x2_kiosk_EItemIsListed">EItemIsListed</Link>);

    (
        dof::remove(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id }),
        <Link href="kiosk#0x2_kiosk_Borrow">Borrow</Link> \{ kiosk_id: <Link href="object#0x2_object_id">object::id</Link>(self), item_id: id }
    )
}
</code></pre>



</details>

<Link id="0x2_kiosk_return_val"></Link>

## Function `return_val`

Return the borrowed item to the <code>
<Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link></code>. This method cannot be avoided
if <code>
borrow_val</code> is used.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_return_val">return_val</Link>&lt;T: store, key&gt;(self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">kiosk::Kiosk</Link>, item: T, <Link href="borrow#0x2_borrow">borrow</Link>: <Link href="kiosk#0x2_kiosk_Borrow">kiosk::Borrow</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_return_val">return_val</Link>&lt;T: key + store&gt;(
    self: &<b>mut</b> <Link href="kiosk#0x2_kiosk_Kiosk">Kiosk</Link>, item: T, <Link href="borrow#0x2_borrow">borrow</Link>: <Link href="kiosk#0x2_kiosk_Borrow">Borrow</Link>
) \{
    <b>let</b> <Link href="kiosk#0x2_kiosk_Borrow">Borrow</Link> \{ kiosk_id, item_id } = <Link href="borrow#0x2_borrow">borrow</Link>;

    <b>assert</b>!(<Link href="object#0x2_object_id">object::id</Link>(self) == kiosk_id, <Link href="kiosk#0x2_kiosk_EWrongKiosk">EWrongKiosk</Link>);
    <b>assert</b>!(<Link href="object#0x2_object_id">object::id</Link>(&item) == item_id, <Link href="kiosk#0x2_kiosk_EItemMismatch">EItemMismatch</Link>);

    dof::add(&<b>mut</b> self.id, <Link href="kiosk#0x2_kiosk_Item">Item</Link> \{ id: item_id }, item);
}
</code></pre>



</details>

<Link id="0x2_kiosk_kiosk_owner_cap_for"></Link>

## Function `kiosk_owner_cap_for`

Get the <code>
for</code> field of the <code>
<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_kiosk_owner_cap_for">kiosk_owner_cap_for</Link>(cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">kiosk::KioskOwnerCap</Link>): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_kiosk_owner_cap_for">kiosk_owner_cap_for</Link>(cap: &<Link href="kiosk#0x2_kiosk_KioskOwnerCap">KioskOwnerCap</Link>): ID \{
    cap.`for`
}
</code></pre>



</details>

<Link id="0x2_kiosk_purchase_cap_kiosk"></Link>

## Function `purchase_cap_kiosk`

Get the <code>
kiosk_id</code> from the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_cap_kiosk">purchase_cap_kiosk</Link>&lt;T: store, key&gt;(self: &<Link href="kiosk#0x2_kiosk_PurchaseCap">kiosk::PurchaseCap</Link>&lt;T&gt;): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_cap_kiosk">purchase_cap_kiosk</Link>&lt;T: key + store&gt;(self: &<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt;): ID \{
    self.kiosk_id
}
</code></pre>



</details>

<Link id="0x2_kiosk_purchase_cap_item"></Link>

## Function `purchase_cap_item`

Get the <code>
Item_id</code> from the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_cap_item">purchase_cap_item</Link>&lt;T: store, key&gt;(self: &<Link href="kiosk#0x2_kiosk_PurchaseCap">kiosk::PurchaseCap</Link>&lt;T&gt;): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_cap_item">purchase_cap_item</Link>&lt;T: key + store&gt;(self: &<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt;): ID \{
    self.item_id
}
</code></pre>



</details>

<Link id="0x2_kiosk_purchase_cap_min_price"></Link>

## Function `purchase_cap_min_price`

Get the <code>
min_price</code> from the <code>
<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_cap_min_price">purchase_cap_min_price</Link>&lt;T: store, key&gt;(self: &<Link href="kiosk#0x2_kiosk_PurchaseCap">kiosk::PurchaseCap</Link>&lt;T&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="kiosk#0x2_kiosk_purchase_cap_min_price">purchase_cap_min_price</Link>&lt;T: key + store&gt;(self: &<Link href="kiosk#0x2_kiosk_PurchaseCap">PurchaseCap</Link>&lt;T&gt;): u64 \{
    self.min_price
}
</code></pre>



</details>
