---
title: Module `0x2::address`
---
import Link from '@docusaurus/Link';



-  [Constants](#@Constants_0)
-  [Function `to_u256`](#0x2_address_to_u256)
-  [Function `from_u256`](#0x2_address_from_u256)
-  [Function `from_bytes`](#0x2_address_from_bytes)
-  [Function `to_bytes`](#0x2_address_to_bytes)
-  [Function `to_ascii_string`](#0x2_address_to_ascii_string)
-  [Function `to_string`](#0x2_address_to_string)
-  [Function `from_ascii_bytes`](#0x2_address_from_ascii_bytes)
-  [Function `hex_char_value`](#0x2_address_hex_char_value)
-  [Function `length`](#0x2_address_length)
-  [Function `max`](#0x2_address_max)


<pre><code>
<b>use</b> <Link href="../move-stdlib/ascii.md#0x1_ascii">0x1::ascii</Link>;
<b>use</b> <Link href="../move-stdlib/bcs.md#0x1_bcs">0x1::bcs</Link>;
<b>use</b> <Link href="../move-stdlib/string.md#0x1_string">0x1::string</Link>;
<b>use</b> <Link href="../iota-framework/hex.md#0x2_hex">0x2::hex</Link>;
</code></pre>



<Link id="@Constants_0"></Link>

## Constants


<Link id="0x2_address_EAddressParseError"></Link>

Error from <code>
from_bytes</code> when it is supplied too many or too few bytes.


<pre><code>
<b>const</b> <Link href="../iota-framework/address.md#0x2_address_EAddressParseError">EAddressParseError</Link>: u64 = 0;
</code></pre>



<Link id="0x2_address_LENGTH"></Link>

The length of an address, in bytes


<pre><code>
<b>const</b> <Link href="../iota-framework/address.md#0x2_address_LENGTH">LENGTH</Link>: u64 = 32;
</code></pre>



<Link id="0x2_address_MAX"></Link>



<pre><code>
<b>const</b> <Link href="../iota-framework/address.md#0x2_address_MAX">MAX</Link>: u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
</code></pre>



<Link id="0x2_address_to_u256"></Link>

## Function `to_u256`

Convert <code>
a</code> into a u256 by interpreting <code>
a</code> as the bytes of a big-endian integer
(e.g., <code>
<Link href="../iota-framework/address.md#0x2_address_to_u256">to_u256</Link>(0x1) == 1</code>)


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_u256">to_u256</Link>(a: <b>address</b>): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_u256">to_u256</Link>(a: <b>address</b>): u256;
</code></pre>



</details>

<Link id="0x2_address_from_u256"></Link>

## Function `from_u256`

Convert <code>
n</code> into an address by encoding it as a big-endian integer (e.g., <code>
<Link href="../iota-framework/address.md#0x2_address_from_u256">from_u256</Link>(1) = @0x1</code>)
Aborts if <code>
n</code> > <code>
MAX_ADDRESS</code>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_from_u256">from_u256</Link>(n: u256): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_from_u256">from_u256</Link>(n: u256): <b>address</b>;
</code></pre>



</details>

<Link id="0x2_address_from_bytes"></Link>

## Function `from_bytes`

Convert <code>
bytes</code> into an address.
Aborts with <code>
<Link href="../iota-framework/address.md#0x2_address_EAddressParseError">EAddressParseError</Link></code> if the length of <code>
bytes</code> is not 32


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_from_bytes">from_bytes</Link>(bytes: <Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>native</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_from_bytes">from_bytes</Link>(bytes: <Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b>;
</code></pre>



</details>

<Link id="0x2_address_to_bytes"></Link>

## Function `to_bytes`

Convert <code>
a</code> into BCS-encoded bytes.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_bytes">to_bytes</Link>(a: <b>address</b>): <Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_bytes">to_bytes</Link>(a: <b>address</b>): <Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>&lt;u8&gt; \{
    <Link href="../move-stdlib/bcs.md#0x1_bcs_to_bytes">bcs::to_bytes</Link>(&a)
}
</code></pre>



</details>

<Link id="0x2_address_to_ascii_string"></Link>

## Function `to_ascii_string`

Convert <code>
a</code> to a hex-encoded ASCII string


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_ascii_string">to_ascii_string</Link>(a: <b>address</b>): <Link href="../move-stdlib/ascii.md#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_ascii_string">to_ascii_string</Link>(a: <b>address</b>): <Link href="../move-stdlib/ascii.md#0x1_ascii_String">ascii::String</Link> \{
    <Link href="../iota-framework/hex.md#0x2_hex_encode">hex::encode</Link>(<Link href="../iota-framework/address.md#0x2_address_to_bytes">to_bytes</Link>(a)).<Link href="../iota-framework/address.md#0x2_address_to_ascii_string">to_ascii_string</Link>()
}
</code></pre>



</details>

<Link id="0x2_address_to_string"></Link>

## Function `to_string`

Convert <code>
a</code> to a hex-encoded string


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_string">to_string</Link>(a: <b>address</b>): <Link href="../move-stdlib/string.md#0x1_string_String">string::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_to_string">to_string</Link>(a: <b>address</b>): <Link href="../move-stdlib/string.md#0x1_string_String">string::String</Link> \{
    <Link href="../iota-framework/address.md#0x2_address_to_ascii_string">to_ascii_string</Link>(a).<Link href="../iota-framework/address.md#0x2_address_to_string">to_string</Link>()
}
</code></pre>



</details>

<Link id="0x2_address_from_ascii_bytes"></Link>

## Function `from_ascii_bytes`

Converts an ASCII string to an address, taking the numerical value for each character. The
string must be Base16 encoded, and thus exactly 64 characters long.
For example, the string "00000000000000000000000000000000000000000000000000000000DEADB33F"
will be converted to the address @0xDEADB33F.
Aborts with <code>
<Link href="../iota-framework/address.md#0x2_address_EAddressParseError">EAddressParseError</Link></code> if the length of <code>
s</code> is not 64,
or if an invalid character is encountered.


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_from_ascii_bytes">from_ascii_bytes</Link>(bytes: &<Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_from_ascii_bytes">from_ascii_bytes</Link>(bytes: &<Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>&lt;u8&gt;): <b>address</b> \{
    <b>assert</b>!(bytes.<Link href="../iota-framework/address.md#0x2_address_length">length</Link>() == 64, <Link href="../iota-framework/address.md#0x2_address_EAddressParseError">EAddressParseError</Link>);
    <b>let</b> <b>mut</b> hex_bytes = <Link href="../move-stdlib/vector.md#0x1_vector">vector</Link>[];
    <b>let</b> <b>mut</b> i = 0;
    <b>while</b> (i &lt; 64) \{
        <b>let</b> hi = <Link href="../iota-framework/address.md#0x2_address_hex_char_value">hex_char_value</Link>(bytes[i]);
        <b>let</b> lo = <Link href="../iota-framework/address.md#0x2_address_hex_char_value">hex_char_value</Link>(bytes[i+1]);
        hex_bytes.push_back((hi &lt;&lt; 4) | lo);
        i = i + 2;
    };
    <Link href="../iota-framework/address.md#0x2_address_from_bytes">from_bytes</Link>(hex_bytes)
}
</code></pre>



</details>

<Link id="0x2_address_hex_char_value"></Link>

## Function `hex_char_value`



<pre><code>
<b>fun</b> <Link href="../iota-framework/address.md#0x2_address_hex_char_value">hex_char_value</Link>(c: u8): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="../iota-framework/address.md#0x2_address_hex_char_value">hex_char_value</Link>(c: u8): u8 \{
    <b>if</b> (c &gt;= 48 && c &lt;= 57) c - 48 // 0-9
    <b>else</b> <b>if</b> (c &gt;= 65 && c &lt;= 70) c - 55 // A-F
    <b>else</b> <b>if</b> (c &gt;= 97 && c &lt;= 102) c - 87 // a-f
    <b>else</b> <b>abort</b> <Link href="../iota-framework/address.md#0x2_address_EAddressParseError">EAddressParseError</Link>
}
</code></pre>



</details>

<Link id="0x2_address_length"></Link>

## Function `length`

Length of a Iota address in bytes


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_length">length</Link>(): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_length">length</Link>(): u64 \{
    <Link href="../iota-framework/address.md#0x2_address_LENGTH">LENGTH</Link>
}
</code></pre>



</details>

<Link id="0x2_address_max"></Link>

## Function `max`

Largest possible address


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_max">max</Link>(): u256
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="../iota-framework/address.md#0x2_address_max">max</Link>(): u256 \{
    <Link href="../iota-framework/address.md#0x2_address_MAX">MAX</Link>
}
</code></pre>



</details>
