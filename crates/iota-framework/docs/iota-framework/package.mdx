---
title: Module `0x2::package`
---
import Link from '@docusaurus/Link';

Functions for operating on Move packages from within Move:
- Creating proof-of-publish objects from one-time witnesses
- Administering package upgrades through upgrade policies.


-  [Resource `Publisher`](#0x2_package_Publisher)
-  [Resource `UpgradeCap`](#0x2_package_UpgradeCap)
-  [Struct `UpgradeTicket`](#0x2_package_UpgradeTicket)
-  [Struct `UpgradeReceipt`](#0x2_package_UpgradeReceipt)
-  [Constants](#@Constants_0)
-  [Function `claim`](#0x2_package_claim)
-  [Function `claim_and_keep`](#0x2_package_claim_and_keep)
-  [Function `burn_publisher`](#0x2_package_burn_publisher)
-  [Function `from_package`](#0x2_package_from_package)
-  [Function `from_module`](#0x2_package_from_module)
-  [Function `published_module`](#0x2_package_published_module)
-  [Function `published_package`](#0x2_package_published_package)
-  [Function `upgrade_package`](#0x2_package_upgrade_package)
-  [Function `version`](#0x2_package_version)
-  [Function `upgrade_policy`](#0x2_package_upgrade_policy)
-  [Function `ticket_package`](#0x2_package_ticket_package)
-  [Function `ticket_policy`](#0x2_package_ticket_policy)
-  [Function `receipt_cap`](#0x2_package_receipt_cap)
-  [Function `receipt_package`](#0x2_package_receipt_package)
-  [Function `ticket_digest`](#0x2_package_ticket_digest)
-  [Function `compatible_policy`](#0x2_package_compatible_policy)
-  [Function `additive_policy`](#0x2_package_additive_policy)
-  [Function `dep_only_policy`](#0x2_package_dep_only_policy)
-  [Function `only_additive_upgrades`](#0x2_package_only_additive_upgrades)
-  [Function `only_dep_upgrades`](#0x2_package_only_dep_upgrades)
-  [Function `make_immutable`](#0x2_package_make_immutable)
-  [Function `authorize_upgrade`](#0x2_package_authorize_upgrade)
-  [Function `commit_upgrade`](#0x2_package_commit_upgrade)
-  [Function `restrict`](#0x2_package_restrict)


<pre><code>
<b>use</b> <Link href="../move-stdlib/ascii#0x1_ascii">0x1::ascii</Link>;
<b>use</b> <Link href="../move-stdlib/type_name#0x1_type_name">0x1::type_name</Link>;
<b>use</b> <Link href="object#0x2_object">0x2::object</Link>;
<b>use</b> <Link href="transfer#0x2_transfer">0x2::transfer</Link>;
<b>use</b> <Link href="tx_context#0x2_tx_context">0x2::tx_context</Link>;
<b>use</b> <Link href="types#0x2_types">0x2::types</Link>;
</code></pre>



<Link id="0x2_package_Publisher"></Link>

## Resource `Publisher`

This type can only be created in the transaction that
generates a module, by consuming its one-time witness, so it
can be used to identify the address that published the package
a type originated from.


<pre><code>
<b>struct</b> <Link href="package#0x2_package_Publisher">Publisher</Link> <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link href="package#0x2_package">package</Link>: <Link href="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
module_name: <Link href="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link></code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_package_UpgradeCap"></Link>

## Resource `UpgradeCap`

Capability controlling the ability to upgrade a package.


<pre><code>
<b>struct</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link> <b>has</b> store, key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
<Link href="package#0x2_package">package</Link>: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 (Mutable) ID of the package that can be upgraded.
</dd>
<dt>
<code>
version: u64</code>
</dt>
<dd>
 (Mutable) The number of upgrades that have been applied
 successively to the original package.  Initially 0.
</dd>
<dt>
<code>
policy: u8</code>
</dt>
<dd>
 What kind of upgrades are allowed.
</dd>
</dl>


</details>

<Link id="0x2_package_UpgradeTicket"></Link>

## Struct `UpgradeTicket`

Permission to perform a particular upgrade (for a fixed version of
the package, bytecode to upgrade with and transitive dependencies to
depend against).

An <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> can only issue one ticket at a time, to prevent races
between concurrent updates or a change in its upgrade policy after
isiotang a ticket, so the ticket is a "Hot Potato" to preserve forward
progress.


<pre><code>
<b>struct</b> <Link href="package#0x2_package_UpgradeTicket">UpgradeTicket</Link>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
cap: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 (Immutable) ID of the <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> this originated from.
</dd>
<dt>
<code>
<Link href="package#0x2_package">package</Link>: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 (Immutable) ID of the package that can be upgraded.
</dd>
<dt>
<code>
policy: u8</code>
</dt>
<dd>
 (Immutable) The policy regarding what kind of upgrade this ticket
 permits.
</dd>
<dt>
<code>
digest: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;</code>
</dt>
<dd>
 (Immutable) SHA256 digest of the bytecode and transitive
 dependencies that will be used in the upgrade.
</dd>
</dl>


</details>

<Link id="0x2_package_UpgradeReceipt"></Link>

## Struct `UpgradeReceipt`

Issued as a result of a successful upgrade, containing the
information to be used to update the <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code>.  This is a "Hot
Potato" to ensure that it is used to update its <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> before
the end of the transaction that performed the upgrade.


<pre><code>
<b>struct</b> <Link href="package#0x2_package_UpgradeReceipt">UpgradeReceipt</Link>
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
cap: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 (Immutable) ID of the <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> this originated from.
</dd>
<dt>
<code>
<Link href="package#0x2_package">package</Link>: <Link href="object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 (Immutable) ID of the package after it was upgraded.
</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x2_package_ADDITIVE"></Link>

Add new functions or types, or change dependencies, existing
functions can't change.


<pre><code>
<b>const</b> <Link href="package#0x2_package_ADDITIVE">ADDITIVE</Link>: u8 = 128;
</code></pre>



<Link id="0x2_package_COMPATIBLE"></Link>

Update any part of the package (function implementations, add new
functions or types, change dependencies)


<pre><code>
<b>const</b> <Link href="package#0x2_package_COMPATIBLE">COMPATIBLE</Link>: u8 = 0;
</code></pre>



<Link id="0x2_package_DEP_ONLY"></Link>

Only be able to change dependencies.


<pre><code>
<b>const</b> <Link href="package#0x2_package_DEP_ONLY">DEP_ONLY</Link>: u8 = 192;
</code></pre>



<Link id="0x2_package_EAlreadyAuthorized"></Link>

This <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> has already authorized a pending upgrade.


<pre><code>
<b>const</b> <Link href="package#0x2_package_EAlreadyAuthorized">EAlreadyAuthorized</Link>: u64 = 2;
</code></pre>



<Link id="0x2_package_ENotAuthorized"></Link>

This <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> has not authorized an upgrade.


<pre><code>
<b>const</b> <Link href="package#0x2_package_ENotAuthorized">ENotAuthorized</Link>: u64 = 3;
</code></pre>



<Link id="0x2_package_ENotOneTimeWitness"></Link>

Tried to create a <code>
<Link href="package#0x2_package_Publisher">Publisher</Link></code> using a type that isn't a
one-time witness.


<pre><code>
<b>const</b> <Link href="package#0x2_package_ENotOneTimeWitness">ENotOneTimeWitness</Link>: u64 = 0;
</code></pre>



<Link id="0x2_package_ETooPermissive"></Link>

Tried to set a less restrictive policy than currently in place.


<pre><code>
<b>const</b> <Link href="package#0x2_package_ETooPermissive">ETooPermissive</Link>: u64 = 1;
</code></pre>



<Link id="0x2_package_EWrongUpgradeCap"></Link>

Trying to commit an upgrade to the wrong <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code>.


<pre><code>
<b>const</b> <Link href="package#0x2_package_EWrongUpgradeCap">EWrongUpgradeCap</Link>: u64 = 4;
</code></pre>



<Link id="0x2_package_claim"></Link>

## Function `claim`

Claim a Publisher object.
Requires a One-Time-Witness to prove ownership. Due to this
constraint there can be only one Publisher object per module
but multiple per package (!).


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_claim">claim</Link>&lt;OTW: drop&gt;(otw: OTW, ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="package#0x2_package_Publisher">package::Publisher</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_claim">claim</Link>&lt;OTW: drop&gt;(otw: OTW, ctx: &<b>mut</b> TxContext): <Link href="package#0x2_package_Publisher">Publisher</Link> \{
    <b>assert</b>!(<Link href="types#0x2_types_is_one_time_witness">types::is_one_time_witness</Link>(&otw), <Link href="package#0x2_package_ENotOneTimeWitness">ENotOneTimeWitness</Link>);

    <b>let</b> tyname = <Link href="../move-stdlib/type_name#0x1_type_name_get_with_original_ids">type_name::get_with_original_ids</Link>&lt;OTW&gt;();

    <Link href="package#0x2_package_Publisher">Publisher</Link> \{
        id: <Link href="object#0x2_object_new">object::new</Link>(ctx),
        <Link href="package#0x2_package">package</Link>: tyname.get_address(),
        module_name: tyname.get_module(),
    }
}
</code></pre>



</details>

<Link id="0x2_package_claim_and_keep"></Link>

## Function `claim_and_keep`

Claim a Publisher object and send it to transaction sender.
Since this function can only be called in the module initializer,
the sender is the publisher.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_claim_and_keep">claim_and_keep</Link>&lt;OTW: drop&gt;(otw: OTW, ctx: &<b>mut</b> <Link href="tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_claim_and_keep">claim_and_keep</Link>&lt;OTW: drop&gt;(otw: OTW, ctx: &<b>mut</b> TxContext) \{
    iota::transfer::public_transfer(<Link href="package#0x2_package_claim">claim</Link>(otw, ctx), ctx.sender())
}
</code></pre>



</details>

<Link id="0x2_package_burn_publisher"></Link>

## Function `burn_publisher`

Destroy a Publisher object effectively removing all privileges
associated with it.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_burn_publisher">burn_publisher</Link>(self: <Link href="package#0x2_package_Publisher">package::Publisher</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_burn_publisher">burn_publisher</Link>(self: <Link href="package#0x2_package_Publisher">Publisher</Link>) \{
    <b>let</b> <Link href="package#0x2_package_Publisher">Publisher</Link> \{ id, <Link href="package#0x2_package">package</Link>: _, module_name: _ } = self;
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_package_from_package"></Link>

## Function `from_package`

Check whether type belongs to the same package as the publisher object.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_from_package">from_package</Link>&lt;T&gt;(self: &<Link href="package#0x2_package_Publisher">package::Publisher</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_from_package">from_package</Link>&lt;T&gt;(self: &<Link href="package#0x2_package_Publisher">Publisher</Link>): bool \{
    <Link href="../move-stdlib/type_name#0x1_type_name_get_with_original_ids">type_name::get_with_original_ids</Link>&lt;T&gt;().get_address() == self.<Link href="package#0x2_package">package</Link>
}
</code></pre>



</details>

<Link id="0x2_package_from_module"></Link>

## Function `from_module`

Check whether a type belongs to the same module as the publisher object.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_from_module">from_module</Link>&lt;T&gt;(self: &<Link href="package#0x2_package_Publisher">package::Publisher</Link>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_from_module">from_module</Link>&lt;T&gt;(self: &<Link href="package#0x2_package_Publisher">Publisher</Link>): bool \{
    <b>let</b> tyname = <Link href="../move-stdlib/type_name#0x1_type_name_get_with_original_ids">type_name::get_with_original_ids</Link>&lt;T&gt;();

    (tyname.get_address() == self.<Link href="package#0x2_package">package</Link>) && (tyname.get_module() == self.module_name)
}
</code></pre>



</details>

<Link id="0x2_package_published_module"></Link>

## Function `published_module`

Read the name of the module.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_published_module">published_module</Link>(self: &<Link href="package#0x2_package_Publisher">package::Publisher</Link>): &<Link href="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_published_module">published_module</Link>(self: &<Link href="package#0x2_package_Publisher">Publisher</Link>): &String \{
    &self.module_name
}
</code></pre>



</details>

<Link id="0x2_package_published_package"></Link>

## Function `published_package`

Read the package address string.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_published_package">published_package</Link>(self: &<Link href="package#0x2_package_Publisher">package::Publisher</Link>): &<Link href="../move-stdlib/ascii#0x1_ascii_String">ascii::String</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_published_package">published_package</Link>(self: &<Link href="package#0x2_package_Publisher">Publisher</Link>): &String \{
    &self.<Link href="package#0x2_package">package</Link>
}
</code></pre>



</details>

<Link id="0x2_package_upgrade_package"></Link>

## Function `upgrade_package`

The ID of the package that this cap authorizes upgrades for.
Can be <code>
0x0</code> if the cap cannot currently authorize an upgrade
because there is already a pending upgrade in the transaction.
Otherwise guaranteed to be the latest version of any given
package.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_upgrade_package">upgrade_package</Link>(cap: &<Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_upgrade_package">upgrade_package</Link>(cap: &<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>): ID \{
    cap.<Link href="package#0x2_package">package</Link>
}
</code></pre>



</details>

<Link id="0x2_package_version"></Link>

## Function `version`

The most recent version of the package, increments by one for each
successfully applied upgrade.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_version">version</Link>(cap: &<Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_version">version</Link>(cap: &<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>): u64 \{
    cap.version
}
</code></pre>



</details>

<Link id="0x2_package_upgrade_policy"></Link>

## Function `upgrade_policy`

The most permissive kind of upgrade currently supported by this
<code>
cap</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_upgrade_policy">upgrade_policy</Link>(cap: &<Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_upgrade_policy">upgrade_policy</Link>(cap: &<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>): u8 \{
    cap.policy
}
</code></pre>



</details>

<Link id="0x2_package_ticket_package"></Link>

## Function `ticket_package`

The package that this ticket is authorized to upgrade


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_ticket_package">ticket_package</Link>(ticket: &<Link href="package#0x2_package_UpgradeTicket">package::UpgradeTicket</Link>): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_ticket_package">ticket_package</Link>(ticket: &<Link href="package#0x2_package_UpgradeTicket">UpgradeTicket</Link>): ID \{
    ticket.<Link href="package#0x2_package">package</Link>
}
</code></pre>



</details>

<Link id="0x2_package_ticket_policy"></Link>

## Function `ticket_policy`

The kind of upgrade that this ticket authorizes.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_ticket_policy">ticket_policy</Link>(ticket: &<Link href="package#0x2_package_UpgradeTicket">package::UpgradeTicket</Link>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_ticket_policy">ticket_policy</Link>(ticket: &<Link href="package#0x2_package_UpgradeTicket">UpgradeTicket</Link>): u8 \{
    ticket.policy
}
</code></pre>



</details>

<Link id="0x2_package_receipt_cap"></Link>

## Function `receipt_cap`

ID of the <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> that this <code>
receipt</code> should be used to
update.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_receipt_cap">receipt_cap</Link>(receipt: &<Link href="package#0x2_package_UpgradeReceipt">package::UpgradeReceipt</Link>): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_receipt_cap">receipt_cap</Link>(receipt: &<Link href="package#0x2_package_UpgradeReceipt">UpgradeReceipt</Link>): ID \{
    receipt.cap
}
</code></pre>



</details>

<Link id="0x2_package_receipt_package"></Link>

## Function `receipt_package`

ID of the package that was upgraded to: the latest version of
the package, as of the upgrade represented by this <code>
receipt</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_receipt_package">receipt_package</Link>(receipt: &<Link href="package#0x2_package_UpgradeReceipt">package::UpgradeReceipt</Link>): <Link href="object#0x2_object_ID">object::ID</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_receipt_package">receipt_package</Link>(receipt: &<Link href="package#0x2_package_UpgradeReceipt">UpgradeReceipt</Link>): ID \{
    receipt.<Link href="package#0x2_package">package</Link>
}
</code></pre>



</details>

<Link id="0x2_package_ticket_digest"></Link>

## Function `ticket_digest`

A hash of the package contents for the new version of the
package.  This ticket only authorizes an upgrade to a package
that matches this digest.  A package's contents are identified
by two things:

- modules: [[u8]]       a list of the package's module contents
- deps:    [[u8; 32]]   a list of 32 byte ObjectIDs of the
package's transitive dependencies

A package's digest is calculated as:

sha3_256(sort(modules ++ deps))


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_ticket_digest">ticket_digest</Link>(ticket: &<Link href="package#0x2_package_UpgradeTicket">package::UpgradeTicket</Link>): &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_ticket_digest">ticket_digest</Link>(ticket: &<Link href="package#0x2_package_UpgradeTicket">UpgradeTicket</Link>): &<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt; \{
    &ticket.digest
}
</code></pre>



</details>

<Link id="0x2_package_compatible_policy"></Link>

## Function `compatible_policy`

Expose the constants representing various upgrade policies


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_compatible_policy">compatible_policy</Link>(): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_compatible_policy">compatible_policy</Link>(): u8 \{ <Link href="package#0x2_package_COMPATIBLE">COMPATIBLE</Link> }
</code></pre>



</details>

<Link id="0x2_package_additive_policy"></Link>

## Function `additive_policy`



<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_additive_policy">additive_policy</Link>(): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_additive_policy">additive_policy</Link>(): u8 \{ <Link href="package#0x2_package_ADDITIVE">ADDITIVE</Link> }
</code></pre>



</details>

<Link id="0x2_package_dep_only_policy"></Link>

## Function `dep_only_policy`



<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_dep_only_policy">dep_only_policy</Link>(): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_dep_only_policy">dep_only_policy</Link>(): u8 \{ <Link href="package#0x2_package_DEP_ONLY">DEP_ONLY</Link> }
</code></pre>



</details>

<Link id="0x2_package_only_additive_upgrades"></Link>

## Function `only_additive_upgrades`

Restrict upgrades through this upgrade <code>
cap</code> to just add code, or
change dependencies.


<pre><code>
<b>public</b> entry <b>fun</b> <Link href="package#0x2_package_only_additive_upgrades">only_additive_upgrades</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> entry <b>fun</b> <Link href="package#0x2_package_only_additive_upgrades">only_additive_upgrades</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>) \{
    cap.<Link href="package#0x2_package_restrict">restrict</Link>(<Link href="package#0x2_package_ADDITIVE">ADDITIVE</Link>)
}
</code></pre>



</details>

<Link id="0x2_package_only_dep_upgrades"></Link>

## Function `only_dep_upgrades`

Restrict upgrades through this upgrade <code>
cap</code> to just change
dependencies.


<pre><code>
<b>public</b> entry <b>fun</b> <Link href="package#0x2_package_only_dep_upgrades">only_dep_upgrades</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> entry <b>fun</b> <Link href="package#0x2_package_only_dep_upgrades">only_dep_upgrades</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>) \{
    cap.<Link href="package#0x2_package_restrict">restrict</Link>(<Link href="package#0x2_package_DEP_ONLY">DEP_ONLY</Link>)
}
</code></pre>



</details>

<Link id="0x2_package_make_immutable"></Link>

## Function `make_immutable`

Discard the <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code> to make a package immutable.


<pre><code>
<b>public</b> entry <b>fun</b> <Link href="package#0x2_package_make_immutable">make_immutable</Link>(cap: <Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> entry <b>fun</b> <Link href="package#0x2_package_make_immutable">make_immutable</Link>(cap: <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>) \{
    <b>let</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link> \{ id, <Link href="package#0x2_package">package</Link>: _, version: _, policy: _ } = cap;
    id.delete();
}
</code></pre>



</details>

<Link id="0x2_package_authorize_upgrade"></Link>

## Function `authorize_upgrade`

Issue a ticket authorizing an upgrade to a particular new bytecode
(identified by its digest).  A ticket will only be issued if one has
not already been issued, and if the <code>
policy</code> requested is at least as
restrictive as the policy set out by the <code>
cap</code>.

The <code>
digest</code> supplied and the <code>
policy</code> will both be checked by
validators when running the upgrade.  I.e. the bytecode supplied in
the upgrade must have a matching digest, and the changes relative to
the parent package must be compatible with the policy in the ticket
for the upgrade to succeed.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_authorize_upgrade">authorize_upgrade</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>, policy: u8, digest: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;): <Link href="package#0x2_package_UpgradeTicket">package::UpgradeTicket</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_authorize_upgrade">authorize_upgrade</Link>(
    cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>,
    policy: u8,
    digest: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u8&gt;
): <Link href="package#0x2_package_UpgradeTicket">UpgradeTicket</Link> \{
    <b>let</b> id_zero = @0x0.to_id();
    <b>assert</b>!(cap.<Link href="package#0x2_package">package</Link> != id_zero, <Link href="package#0x2_package_EAlreadyAuthorized">EAlreadyAuthorized</Link>);
    <b>assert</b>!(policy &gt;= cap.policy, <Link href="package#0x2_package_ETooPermissive">ETooPermissive</Link>);

    <b>let</b> <Link href="package#0x2_package">package</Link> = cap.<Link href="package#0x2_package">package</Link>;
    cap.<Link href="package#0x2_package">package</Link> = id_zero;

    <Link href="package#0x2_package_UpgradeTicket">UpgradeTicket</Link> \{
        cap: <Link href="object#0x2_object_id">object::id</Link>(cap),
        <Link href="package#0x2_package">package</Link>,
        policy,
        digest,
    }
}
</code></pre>



</details>

<Link id="0x2_package_commit_upgrade"></Link>

## Function `commit_upgrade`

Consume an <code>
<Link href="package#0x2_package_UpgradeReceipt">UpgradeReceipt</Link></code> to update its <code>
<Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link></code>, finalizing
the upgrade.


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_commit_upgrade">commit_upgrade</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>, receipt: <Link href="package#0x2_package_UpgradeReceipt">package::UpgradeReceipt</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="package#0x2_package_commit_upgrade">commit_upgrade</Link>(
    cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>,
    receipt: <Link href="package#0x2_package_UpgradeReceipt">UpgradeReceipt</Link>,
) \{
    <b>let</b> <Link href="package#0x2_package_UpgradeReceipt">UpgradeReceipt</Link> \{ cap: cap_id, <Link href="package#0x2_package">package</Link> } = receipt;

    <b>assert</b>!(<Link href="object#0x2_object_id">object::id</Link>(cap) == cap_id, <Link href="package#0x2_package_EWrongUpgradeCap">EWrongUpgradeCap</Link>);
    <b>assert</b>!(cap.<Link href="package#0x2_package">package</Link>.to_address() == @0x0, <Link href="package#0x2_package_ENotAuthorized">ENotAuthorized</Link>);

    cap.<Link href="package#0x2_package">package</Link> = <Link href="package#0x2_package">package</Link>;
    cap.version = cap.version + 1;
}
</code></pre>



</details>

<Link id="0x2_package_restrict"></Link>

## Function `restrict`



<pre><code>
<b>fun</b> <Link href="package#0x2_package_restrict">restrict</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">package::UpgradeCap</Link>, policy: u8)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="package#0x2_package_restrict">restrict</Link>(cap: &<b>mut</b> <Link href="package#0x2_package_UpgradeCap">UpgradeCap</Link>, policy: u8) \{
    <b>assert</b>!(cap.policy &lt;= policy, <Link href="package#0x2_package_ETooPermissive">ETooPermissive</Link>);
    cap.policy = policy;
}
</code></pre>



</details>
