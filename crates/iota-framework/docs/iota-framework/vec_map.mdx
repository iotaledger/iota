---
title: Module `0x2::vec_map`
---
import Link from '@docusaurus/Link';

<Link id="0x2_vec_map"/>


-  [Struct `VecMap`](#0x2_vec_map_VecMap)
-  [Struct `Entry`](#0x2_vec_map_Entry)
-  [Constants](#@Constants_0)
-  [Function `empty`](#0x2_vec_map_empty)
-  [Function `insert`](#0x2_vec_map_insert)
-  [Function `remove`](#0x2_vec_map_remove)
-  [Function `pop`](#0x2_vec_map_pop)
-  [Function `get_mut`](#0x2_vec_map_get_mut)
-  [Function `get`](#0x2_vec_map_get)
-  [Function `try_get`](#0x2_vec_map_try_get)
-  [Function `contains`](#0x2_vec_map_contains)
-  [Function `size`](#0x2_vec_map_size)
-  [Function `is_empty`](#0x2_vec_map_is_empty)
-  [Function `destroy_empty`](#0x2_vec_map_destroy_empty)
-  [Function `into_keys_values`](#0x2_vec_map_into_keys_values)
-  [Function `keys`](#0x2_vec_map_keys)
-  [Function `get_idx_opt`](#0x2_vec_map_get_idx_opt)
-  [Function `get_idx`](#0x2_vec_map_get_idx)
-  [Function `get_entry_by_idx`](#0x2_vec_map_get_entry_by_idx)
-  [Function `get_entry_by_idx_mut`](#0x2_vec_map_get_entry_by_idx_mut)
-  [Function `remove_entry_by_idx`](#0x2_vec_map_remove_entry_by_idx)


<pre><code>
<b>use</b> <Link to="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link to="../move-stdlib/vector#0x1_vector">0x1::vector</Link>;
</code></pre>



<Link id="0x2_vec_map_VecMap"></Link>

## Struct `VecMap`

A map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries
are *not* sorted by key--entries are included in insertion order.
All operations are O(N) in the size of the map--the intention of this data structure is only to provide
the convenience of programming against a map API.
Large maps should use handwritten parent/child relationships instead.
Maps that need sorted iteration rather than insertion order iteration should also be handwritten.


<pre><code>
<b>struct</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K: <b>copy</b>, V&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
contents: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link to="../iota-framework/vec_map#0x2_vec_map_Entry">vec_map::Entry</Link>&lt;K, V&gt;&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0x2_vec_map_Entry"></Link>

## Struct `Entry`

An entry in the map


<pre><code>
<b>struct</b> <Link to="../iota-framework/vec_map#0x2_vec_map_Entry">Entry</Link>&lt;K: <b>copy</b>, V&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
key: K</code>
</dt>
<dd>

</dd>
<dt>
<code>
value: V</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0x2_vec_map_EKeyAlreadyExists"></Link>

This key already exists in the map


<pre><code>
<b>const</b> <Link to="../iota-framework/vec_map#0x2_vec_map_EKeyAlreadyExists">EKeyAlreadyExists</Link>: u64 = 0;
</code></pre>



<Link id="0x2_vec_map_EKeyDoesNotExist"></Link>

This key does not exist in the map


<pre><code>
<b>const</b> <Link to="../iota-framework/vec_map#0x2_vec_map_EKeyDoesNotExist">EKeyDoesNotExist</Link>: u64 = 1;
</code></pre>



<Link id="0x2_vec_map_EIndexOutOfBounds"></Link>

Trying to access an element of the map at an invalid index


<pre><code>
<b>const</b> <Link to="../iota-framework/vec_map#0x2_vec_map_EIndexOutOfBounds">EIndexOutOfBounds</Link>: u64 = 3;
</code></pre>



<Link id="0x2_vec_map_EMapEmpty"></Link>

Trying to pop from a map that is empty


<pre><code>
<b>const</b> <Link to="../iota-framework/vec_map#0x2_vec_map_EMapEmpty">EMapEmpty</Link>: u64 = 4;
</code></pre>



<Link id="0x2_vec_map_EMapNotEmpty"></Link>

Trying to destroy a map that is not empty


<pre><code>
<b>const</b> <Link to="../iota-framework/vec_map#0x2_vec_map_EMapNotEmpty">EMapNotEmpty</Link>: u64 = 2;
</code></pre>



<Link id="0x2_vec_map_empty"></Link>

## Function `empty`

Create an empty <code>
<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link></code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_empty">empty</Link>&lt;K: <b>copy</b>, V&gt;(): <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_empty">empty</Link>&lt;K: <b>copy</b>, V&gt;(): <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt; \{
    <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link> \{ contents: <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[] }
}
</code></pre>



</details>

<Link id="0x2_vec_map_insert"></Link>

## Function `insert`

Insert the entry <code>
key</code> |-> <code>
value</code> into <code>
self</code>.
Aborts if <code>
key</code> is already bound in <code>
self</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_insert">insert</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: K, value: V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_insert">insert</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: K, value: V) \{
    <b>assert</b>!(!self.<Link to="../iota-framework/vec_map#0x2_vec_map_contains">contains</Link>(&key), <Link to="../iota-framework/vec_map#0x2_vec_map_EKeyAlreadyExists">EKeyAlreadyExists</Link>);
    self.contents.push_back(<Link to="../iota-framework/vec_map#0x2_vec_map_Entry">Entry</Link> \{ key, value })
}
</code></pre>



</details>

<Link id="0x2_vec_map_remove"></Link>

## Function `remove`

Remove the entry <code>
key</code> |-> <code>
value</code> from self. Aborts if <code>
key</code> is not bound in <code>
self</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_remove">remove</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): (K, V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_remove">remove</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: &K): (K, V) \{
    <b>let</b> idx = self.<Link to="../iota-framework/vec_map#0x2_vec_map_get_idx">get_idx</Link>(key);
    <b>let</b> <Link to="../iota-framework/vec_map#0x2_vec_map_Entry">Entry</Link> \{ key, value } = self.contents.<Link to="../iota-framework/vec_map#0x2_vec_map_remove">remove</Link>(idx);
    (key, value)
}
</code></pre>



</details>

<Link id="0x2_vec_map_pop"></Link>

## Function `pop`

Pop the most recently inserted entry from the map. Aborts if the map is empty.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_pop">pop</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;): (K, V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_pop">pop</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;): (K, V) \{
    <b>assert</b>!(!self.contents.<Link to="../iota-framework/vec_map#0x2_vec_map_is_empty">is_empty</Link>(), <Link to="../iota-framework/vec_map#0x2_vec_map_EMapEmpty">EMapEmpty</Link>);
    <b>let</b> <Link to="../iota-framework/vec_map#0x2_vec_map_Entry">Entry</Link> \{ key, value } = self.contents.pop_back();
    (key, value)
}
</code></pre>



</details>

<Link id="0x2_vec_map_get_mut"></Link>

## Function `get_mut`

Get a mutable reference to the value bound to <code>
key</code> in <code>
self</code>.
Aborts if <code>
key</code> is not bound in <code>
self</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_mut">get_mut</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): &<b>mut</b> V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_mut">get_mut</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: &K): &<b>mut</b> V \{
    <b>let</b> idx = self.<Link to="../iota-framework/vec_map#0x2_vec_map_get_idx">get_idx</Link>(key);
    <b>let</b> entry = &<b>mut</b> self.contents[idx];
    &<b>mut</b> entry.value
}
</code></pre>



</details>

<Link id="0x2_vec_map_get"></Link>

## Function `get`

Get a reference to the value bound to <code>
key</code> in <code>
self</code>.
Aborts if <code>
key</code> is not bound in <code>
self</code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get">get</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): &V
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get">get</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: &K): &V \{
    <b>let</b> idx = self.<Link to="../iota-framework/vec_map#0x2_vec_map_get_idx">get_idx</Link>(key);
    <b>let</b> entry = &self.contents[idx];
    &entry.value
}
</code></pre>



</details>

<Link id="0x2_vec_map_try_get"></Link>

## Function `try_get`

Safely try borrow a value bound to <code>
key</code> in <code>
self</code>.
Return Some(V) if the value exists, None otherwise.
Only works for a "copyable" value as references cannot be stored in <code>
<Link to="../move-stdlib/vector#0x1_vector">vector</Link></code>.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_try_get">try_get</Link>&lt;K: <b>copy</b>, V: <b>copy</b>&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;V&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_try_get">try_get</Link>&lt;K: <b>copy</b>, V: <b>copy</b>&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: &K): Option&lt;V&gt; \{
    <b>if</b> (self.<Link to="../iota-framework/vec_map#0x2_vec_map_contains">contains</Link>(key)) \{
        <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(*<Link to="../iota-framework/vec_map#0x2_vec_map_get">get</Link>(self, key))
    } <b>else</b> \{
        <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
    }
}
</code></pre>



</details>

<Link id="0x2_vec_map_contains"></Link>

## Function `contains`

Return true if <code>
self</code> contains an entry for <code>
key</code>, false otherwise


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_contains">contains</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_contains">contains</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;, key: &K): bool \{
    <Link to="../iota-framework/vec_map#0x2_vec_map_get_idx_opt">get_idx_opt</Link>(self, key).is_some()
}
</code></pre>



</details>

<Link id="0x2_vec_map_size"></Link>

## Function `size`

Return the number of entries in <code>
self</code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;): u64 \{
    self.contents.length()
}
</code></pre>



</details>

<Link id="0x2_vec_map_is_empty"></Link>

## Function `is_empty`

Return true if <code>
self</code> has 0 elements, false otherwise


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_is_empty">is_empty</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_is_empty">is_empty</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;): bool \{
    self.<Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>() == 0
}
</code></pre>



</details>

<Link id="0x2_vec_map_destroy_empty"></Link>

## Function `destroy_empty`

Destroy an empty map. Aborts if <code>
self</code> is not empty


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_destroy_empty">destroy_empty</Link>&lt;K: <b>copy</b>, V&gt;(self: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_destroy_empty">destroy_empty</Link>&lt;K: <b>copy</b>, V&gt;(self: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;) \{
    <b>let</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link> \{ contents } = self;
    <b>assert</b>!(contents.<Link to="../iota-framework/vec_map#0x2_vec_map_is_empty">is_empty</Link>(), <Link to="../iota-framework/vec_map#0x2_vec_map_EMapNotEmpty">EMapNotEmpty</Link>);
    contents.<Link to="../iota-framework/vec_map#0x2_vec_map_destroy_empty">destroy_empty</Link>()
}
</code></pre>



</details>

<Link id="0x2_vec_map_into_keys_values"></Link>

## Function `into_keys_values`

Unpack <code>
self</code> into vectors of its keys and values.
The output keys and values are stored in insertion order, *not* sorted by key.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_into_keys_values">into_keys_values</Link>&lt;K: <b>copy</b>, V&gt;(self: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;): (<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;K&gt;, <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;V&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_into_keys_values">into_keys_values</Link>&lt;K: <b>copy</b>, V&gt;(self: <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;): (<Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;K&gt;, <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;V&gt;) \{
    <b>let</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link> \{ <b>mut</b> contents } = self;
    // reverse the <Link to="../move-stdlib/vector#0x1_vector">vector</Link> so the output keys and values will appear in insertion order
    contents.reverse();
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> n = contents.length();
    <b>let</b> <b>mut</b> keys = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>let</b> <b>mut</b> values = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>while</b> (i &lt; n) \{
        <b>let</b> <Link to="../iota-framework/vec_map#0x2_vec_map_Entry">Entry</Link> \{ key, value } = contents.pop_back();
        keys.push_back(key);
        values.push_back(value);
        i = i + 1;
    };
    contents.<Link to="../iota-framework/vec_map#0x2_vec_map_destroy_empty">destroy_empty</Link>();
    (keys, values)
}
</code></pre>



</details>

<Link id="0x2_vec_map_keys"></Link>

## Function `keys`

Returns a list of keys in the map.
Do not assume any particular ordering.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_keys">keys</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;K&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_keys">keys</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;): <Link to="../move-stdlib/vector#0x1_vector">vector</Link>&lt;K&gt; \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> n = self.contents.length();
    <b>let</b> <b>mut</b> keys = <Link to="../move-stdlib/vector#0x1_vector">vector</Link>[];
    <b>while</b> (i &lt; n) \{
        <b>let</b> entry = self.contents.borrow(i);
        keys.push_back(entry.key);
        i = i + 1;
    };
    keys
}
</code></pre>



</details>

<Link id="0x2_vec_map_get_idx_opt"></Link>

## Function `get_idx_opt`

Find the index of <code>
key</code> in <code>
self</code>. Return <code>
None</code> if <code>
key</code> is not in <code>
self</code>.
Note that map entries are stored in insertion order, *not* sorted by key.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_idx_opt">get_idx_opt</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): <Link to="../move-stdlib/option#0x1_option_Option">option::Option</Link>&lt;u64&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_idx_opt">get_idx_opt</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: &K): Option&lt;u64&gt; \{
    <b>let</b> <b>mut</b> i = 0;
    <b>let</b> n = <Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self);
    <b>while</b> (i &lt; n) \{
        <b>if</b> (&self.contents[i].key == key) \{
            <b>return</b> <Link to="../move-stdlib/option#0x1_option_some">option::some</Link>(i)
        };
        i = i + 1;
    };
    <Link to="../move-stdlib/option#0x1_option_none">option::none</Link>()
}
</code></pre>



</details>

<Link id="0x2_vec_map_get_idx"></Link>

## Function `get_idx`

Find the index of <code>
key</code> in <code>
self</code>. Aborts if <code>
key</code> is not in <code>
self</code>.
Note that map entries are stored in insertion order, *not* sorted by key.


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_idx">get_idx</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, key: &K): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_idx">get_idx</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K,V&gt;, key: &K): u64 \{
    <b>let</b> idx_opt = self.<Link to="../iota-framework/vec_map#0x2_vec_map_get_idx_opt">get_idx_opt</Link>(key);
    <b>assert</b>!(idx_opt.is_some(), <Link to="../iota-framework/vec_map#0x2_vec_map_EKeyDoesNotExist">EKeyDoesNotExist</Link>);
    idx_opt.destroy_some()
}
</code></pre>



</details>

<Link id="0x2_vec_map_get_entry_by_idx"></Link>

## Function `get_entry_by_idx`

Return a reference to the <code>
idx</code>th entry of <code>
self</code>. This gives direct access into the backing array of the map--use with caution.
Note that map entries are stored in insertion order, *not* sorted by key.
Aborts if <code>
idx</code> is greater than or equal to <code>
<Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self)</code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_entry_by_idx">get_entry_by_idx</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, idx: u64): (&K, &V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_entry_by_idx">get_entry_by_idx</Link>&lt;K: <b>copy</b>, V&gt;(self: &<Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;, idx: u64): (&K, &V) \{
    <b>assert</b>!(idx &lt; <Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self), <Link to="../iota-framework/vec_map#0x2_vec_map_EIndexOutOfBounds">EIndexOutOfBounds</Link>);
    <b>let</b> entry = &self.contents[idx];
    (&entry.key, &entry.value)
}
</code></pre>



</details>

<Link id="0x2_vec_map_get_entry_by_idx_mut"></Link>

## Function `get_entry_by_idx_mut`

Return a mutable reference to the <code>
idx</code>th entry of <code>
self</code>. This gives direct access into the backing array of the map--use with caution.
Note that map entries are stored in insertion order, *not* sorted by key.
Aborts if <code>
idx</code> is greater than or equal to <code>
<Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self)</code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_entry_by_idx_mut">get_entry_by_idx_mut</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, idx: u64): (&K, &<b>mut</b> V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_get_entry_by_idx_mut">get_entry_by_idx_mut</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;, idx: u64): (&K, &<b>mut</b> V) \{
    <b>assert</b>!(idx &lt; <Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self), <Link to="../iota-framework/vec_map#0x2_vec_map_EIndexOutOfBounds">EIndexOutOfBounds</Link>);
    <b>let</b> entry = &<b>mut</b> self.contents[idx];
    (&entry.key, &<b>mut</b> entry.value)
}
</code></pre>



</details>

<Link id="0x2_vec_map_remove_entry_by_idx"></Link>

## Function `remove_entry_by_idx`

Remove the entry at index <code>
idx</code> from self.
Aborts if <code>
idx</code> is greater than or equal to <code>
<Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self)</code>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_remove_entry_by_idx">remove_entry_by_idx</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">vec_map::VecMap</Link>&lt;K, V&gt;, idx: u64): (K, V)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link to="../iota-framework/vec_map#0x2_vec_map_remove_entry_by_idx">remove_entry_by_idx</Link>&lt;K: <b>copy</b>, V&gt;(self: &<b>mut</b> <Link to="../iota-framework/vec_map#0x2_vec_map_VecMap">VecMap</Link>&lt;K, V&gt;, idx: u64): (K, V) \{
    <b>assert</b>!(idx &lt; <Link to="../iota-framework/vec_map#0x2_vec_map_size">size</Link>(self), <Link to="../iota-framework/vec_map#0x2_vec_map_EIndexOutOfBounds">EIndexOutOfBounds</Link>);
    <b>let</b> <Link to="../iota-framework/vec_map#0x2_vec_map_Entry">Entry</Link> \{ key, value } = self.contents.<Link to="../iota-framework/vec_map#0x2_vec_map_remove">remove</Link>(idx);
    (key, value)
}
</code></pre>



</details>
