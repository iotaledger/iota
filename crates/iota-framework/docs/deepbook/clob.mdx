---
title: Module `0xdee9::clob`
---
import Link from '@docusaurus/Link';



-  [Struct `PoolCreated`](#0xdee9_clob_PoolCreated)
-  [Struct `OrderPlacedV2`](#0xdee9_clob_OrderPlacedV2)
-  [Struct `OrderCanceled`](#0xdee9_clob_OrderCanceled)
-  [Struct `OrderFilledV2`](#0xdee9_clob_OrderFilledV2)
-  [Struct `Order`](#0xdee9_clob_Order)
-  [Struct `TickLevel`](#0xdee9_clob_TickLevel)
-  [Resource `Pool`](#0xdee9_clob_Pool)
-  [Struct `OrderPlaced`](#0xdee9_clob_OrderPlaced)
-  [Struct `OrderFilled`](#0xdee9_clob_OrderFilled)
-  [Constants](#@Constants_0)
-  [Function `destroy_empty_level`](#0xdee9_clob_destroy_empty_level)
-  [Function `create_account`](#0xdee9_clob_create_account)
-  [Function `create_pool`](#0xdee9_clob_create_pool)
-  [Function `deposit_base`](#0xdee9_clob_deposit_base)
-  [Function `deposit_quote`](#0xdee9_clob_deposit_quote)
-  [Function `withdraw_base`](#0xdee9_clob_withdraw_base)
-  [Function `withdraw_quote`](#0xdee9_clob_withdraw_quote)
-  [Function `swap_exact_base_for_quote`](#0xdee9_clob_swap_exact_base_for_quote)
-  [Function `swap_exact_quote_for_base`](#0xdee9_clob_swap_exact_quote_for_base)
-  [Function `match_bid_with_quote_quantity`](#0xdee9_clob_match_bid_with_quote_quantity)
-  [Function `match_bid`](#0xdee9_clob_match_bid)
-  [Function `match_ask`](#0xdee9_clob_match_ask)
-  [Function `place_market_order`](#0xdee9_clob_place_market_order)
-  [Function `inject_limit_order`](#0xdee9_clob_inject_limit_order)
-  [Function `place_limit_order`](#0xdee9_clob_place_limit_order)
-  [Function `order_is_bid`](#0xdee9_clob_order_is_bid)
-  [Function `emit_order_canceled`](#0xdee9_clob_emit_order_canceled)
-  [Function `emit_order_filled`](#0xdee9_clob_emit_order_filled)
-  [Function `cancel_order`](#0xdee9_clob_cancel_order)
-  [Function `remove_order`](#0xdee9_clob_remove_order)
-  [Function `cancel_all_orders`](#0xdee9_clob_cancel_all_orders)
-  [Function `batch_cancel_order`](#0xdee9_clob_batch_cancel_order)
-  [Function `list_open_orders`](#0xdee9_clob_list_open_orders)
-  [Function `account_balance`](#0xdee9_clob_account_balance)
-  [Function `get_market_price`](#0xdee9_clob_get_market_price)
-  [Function `get_level2_book_status_bid_side`](#0xdee9_clob_get_level2_book_status_bid_side)
-  [Function `get_level2_book_status_ask_side`](#0xdee9_clob_get_level2_book_status_ask_side)
-  [Function `get_level2_book_status`](#0xdee9_clob_get_level2_book_status)
-  [Function `get_order_status`](#0xdee9_clob_get_order_status)


<pre><code>
<b>use</b> <Link href="../move-stdlib/option#0x1_option">0x1::option</Link>;
<b>use</b> <Link href="../move-stdlib/type_name#0x1_type_name">0x1::type_name</Link>;
<b>use</b> <Link href="../iota-framework/balance#0x2_balance">0x2::balance</Link>;
<b>use</b> <Link href="../iota-framework/clock#0x2_clock">0x2::clock</Link>;
<b>use</b> <Link href="../iota-framework/coin#0x2_coin">0x2::coin</Link>;
<b>use</b> <Link href="../iota-framework/event#0x2_event">0x2::event</Link>;
<b>use</b> <Link href="../iota-framework/iota#0x2_iota">0x2::iota</Link>;
<b>use</b> <Link href="../iota-framework/linked_table#0x2_linked_table">0x2::linked_table</Link>;
<b>use</b> <Link href="../iota-framework/object#0x2_object">0x2::object</Link>;
<b>use</b> <Link href="../iota-framework/table#0x2_table">0x2::table</Link>;
<b>use</b> <Link href="../iota-framework/tx_context#0x2_tx_context">0x2::tx_context</Link>;
<b>use</b> <Link href="critbit#0xdee9_critbit">0xdee9::critbit</Link>;
<b>use</b> <Link href="custodian#0xdee9_custodian">0xdee9::custodian</Link>;
<b>use</b> <Link href="math#0xdee9_math">0xdee9::math</Link>;
</code></pre>



<Link id="0xdee9_clob_PoolCreated"></Link>

## Struct `PoolCreated`

Emitted when a new pool is created


<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_PoolCreated">PoolCreated</Link> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the newly created pool
</dd>
<dt>
<code>
base_asset: <Link href="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
quote_asset: <Link href="../move-stdlib/type_name#0x1_type_name_TypeName">type_name::TypeName</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
taker_fee_rate: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
maker_rebate_rate: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
tick_size: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
lot_size: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_OrderPlacedV2"></Link>

## Struct `OrderPlacedV2`

Emitted when a maker order is injected into the order book.


<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_OrderPlacedV2">OrderPlacedV2</Link>&lt;BaseAsset, QuoteAsset&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the pool the order was placed on
</dd>
<dt>
<code>
order_id: u64</code>
</dt>
<dd>
 ID of the order within the pool
</dd>
<dt>
<code>
is_bid: bool</code>
</dt>
<dd>

</dd>
<dt>
<code>
owner: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the <code>
AccountCap</code> that placed the order
</dd>
<dt>
<code>
base_asset_quantity_placed: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
expire_timestamp: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_OrderCanceled"></Link>

## Struct `OrderCanceled`

Emitted when a maker order is canceled.


<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_OrderCanceled">OrderCanceled</Link>&lt;BaseAsset, QuoteAsset&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the pool the order was placed on
</dd>
<dt>
<code>
order_id: u64</code>
</dt>
<dd>
 ID of the order within the pool
</dd>
<dt>
<code>
is_bid: bool</code>
</dt>
<dd>

</dd>
<dt>
<code>
owner: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the <code>
AccountCap</code> that placed the order
</dd>
<dt>
<code>
base_asset_quantity_canceled: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_OrderFilledV2"></Link>

## Struct `OrderFilledV2`

Emitted only when a maker order is filled.


<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_OrderFilledV2">OrderFilledV2</Link>&lt;BaseAsset, QuoteAsset&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the pool the order was placed on
</dd>
<dt>
<code>
order_id: u64</code>
</dt>
<dd>
 ID of the order within the pool
</dd>
<dt>
<code>
is_bid: bool</code>
</dt>
<dd>

</dd>
<dt>
<code>
owner: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the <code>
AccountCap</code> that placed the order
</dd>
<dt>
<code>
total_quantity: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
base_asset_quantity_filled: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
base_asset_quantity_remaining: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
taker_commission: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
maker_rebates: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_Order"></Link>

## Struct `Order`



<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_Order">Order</Link> <b>has</b> drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
order_id: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
quantity: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
is_bid: bool</code>
</dt>
<dd>

</dd>
<dt>
<code>
owner: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
expire_timestamp: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_TickLevel"></Link>

## Struct `TickLevel`



<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link> <b>has</b> store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
open_orders: <Link href="../iota-framework/linked_table#0x2_linked_table_LinkedTable">linked_table::LinkedTable</Link>&lt;u64, <Link href="clob#0xdee9_clob_Order">clob::Order</Link>&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_Pool"></Link>

## Resource `Pool`



<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt; <b>has</b> key
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
id: <Link href="../iota-framework/object#0x2_object_UID">object::UID</Link></code>
</dt>
<dd>

</dd>
<dt>
<code>
bids: <Link href="critbit#0xdee9_critbit_CritbitTree">critbit::CritbitTree</Link>&lt;<Link href="clob#0xdee9_clob_TickLevel">clob::TickLevel</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
asks: <Link href="critbit#0xdee9_critbit_CritbitTree">critbit::CritbitTree</Link>&lt;<Link href="clob#0xdee9_clob_TickLevel">clob::TickLevel</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
next_bid_order_id: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
next_ask_order_id: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
usr_open_orders: <Link href="../iota-framework/table#0x2_table_Table">table::Table</Link>&lt;<Link href="../iota-framework/object#0x2_object_ID">object::ID</Link>, <Link href="../iota-framework/linked_table#0x2_linked_table_LinkedTable">linked_table::LinkedTable</Link>&lt;u64, u64&gt;&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
taker_fee_rate: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
maker_rebate_rate: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
tick_size: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
lot_size: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
base_custodian: <Link href="custodian#0xdee9_custodian_Custodian">custodian::Custodian</Link>&lt;BaseAsset&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
quote_custodian: <Link href="custodian#0xdee9_custodian_Custodian">custodian::Custodian</Link>&lt;QuoteAsset&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
creation_fee: <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;<Link href="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
base_asset_trading_fees: <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;BaseAsset&gt;</code>
</dt>
<dd>

</dd>
<dt>
<code>
quote_asset_trading_fees: <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;QuoteAsset&gt;</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_OrderPlaced"></Link>

## Struct `OrderPlaced`

Deprecated since v1.0.0, use <code>
<Link href="clob#0xdee9_clob_OrderPlacedV2">OrderPlacedV2</Link></code> instead.


<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_OrderPlaced">OrderPlaced</Link>&lt;BaseAsset, QuoteAsset&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the pool the order was placed on
</dd>
<dt>
<code>
order_id: u64</code>
</dt>
<dd>
 ID of the order within the pool
</dd>
<dt>
<code>
is_bid: bool</code>
</dt>
<dd>

</dd>
<dt>
<code>
owner: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the <code>
AccountCap</code> that placed the order
</dd>
<dt>
<code>
base_asset_quantity_placed: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="0xdee9_clob_OrderFilled"></Link>

## Struct `OrderFilled`

Deprecated since v1.0.0, use <code>
<Link href="clob#0xdee9_clob_OrderFilledV2">OrderFilledV2</Link></code> instead.


<pre><code>
<b>struct</b> <Link href="clob#0xdee9_clob_OrderFilled">OrderFilled</Link>&lt;BaseAsset, QuoteAsset&gt; <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>
pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the pool the order was placed on
</dd>
<dt>
<code>
order_id: u64</code>
</dt>
<dd>
 ID of the order within the pool
</dd>
<dt>
<code>
is_bid: bool</code>
</dt>
<dd>

</dd>
<dt>
<code>
owner: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link></code>
</dt>
<dd>
 object ID of the <code>
AccountCap</code> that placed the order
</dd>
<dt>
<code>
total_quantity: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
base_asset_quantity_filled: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
base_asset_quantity_remaining: u64</code>
</dt>
<dd>

</dd>
<dt>
<code>
price: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<Link id="@Constants_0"></Link>

## Constants


<Link id="0xdee9_clob_FLOAT_SCALING"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_FLOAT_SCALING">FLOAT_SCALING</Link>: u64 = 1000000000;
</code></pre>



<Link id="0xdee9_clob_DEPRECATED"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_DEPRECATED">DEPRECATED</Link>: u64 = 0;
</code></pre>



<Link id="0xdee9_clob_EInsufficientBaseCoin"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInsufficientBaseCoin">EInsufficientBaseCoin</Link>: u64 = 7;
</code></pre>



<Link id="0xdee9_clob_EInsufficientQuoteCoin"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInsufficientQuoteCoin">EInsufficientQuoteCoin</Link>: u64 = 8;
</code></pre>



<Link id="0xdee9_clob_EInvalidExpireTimestamp"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidExpireTimestamp">EInvalidExpireTimestamp</Link>: u64 = 19;
</code></pre>



<Link id="0xdee9_clob_EInvalidOrderId"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidOrderId">EInvalidOrderId</Link>: u64 = 3;
</code></pre>



<Link id="0xdee9_clob_EInvalidPrice"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidPrice">EInvalidPrice</Link>: u64 = 5;
</code></pre>



<Link id="0xdee9_clob_EInvalidQuantity"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>: u64 = 6;
</code></pre>



<Link id="0xdee9_clob_EInvalidRestriction"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidRestriction">EInvalidRestriction</Link>: u64 = 14;
</code></pre>



<Link id="0xdee9_clob_EInvalidTickPrice"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidTickPrice">EInvalidTickPrice</Link>: u64 = 11;
</code></pre>



<Link id="0xdee9_clob_EInvalidUser"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EInvalidUser">EInvalidUser</Link>: u64 = 12;
</code></pre>



<Link id="0xdee9_clob_EOrderCannotBeFullyFilled"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EOrderCannotBeFullyFilled">EOrderCannotBeFullyFilled</Link>: u64 = 9;
</code></pre>



<Link id="0xdee9_clob_EOrderCannotBeFullyPassive"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EOrderCannotBeFullyPassive">EOrderCannotBeFullyPassive</Link>: u64 = 10;
</code></pre>



<Link id="0xdee9_clob_EUnauthorizedCancel"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_EUnauthorizedCancel">EUnauthorizedCancel</Link>: u64 = 4;
</code></pre>



<Link id="0xdee9_clob_FILL_OR_KILL"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_FILL_OR_KILL">FILL_OR_KILL</Link>: u8 = 2;
</code></pre>



<Link id="0xdee9_clob_IMMEDIATE_OR_CANCEL"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_IMMEDIATE_OR_CANCEL">IMMEDIATE_OR_CANCEL</Link>: u8 = 1;
</code></pre>



<Link id="0xdee9_clob_MAX_PRICE"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_MAX_PRICE">MAX_PRICE</Link>: u64 = 9223372036854775808;
</code></pre>



<Link id="0xdee9_clob_MIN_ASK_ORDER_ID"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_MIN_ASK_ORDER_ID">MIN_ASK_ORDER_ID</Link>: u64 = 9223372036854775808;
</code></pre>



<Link id="0xdee9_clob_MIN_PRICE"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_MIN_PRICE">MIN_PRICE</Link>: u64 = 0;
</code></pre>



<Link id="0xdee9_clob_NO_RESTRICTION"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_NO_RESTRICTION">NO_RESTRICTION</Link>: u8 = 0;
</code></pre>



<Link id="0xdee9_clob_POST_OR_ABORT"></Link>



<pre><code>
<b>const</b> <Link href="clob#0xdee9_clob_POST_OR_ABORT">POST_OR_ABORT</Link>: u8 = 3;
</code></pre>



<Link id="0xdee9_clob_destroy_empty_level"></Link>

## Function `destroy_empty_level`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_destroy_empty_level">destroy_empty_level</Link>(level: <Link href="clob#0xdee9_clob_TickLevel">clob::TickLevel</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_destroy_empty_level">destroy_empty_level</Link>(level: <Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>) \{
    <b>let</b> <Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link> \{
        price: _,
        open_orders: orders,
    } = level;

    <Link href="../iota-framework/linked_table#0x2_linked_table_destroy_empty">linked_table::destroy_empty</Link>(orders);
}
</code></pre>



</details>

<Link id="0xdee9_clob_create_account"></Link>

## Function `create_account`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_create_account">create_account</Link>(_ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_create_account">create_account</Link>(_ctx: &<b>mut</b> TxContext): AccountCap \{
    <b>abort</b> <Link href="clob#0xdee9_clob_DEPRECATED">DEPRECATED</Link>
}
</code></pre>



</details>

<Link id="0xdee9_clob_create_pool"></Link>

## Function `create_pool`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_create_pool">create_pool</Link>&lt;BaseAsset, QuoteAsset&gt;(_tick_size: u64, _lot_size: u64, _creation_fee: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;<Link href="../iota-framework/iota#0x2_iota_IOTA">iota::IOTA</Link>&gt;, _ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_create_pool">create_pool</Link>&lt;BaseAsset, QuoteAsset&gt;(
    _tick_size: u64,
    _lot_size: u64,
    _creation_fee: Coin&lt;IOTA&gt;,
    _ctx: &<b>mut</b> TxContext,
) \{
    <b>abort</b> <Link href="clob#0xdee9_clob_DEPRECATED">DEPRECATED</Link>
}
</code></pre>



</details>

<Link id="0xdee9_clob_deposit_base"></Link>

## Function `deposit_base`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_deposit_base">deposit_base</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, <Link href="../iota-framework/coin#0x2_coin">coin</Link>: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_deposit_base">deposit_base</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    <Link href="../iota-framework/coin#0x2_coin">coin</Link>: Coin&lt;BaseAsset&gt;,
    account_cap: &AccountCap
) \{
    <b>assert</b>!(<Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&<Link href="../iota-framework/coin#0x2_coin">coin</Link>) != 0, <Link href="clob#0xdee9_clob_EInsufficientBaseCoin">EInsufficientBaseCoin</Link>);
    <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>(
        &<b>mut</b> pool.base_custodian,
        <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap),
        <Link href="../iota-framework/coin#0x2_coin_into_balance">coin::into_balance</Link>(<Link href="../iota-framework/coin#0x2_coin">coin</Link>)
    )
}
</code></pre>



</details>

<Link id="0xdee9_clob_deposit_quote"></Link>

## Function `deposit_quote`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_deposit_quote">deposit_quote</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, <Link href="../iota-framework/coin#0x2_coin">coin</Link>: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_deposit_quote">deposit_quote</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    <Link href="../iota-framework/coin#0x2_coin">coin</Link>: Coin&lt;QuoteAsset&gt;,
    account_cap: &AccountCap
) \{
    <b>assert</b>!(<Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&<Link href="../iota-framework/coin#0x2_coin">coin</Link>) != 0, <Link href="clob#0xdee9_clob_EInsufficientQuoteCoin">EInsufficientQuoteCoin</Link>);
    <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>(
        &<b>mut</b> pool.quote_custodian,
        <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap),
        <Link href="../iota-framework/coin#0x2_coin_into_balance">coin::into_balance</Link>(<Link href="../iota-framework/coin#0x2_coin">coin</Link>)
    )
}
</code></pre>



</details>

<Link id="0xdee9_clob_withdraw_base"></Link>

## Function `withdraw_base`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_withdraw_base">withdraw_base</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_withdraw_base">withdraw_base</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    account_cap: &AccountCap,
    ctx: &<b>mut</b> TxContext
): Coin&lt;BaseAsset&gt; \{
    <b>assert</b>!(quantity &gt; 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <Link href="custodian#0xdee9_custodian_withdraw_asset">custodian::withdraw_asset</Link>(&<b>mut</b> pool.base_custodian, quantity, account_cap, ctx)
}
</code></pre>



</details>

<Link id="0xdee9_clob_withdraw_quote"></Link>

## Function `withdraw_quote`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_withdraw_quote">withdraw_quote</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_withdraw_quote">withdraw_quote</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    account_cap: &AccountCap,
    ctx: &<b>mut</b> TxContext
): Coin&lt;QuoteAsset&gt; \{
    <b>assert</b>!(quantity &gt; 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <Link href="custodian#0xdee9_custodian_withdraw_asset">custodian::withdraw_asset</Link>(&<b>mut</b> pool.quote_custodian, quantity, account_cap, ctx)
}
</code></pre>



</details>

<Link id="0xdee9_clob_swap_exact_base_for_quote"></Link>

## Function `swap_exact_base_for_quote`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_swap_exact_base_for_quote">swap_exact_base_for_quote</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, base_coin: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;, quote_coin: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;, <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &<Link href="../iota-framework/clock#0x2_clock_Clock">clock::Clock</Link>, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;, <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_swap_exact_base_for_quote">swap_exact_base_for_quote</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    base_coin: Coin&lt;BaseAsset&gt;,
    quote_coin: Coin&lt;QuoteAsset&gt;,
    <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &Clock,
    ctx: &<b>mut</b> TxContext,
): (Coin&lt;BaseAsset&gt;, Coin&lt;QuoteAsset&gt;, u64) \{
    <b>assert</b>!(quantity &gt; 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <b>assert</b>!(<Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&base_coin) &gt;= quantity, <Link href="clob#0xdee9_clob_EInsufficientBaseCoin">EInsufficientBaseCoin</Link>);
    <b>let</b> original_val = <Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&quote_coin);
    <b>let</b> (ret_base_coin, ret_quote_coin) = <Link href="clob#0xdee9_clob_place_market_order">place_market_order</Link>(
        pool,
        quantity,
        <b>false</b>,
        base_coin,
        quote_coin,
        <Link href="../iota-framework/clock#0x2_clock">clock</Link>,
        ctx
    );
    <b>let</b> ret_val = <Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&ret_quote_coin);
    (ret_base_coin, ret_quote_coin, ret_val - original_val)
}
</code></pre>



</details>

<Link id="0xdee9_clob_swap_exact_quote_for_base"></Link>

## Function `swap_exact_quote_for_base`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_swap_exact_quote_for_base">swap_exact_quote_for_base</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &<Link href="../iota-framework/clock#0x2_clock_Clock">clock::Clock</Link>, quote_coin: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;, <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_swap_exact_quote_for_base">swap_exact_quote_for_base</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &Clock,
    quote_coin: Coin&lt;QuoteAsset&gt;,
    ctx: &<b>mut</b> TxContext,
): (Coin&lt;BaseAsset&gt;, Coin&lt;QuoteAsset&gt;, u64) \{
    <b>assert</b>!(quantity &gt; 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <b>assert</b>!(<Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&quote_coin) &gt;= quantity, <Link href="clob#0xdee9_clob_EInsufficientQuoteCoin">EInsufficientQuoteCoin</Link>);
    <b>let</b> (base_asset_balance, quote_asset_balance) = <Link href="clob#0xdee9_clob_match_bid_with_quote_quantity">match_bid_with_quote_quantity</Link>(
        pool,
        quantity,
        <Link href="clob#0xdee9_clob_MAX_PRICE">MAX_PRICE</Link>,
        <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>),
        <Link href="../iota-framework/coin#0x2_coin_into_balance">coin::into_balance</Link>(quote_coin)
    );
    <b>let</b> val = <Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&base_asset_balance);
    (<Link href="../iota-framework/coin#0x2_coin_from_balance">coin::from_balance</Link>(base_asset_balance, ctx), <Link href="../iota-framework/coin#0x2_coin_from_balance">coin::from_balance</Link>(quote_asset_balance, ctx), val)
}
</code></pre>



</details>

<Link id="0xdee9_clob_match_bid_with_quote_quantity"></Link>

## Function `match_bid_with_quote_quantity`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_match_bid_with_quote_quantity">match_bid_with_quote_quantity</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, price_limit: u64, current_timestamp: u64, quote_balance: <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;QuoteAsset&gt;): (<Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;BaseAsset&gt;, <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;QuoteAsset&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_match_bid_with_quote_quantity">match_bid_with_quote_quantity</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    price_limit: u64,
    current_timestamp: u64,
    quote_balance: Balance&lt;QuoteAsset&gt;,
): (Balance&lt;BaseAsset&gt;, Balance&lt;QuoteAsset&gt;) \{
    // Base <Link href="../iota-framework/balance#0x2_balance">balance</Link> received by taker, taking into account of taker commission.
    // Need <b>to</b> individually keep track of the remaining base quantity <b>to</b> be filled <b>to</b> avoid infinite <b>loop</b>.
    <b>let</b> pool_id = *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id);
    <b>let</b> <b>mut</b> taker_quote_quantity_remaining = quantity;
    <b>let</b> <b>mut</b> base_balance_filled = <Link href="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>&lt;BaseAsset&gt;();
    <b>let</b> <b>mut</b> quote_balance_left = quote_balance;
    <b>let</b> all_open_orders = &<b>mut</b> pool.asks;
    <b>if</b> (<Link href="critbit#0xdee9_critbit_is_empty">critbit::is_empty</Link>(all_open_orders)) \{
        <b>return</b> (base_balance_filled, quote_balance_left)
    };
    <b>let</b> (<b>mut</b> tick_price, <b>mut</b> tick_index) = min_leaf(all_open_orders);
    <b>let</b> <b>mut</b> terminate_loop = <b>false</b>;

    <b>while</b> (!is_empty&lt;<Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>&gt;(all_open_orders) && tick_price &lt;= price_limit) \{
        <b>let</b> tick_level = borrow_mut_leaf_by_index(all_open_orders, tick_index);
        <b>let</b> <b>mut</b> order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(<Link href="../iota-framework/linked_table#0x2_linked_table_front">linked_table::front</Link>(&tick_level.open_orders));

        <b>while</b> (!<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&tick_level.open_orders)) \{
            <b>let</b> maker_order = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(&tick_level.open_orders, order_id);
            <b>let</b> <b>mut</b> maker_base_quantity = maker_order.quantity;
            <b>let</b> <b>mut</b> skip_order = <b>false</b>;

            <b>if</b> (maker_order.expire_timestamp &lt;= current_timestamp) \{
                skip_order = <b>true</b>;
                <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.base_custodian, maker_order.owner, maker_order.quantity);
                <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id, maker_order);
            } <b>else</b> \{
                // Calculate how much quote asset (maker_quote_quantity) is required, including the commission, <b>to</b> fill the maker order.
                <b>let</b> maker_quote_quantity_without_commission = clob_math::mul(
                    maker_base_quantity,
                    maker_order.price
                );
                <b>let</b> (is_round_down, <b>mut</b> taker_commission)  = clob_math::unsafe_mul_round(
                    maker_quote_quantity_without_commission,
                    pool.taker_fee_rate
                );
                <b>if</b> (is_round_down)  taker_commission = taker_commission + 1;

                <b>let</b> maker_quote_quantity = maker_quote_quantity_without_commission + taker_commission;

                // Total base quantity filled.
                <b>let</b> <b>mut</b> filled_base_quantity: u64;
                // Total quote quantity filled, excluding commission and rebate.
                <b>let</b> <b>mut</b> filled_quote_quantity: u64;
                // Total quote quantity paid by taker.
                // filled_quote_quantity_without_commission * (<Link href="clob#0xdee9_clob_FLOAT_SCALING">FLOAT_SCALING</Link> + taker_fee_rate) = filled_quote_quantity
                <b>let</b> <b>mut</b> filled_quote_quantity_without_commission: u64;
                <b>if</b> (taker_quote_quantity_remaining &gt; maker_quote_quantity) \{
                    filled_quote_quantity = maker_quote_quantity;
                    filled_quote_quantity_without_commission = maker_quote_quantity_without_commission;
                    filled_base_quantity = maker_base_quantity;
                } <b>else</b> \{
                    terminate_loop = <b>true</b>;
                    // <b>if</b> not enough quote quantity <b>to</b> pay for taker commission, then no quantity will be filled
                    filled_quote_quantity_without_commission = clob_math::unsafe_div(
                        taker_quote_quantity_remaining,
                        <Link href="clob#0xdee9_clob_FLOAT_SCALING">FLOAT_SCALING</Link> + pool.taker_fee_rate
                    );
                    // filled_base_quantity = 0 is permitted since filled_quote_quantity_without_commission can be 0
                    filled_base_quantity = clob_math::unsafe_div(
                        filled_quote_quantity_without_commission,
                        maker_order.price
                    );
                    <b>let</b> filled_base_lot = filled_base_quantity / pool.lot_size;
                    filled_base_quantity = filled_base_lot * pool.lot_size;
                    // filled_quote_quantity_without_commission = 0 is permitted here since filled_base_quantity could be 0
                    filled_quote_quantity_without_commission = clob_math::unsafe_mul(
                        filled_base_quantity,
                        maker_order.price
                    );
                    // <b>if</b> taker_commission = 0 due <b>to</b> underflow, round it up <b>to</b> 1
                    <b>let</b> (round_down, <b>mut</b> taker_commission) = clob_math::unsafe_mul_round(
                        filled_quote_quantity_without_commission,
                        pool.taker_fee_rate
                    );
                    <b>if</b> (round_down) \{
                        taker_commission = taker_commission + 1;
                    };
                    filled_quote_quantity = filled_quote_quantity_without_commission + taker_commission;
                };
                // <b>if</b> maker_rebate = 0 due <b>to</b> underflow, maker will not receive a rebate
                <b>let</b> maker_rebate = clob_math::unsafe_mul(
                    filled_quote_quantity_without_commission,
                    pool.maker_rebate_rate
                );
                maker_base_quantity = maker_base_quantity - filled_base_quantity;

                // maker in ask side, decrease maker's locked base asset, increase maker's available quote asset
                taker_quote_quantity_remaining = taker_quote_quantity_remaining - filled_quote_quantity;
                <b>let</b> locked_base_balance = <Link href="custodian#0xdee9_custodian_decrease_user_locked_balance">custodian::decrease_user_locked_balance</Link>&lt;BaseAsset&gt;(
                    &<b>mut</b> pool.base_custodian,
                    maker_order.owner,
                    filled_base_quantity
                );

                <b>let</b> <b>mut</b> quote_balance_filled = <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                    &<b>mut</b> quote_balance_left,
                    filled_quote_quantity,
                );
                // Send quote asset including rebate <b>to</b> maker.
                <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;QuoteAsset&gt;(
                    &<b>mut</b> pool.quote_custodian,
                    maker_order.owner,
                    <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                        &<b>mut</b> quote_balance_filled,
                        maker_rebate + filled_quote_quantity_without_commission,
                    ),
                );
                // Send remaining of commission - rebate <b>to</b> the protocol.
                // commission - rebate = filled_quote_quantity_without_commission - filled_quote_quantity - maker_rebate
                <Link href="../iota-framework/balance#0x2_balance_join">balance::join</Link>(&<b>mut</b> pool.quote_asset_trading_fees, quote_balance_filled);
                <Link href="../iota-framework/balance#0x2_balance_join">balance::join</Link>(&<b>mut</b> base_balance_filled, locked_base_balance);

                <Link href="clob#0xdee9_clob_emit_order_filled">emit_order_filled</Link>&lt;BaseAsset, QuoteAsset&gt;(
                    *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id),
                    maker_order,
                    filled_base_quantity,
                    // taker_commission = filled_quote_quantity - filled_quote_quantity_without_commission
                    // This guarantees that the subtraction will not underflow
                    filled_quote_quantity - filled_quote_quantity_without_commission,
                    maker_rebate
                )
            };

            <b>if</b> (skip_order || maker_base_quantity == 0) \{
                // Remove the maker order.
                <b>let</b> old_order_id = order_id;
                <b>let</b> maybe_order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_next">linked_table::next</Link>(&tick_level.open_orders, order_id);
                <b>if</b> (!<Link href="../move-stdlib/option#0x1_option_is_none">option::is_none</Link>(maybe_order_id)) \{
                    order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(maybe_order_id);
                };
                <b>let</b> usr_open_order_ids = <Link href="../iota-framework/table#0x2_table_borrow_mut">table::borrow_mut</Link>(&<b>mut</b> pool.usr_open_orders, maker_order.owner);
                <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(usr_open_order_ids, old_order_id);
                <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(&<b>mut</b> tick_level.open_orders, old_order_id);
            } <b>else</b> \{
                // Update the maker order.
                <b>let</b> maker_order_mut = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow_mut">linked_table::borrow_mut</Link>(
                    &<b>mut</b> tick_level.open_orders,
                    order_id);
                maker_order_mut.quantity = maker_base_quantity;
            };
            <b>if</b> (terminate_loop) \{
                <b>break</b>
            };
        };
        <b>if</b> (<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&tick_level.open_orders)) \{
            (tick_price, _) = next_leaf(all_open_orders, tick_price);
            <Link href="clob#0xdee9_clob_destroy_empty_level">destroy_empty_level</Link>(remove_leaf_by_index(all_open_orders, tick_index));
            (_, tick_index) = find_leaf(all_open_orders, tick_price);
        };
        <b>if</b> (terminate_loop) \{
            <b>break</b>
        };
    };
    <b>return</b> (base_balance_filled, quote_balance_left)
}
</code></pre>



</details>

<Link id="0xdee9_clob_match_bid"></Link>

## Function `match_bid`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_match_bid">match_bid</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, price_limit: u64, current_timestamp: u64, quote_balance: <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;QuoteAsset&gt;): (<Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;BaseAsset&gt;, <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;QuoteAsset&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_match_bid">match_bid</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    price_limit: u64,
    current_timestamp: u64,
    quote_balance: Balance&lt;QuoteAsset&gt;,
): (Balance&lt;BaseAsset&gt;, Balance&lt;QuoteAsset&gt;) \{
    <b>let</b> pool_id = *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id);
    // Base <Link href="../iota-framework/balance#0x2_balance">balance</Link> received by taker.
    // Need <b>to</b> individually keep track of the remaining base quantity <b>to</b> be filled <b>to</b> avoid infinite <b>loop</b>.
    <b>let</b> <b>mut</b> taker_base_quantity_remaining = quantity;
    <b>let</b> <b>mut</b> base_balance_filled = <Link href="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>&lt;BaseAsset&gt;();
    <b>let</b> <b>mut</b> quote_balance_left = quote_balance;
    <b>let</b> all_open_orders = &<b>mut</b> pool.asks;
    <b>if</b> (<Link href="critbit#0xdee9_critbit_is_empty">critbit::is_empty</Link>(all_open_orders)) \{
        <b>return</b> (base_balance_filled, quote_balance_left)
    };
    <b>let</b> (<b>mut</b> tick_price, <b>mut</b> tick_index) = min_leaf(all_open_orders);

    <b>while</b> (!is_empty&lt;<Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>&gt;(all_open_orders) && tick_price &lt;= price_limit) \{
        <b>let</b> tick_level = borrow_mut_leaf_by_index(all_open_orders, tick_index);
        <b>let</b> <b>mut</b> order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(<Link href="../iota-framework/linked_table#0x2_linked_table_front">linked_table::front</Link>(&tick_level.open_orders));

        <b>while</b> (!<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&tick_level.open_orders)) \{
            <b>let</b> maker_order = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(&tick_level.open_orders, order_id);
            <b>let</b> <b>mut</b> maker_base_quantity = maker_order.quantity;
            <b>let</b> <b>mut</b> skip_order = <b>false</b>;

            <b>if</b> (maker_order.expire_timestamp &lt;= current_timestamp) \{
                skip_order = <b>true</b>;
                <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.base_custodian, maker_order.owner, maker_order.quantity);
                <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id, maker_order);
            } <b>else</b> \{
                <b>let</b> filled_base_quantity =
                    <b>if</b> (taker_base_quantity_remaining &gt; maker_base_quantity) \{ maker_base_quantity }
                    <b>else</b> \{ taker_base_quantity_remaining };

                <b>let</b> filled_quote_quantity = clob_math::mul(filled_base_quantity, maker_order.price);

                // <b>if</b> maker_rebate = 0 due <b>to</b> underflow, maker will not receive a rebate
                <b>let</b> maker_rebate = clob_math::unsafe_mul(filled_quote_quantity, pool.maker_rebate_rate);
                // <b>if</b> taker_commission = 0 due <b>to</b> underflow, round it up <b>to</b> 1
                <b>let</b> (is_round_down, <b>mut</b> taker_commission) = clob_math::unsafe_mul_round(
                    filled_quote_quantity,
                    pool.taker_fee_rate
                );
                <b>if</b> (is_round_down) taker_commission = taker_commission + 1;

                maker_base_quantity = maker_base_quantity - filled_base_quantity;

                // maker in ask side, decrease maker's locked base asset, increase maker's available quote asset
                taker_base_quantity_remaining = taker_base_quantity_remaining - filled_base_quantity;
                <b>let</b> locked_base_balance = <Link href="custodian#0xdee9_custodian_decrease_user_locked_balance">custodian::decrease_user_locked_balance</Link>&lt;BaseAsset&gt;(
                    &<b>mut</b> pool.base_custodian,
                    maker_order.owner,
                    filled_base_quantity
                );
                <b>let</b> <b>mut</b> taker_commission_balance = <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                    &<b>mut</b> quote_balance_left,
                    taker_commission,
                );
                <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;QuoteAsset&gt;(
                    &<b>mut</b> pool.quote_custodian,
                    maker_order.owner,
                    <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                        &<b>mut</b> taker_commission_balance,
                        maker_rebate,
                    ),
                );
                <Link href="../iota-framework/balance#0x2_balance_join">balance::join</Link>(&<b>mut</b> pool.quote_asset_trading_fees, taker_commission_balance);
                <Link href="../iota-framework/balance#0x2_balance_join">balance::join</Link>(&<b>mut</b> base_balance_filled, locked_base_balance);

                <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;QuoteAsset&gt;(
                    &<b>mut</b> pool.quote_custodian,
                    maker_order.owner,
                    <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                        &<b>mut</b> quote_balance_left,
                        filled_quote_quantity,
                    ),
                );

                <Link href="clob#0xdee9_clob_emit_order_filled">emit_order_filled</Link>&lt;BaseAsset, QuoteAsset&gt;(
                    *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id),
                    maker_order,
                    filled_base_quantity,
                    taker_commission,
                    maker_rebate
                );
            };

            <b>if</b> (skip_order || maker_base_quantity == 0) \{
                // Remove the maker order.
                <b>let</b> old_order_id = order_id;
                <b>let</b> maybe_order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_next">linked_table::next</Link>(&tick_level.open_orders, order_id);
                <b>if</b> (!<Link href="../move-stdlib/option#0x1_option_is_none">option::is_none</Link>(maybe_order_id)) \{
                    order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(maybe_order_id);
                };
                <b>let</b> usr_open_order_ids = <Link href="../iota-framework/table#0x2_table_borrow_mut">table::borrow_mut</Link>(&<b>mut</b> pool.usr_open_orders, maker_order.owner);
                <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(usr_open_order_ids, old_order_id);
                <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(&<b>mut</b> tick_level.open_orders, old_order_id);
            } <b>else</b> \{
                // Update the maker order.
                <b>let</b> maker_order_mut = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow_mut">linked_table::borrow_mut</Link>(
                    &<b>mut</b> tick_level.open_orders,
                    order_id);
                maker_order_mut.quantity = maker_base_quantity;
            };
            <b>if</b> (taker_base_quantity_remaining == 0) \{
                <b>break</b>
            };
        };
        <b>if</b> (<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&tick_level.open_orders)) \{
            (tick_price, _) = next_leaf(all_open_orders, tick_price);
            <Link href="clob#0xdee9_clob_destroy_empty_level">destroy_empty_level</Link>(remove_leaf_by_index(all_open_orders, tick_index));
            (_, tick_index) = find_leaf(all_open_orders, tick_price);
        };
        <b>if</b> (taker_base_quantity_remaining == 0) \{
            <b>break</b>
        };
    };
    <b>return</b> (base_balance_filled, quote_balance_left)
}
</code></pre>



</details>

<Link id="0xdee9_clob_match_ask"></Link>

## Function `match_ask`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_match_ask">match_ask</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, price_limit: u64, current_timestamp: u64, base_balance: <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;BaseAsset&gt;): (<Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;BaseAsset&gt;, <Link href="../iota-framework/balance#0x2_balance_Balance">balance::Balance</Link>&lt;QuoteAsset&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_match_ask">match_ask</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    price_limit: u64,
    current_timestamp: u64,
    base_balance: Balance&lt;BaseAsset&gt;,
): (Balance&lt;BaseAsset&gt;, Balance&lt;QuoteAsset&gt;) \{
    <b>let</b> pool_id = *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id);
    <b>let</b> <b>mut</b> base_balance_left = base_balance;
    // Base <Link href="../iota-framework/balance#0x2_balance">balance</Link> received by taker, taking into account of taker commission.
    <b>let</b> <b>mut</b> quote_balance_filled = <Link href="../iota-framework/balance#0x2_balance_zero">balance::zero</Link>&lt;QuoteAsset&gt;();
    <b>let</b> all_open_orders = &<b>mut</b> pool.bids;
    <b>if</b> (<Link href="critbit#0xdee9_critbit_is_empty">critbit::is_empty</Link>(all_open_orders)) \{
        <b>return</b> (base_balance_left, quote_balance_filled)
    };
    <b>let</b> (<b>mut</b> tick_price, <b>mut</b> tick_index) = max_leaf(all_open_orders);
    <b>while</b> (!is_empty&lt;<Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>&gt;(all_open_orders) && tick_price &gt;= price_limit) \{
        <b>let</b> tick_level = borrow_mut_leaf_by_index(all_open_orders, tick_index);
        <b>let</b> <b>mut</b> order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(<Link href="../iota-framework/linked_table#0x2_linked_table_front">linked_table::front</Link>(&tick_level.open_orders));
        <b>while</b> (!<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&tick_level.open_orders)) \{
            <b>let</b> maker_order = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(&tick_level.open_orders, order_id);
            <b>let</b> <b>mut</b> maker_base_quantity = maker_order.quantity;
            <b>let</b> <b>mut</b> skip_order = <b>false</b>;

            <b>if</b> (maker_order.expire_timestamp &lt;= current_timestamp) \{
                skip_order = <b>true</b>;
                <b>let</b> maker_quote_quantity = clob_math::mul(maker_order.quantity, maker_order.price);
                <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.quote_custodian, maker_order.owner, maker_quote_quantity);
                <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id, maker_order);
            } <b>else</b> \{
                <b>let</b> taker_base_quantity_remaining = <Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&base_balance_left);
                <b>let</b> filled_base_quantity =
                    <b>if</b> (taker_base_quantity_remaining &gt;= maker_base_quantity) \{ maker_base_quantity }
                    <b>else</b> \{ taker_base_quantity_remaining };

                <b>let</b> filled_quote_quantity = clob_math::mul(filled_base_quantity, maker_order.price);

                // <b>if</b> maker_rebate = 0 due <b>to</b> underflow, maker will not receive a rebate
                <b>let</b> maker_rebate = clob_math::unsafe_mul(filled_quote_quantity, pool.maker_rebate_rate);
                // <b>if</b> taker_commission = 0 due <b>to</b> underflow, round it up <b>to</b> 1
                <b>let</b> (is_round_down, <b>mut</b> taker_commission) = clob_math::unsafe_mul_round(
                    filled_quote_quantity,
                    pool.taker_fee_rate
                );
                <b>if</b> (is_round_down) taker_commission = taker_commission + 1;

                maker_base_quantity = maker_base_quantity - filled_base_quantity;
                // maker in bid side, decrease maker's locked quote asset, increase maker's available base asset
                <b>let</b> <b>mut</b> locked_quote_balance = <Link href="custodian#0xdee9_custodian_decrease_user_locked_balance">custodian::decrease_user_locked_balance</Link>&lt;QuoteAsset&gt;(
                    &<b>mut</b> pool.quote_custodian,
                    maker_order.owner,
                    filled_quote_quantity
                );
                <b>let</b> <b>mut</b> taker_commission_balance = <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                    &<b>mut</b> locked_quote_balance,
                    taker_commission,
                );
                <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;QuoteAsset&gt;(
                    &<b>mut</b> pool.quote_custodian,
                    maker_order.owner,
                    <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                        &<b>mut</b> taker_commission_balance,
                        maker_rebate,
                    ),
                );
                <Link href="../iota-framework/balance#0x2_balance_join">balance::join</Link>(&<b>mut</b> pool.quote_asset_trading_fees, taker_commission_balance);
                <Link href="../iota-framework/balance#0x2_balance_join">balance::join</Link>(&<b>mut</b> quote_balance_filled, locked_quote_balance);

                <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;BaseAsset&gt;(
                    &<b>mut</b> pool.base_custodian,
                    maker_order.owner,
                    <Link href="../iota-framework/balance#0x2_balance_split">balance::split</Link>(
                        &<b>mut</b> base_balance_left,
                        filled_base_quantity,
                    ),
                );

                <Link href="clob#0xdee9_clob_emit_order_filled">emit_order_filled</Link>&lt;BaseAsset, QuoteAsset&gt;(
                    *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id),
                    maker_order,
                    filled_base_quantity,
                    taker_commission,
                    maker_rebate
                );
            };

            <b>if</b> (skip_order || maker_base_quantity == 0) \{
                // Remove the maker order.
                <b>let</b> old_order_id = order_id;
                <b>let</b> maybe_order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_next">linked_table::next</Link>(&tick_level.open_orders, order_id);
                <b>if</b> (!<Link href="../move-stdlib/option#0x1_option_is_none">option::is_none</Link>(maybe_order_id)) \{
                    order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(maybe_order_id);
                };
                <b>let</b> usr_open_order_ids = <Link href="../iota-framework/table#0x2_table_borrow_mut">table::borrow_mut</Link>(&<b>mut</b> pool.usr_open_orders, maker_order.owner);
                <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(usr_open_order_ids, old_order_id);
                <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(&<b>mut</b> tick_level.open_orders, old_order_id);
            } <b>else</b> \{
                // Update the maker order.
                <b>let</b> maker_order_mut = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow_mut">linked_table::borrow_mut</Link>(
                    &<b>mut</b> tick_level.open_orders,
                    order_id);
                maker_order_mut.quantity = maker_base_quantity;
            };
            <b>if</b> (<Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&base_balance_left) == 0) \{
                <b>break</b>
            };
        };
        <b>if</b> (<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&tick_level.open_orders)) \{
            (tick_price, _) = previous_leaf(all_open_orders, tick_price);
            <Link href="clob#0xdee9_clob_destroy_empty_level">destroy_empty_level</Link>(remove_leaf_by_index(all_open_orders, tick_index));
            (_, tick_index) = find_leaf(all_open_orders, tick_price);
        };
        <b>if</b> (<Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&base_balance_left) == 0) \{
            <b>break</b>
        };
    };
    <b>return</b> (base_balance_left, quote_balance_filled)
}
</code></pre>



</details>

<Link id="0xdee9_clob_place_market_order"></Link>

## Function `place_market_order`

Place a market order to the order book.


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_place_market_order">place_market_order</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, quantity: u64, is_bid: bool, base_coin: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;, quote_coin: <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;, <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &<Link href="../iota-framework/clock#0x2_clock_Clock">clock::Clock</Link>, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (<Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;BaseAsset&gt;, <Link href="../iota-framework/coin#0x2_coin_Coin">coin::Coin</Link>&lt;QuoteAsset&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_place_market_order">place_market_order</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    quantity: u64,
    is_bid: bool,
    <b>mut</b> base_coin: Coin&lt;BaseAsset&gt;,
    <b>mut</b> quote_coin: Coin&lt;QuoteAsset&gt;,
    <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &Clock,
    ctx: &<b>mut</b> TxContext,
): (Coin&lt;BaseAsset&gt;, Coin&lt;QuoteAsset&gt;) \{
    // If market bid order, match against the open ask orders. Otherwise, match against the open bid orders.
    // Take market bid order for example.
    // We first retrieve the PriceLevel <b>with</b> the lowest price by calling min_leaf on the asks Critbit Tree.
    // We then match the market order by iterating through open orders on that price level in ascending order of the order id.
    // Open orders that are being filled are removed from the order book.
    // We stop the iteration until all quantities are filled.
    // If the total quantity of open orders at the lowest price level is not large enough <b>to</b> fully fill the market order,
    // we <b>move</b> on <b>to</b> the next price level by calling next_leaf on the asks Critbit Tree and repeat the same procedure.
    // Continue iterating over the price levels in ascending order until the market order is completely filled.
    // If their market order cannot be completely filled even after consuming all the open ask orders,
    // the unfilled quantity will be cancelled.
    // Market ask order follows similar procedure.
    // The difference is that market ask order is matched against the open bid orders.
    // We start <b>with</b> the bid PriceLeve <b>with</b> the highest price by calling max_leaf on the bids Critbit Tree.
    // The inner <b>loop</b> for iterating over the open orders in ascending orders of order id is the same <b>as</b> above.
    // Then iterate over the price levels in descending order until the market order is completely filled.
    <b>assert</b>!(quantity % pool.lot_size == 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <b>assert</b>!(quantity != 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <b>if</b> (is_bid) \{
        <b>let</b> (base_balance_filled, quote_balance_left) = <Link href="clob#0xdee9_clob_match_bid">match_bid</Link>(
            pool,
            quantity,
            <Link href="clob#0xdee9_clob_MAX_PRICE">MAX_PRICE</Link>,
            <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>),
            <Link href="../iota-framework/coin#0x2_coin_into_balance">coin::into_balance</Link>(quote_coin),
        );
        join(
            &<b>mut</b> base_coin,
            <Link href="../iota-framework/coin#0x2_coin_from_balance">coin::from_balance</Link>(base_balance_filled, ctx),
        );
        quote_coin = <Link href="../iota-framework/coin#0x2_coin_from_balance">coin::from_balance</Link>(quote_balance_left, ctx);
    } <b>else</b> \{
        <b>assert</b>!(quantity &lt;= <Link href="../iota-framework/coin#0x2_coin_value">coin::value</Link>(&base_coin), <Link href="clob#0xdee9_clob_EInsufficientBaseCoin">EInsufficientBaseCoin</Link>);
        <b>let</b> (base_balance_left, quote_balance_filled) = <Link href="clob#0xdee9_clob_match_ask">match_ask</Link>(
            pool,
            <Link href="clob#0xdee9_clob_MIN_PRICE">MIN_PRICE</Link>,
            <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>),
            <Link href="../iota-framework/coin#0x2_coin_into_balance">coin::into_balance</Link>(base_coin),
        );
        base_coin = <Link href="../iota-framework/coin#0x2_coin_from_balance">coin::from_balance</Link>(base_balance_left, ctx);
        join(
            &<b>mut</b> quote_coin,
            <Link href="../iota-framework/coin#0x2_coin_from_balance">coin::from_balance</Link>(quote_balance_filled, ctx),
        );
    };
    (base_coin, quote_coin)
}
</code></pre>



</details>

<Link id="0xdee9_clob_inject_limit_order"></Link>

## Function `inject_limit_order`

Injects a maker order to the order book.
Returns the order id.


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_inject_limit_order">inject_limit_order</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, price: u64, quantity: u64, is_bid: bool, expire_timestamp: u64, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_inject_limit_order">inject_limit_order</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    price: u64,
    quantity: u64,
    is_bid: bool,
    expire_timestamp: u64,
    account_cap: &AccountCap,
    ctx: &<b>mut</b> TxContext
): u64 \{
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>let</b> order_id: u64;
    <b>let</b> open_orders: &<b>mut</b> CritbitTree&lt;<Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>&gt;;
    <b>if</b> (is_bid) \{
        <b>let</b> quote_quantity = clob_math::mul(quantity, price);
        <Link href="custodian#0xdee9_custodian_lock_balance">custodian::lock_balance</Link>&lt;QuoteAsset&gt;(&<b>mut</b> pool.quote_custodian, account_cap, quote_quantity);
        order_id = pool.next_bid_order_id;
        pool.next_bid_order_id = pool.next_bid_order_id + 1;
        open_orders = &<b>mut</b> pool.bids;
    } <b>else</b> \{
        <Link href="custodian#0xdee9_custodian_lock_balance">custodian::lock_balance</Link>&lt;BaseAsset&gt;(&<b>mut</b> pool.base_custodian, account_cap, quantity);
        order_id = pool.next_ask_order_id;
        pool.next_ask_order_id = pool.next_ask_order_id + 1;
        open_orders = &<b>mut</b> pool.asks;
    };
    <b>let</b> order = <Link href="clob#0xdee9_clob_Order">Order</Link> \{
        order_id,
        price,
        quantity,
        is_bid,
        owner: user,
        expire_timestamp,
    };
    <b>let</b> (tick_exists, <b>mut</b> tick_index) = find_leaf(open_orders, price);
    <b>if</b> (!tick_exists) \{
        tick_index = insert_leaf(
            open_orders,
            price,
            <Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link> \{
                price,
                open_orders: <Link href="../iota-framework/linked_table#0x2_linked_table_new">linked_table::new</Link>(ctx),
            });
    };

    <b>let</b> tick_level = borrow_mut_leaf_by_index(open_orders, tick_index);
    <Link href="../iota-framework/linked_table#0x2_linked_table_push_back">linked_table::push_back</Link>(&<b>mut</b> tick_level.open_orders, order_id, order);
    <Link href="../iota-framework/event#0x2_event_emit">event::emit</Link>(<Link href="clob#0xdee9_clob_OrderPlacedV2">OrderPlacedV2</Link>&lt;BaseAsset, QuoteAsset&gt; \{
        pool_id: *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id),
        order_id,
        is_bid,
        owner: user,
        base_asset_quantity_placed: quantity,
        price,
        expire_timestamp
    });
    <b>if</b> (!contains(&pool.usr_open_orders, user)) \{
        add(&<b>mut</b> pool.usr_open_orders, user, <Link href="../iota-framework/linked_table#0x2_linked_table_new">linked_table::new</Link>(ctx));
    };
    <Link href="../iota-framework/linked_table#0x2_linked_table_push_back">linked_table::push_back</Link>(borrow_mut(&<b>mut</b> pool.usr_open_orders, user), order_id, price);

    <b>return</b> order_id
}
</code></pre>



</details>

<Link id="0xdee9_clob_place_limit_order"></Link>

## Function `place_limit_order`

Place a limit order to the order book.
Returns (base quantity filled, quote quantity filled, whether a maker order is being placed, order id of the maker order).
When the limit order is not successfully placed, we return false to indicate that and also returns a meaningless order_id 0.
When the limit order is successfully placed, we return true to indicate that and also the corresponding order_id.
So please check that boolean value first before using the order id.


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_place_limit_order">place_limit_order</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, price: u64, quantity: u64, is_bid: bool, expire_timestamp: u64, restriction: u8, <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &<Link href="../iota-framework/clock#0x2_clock_Clock">clock::Clock</Link>, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>, ctx: &<b>mut</b> <Link href="../iota-framework/tx_context#0x2_tx_context_TxContext">tx_context::TxContext</Link>): (u64, u64, bool, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_place_limit_order">place_limit_order</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    price: u64,
    quantity: u64,
    is_bid: bool,
    expire_timestamp: u64, // Expiration timestamp in ms in absolute value inclusive.
    restriction: u8,
    <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &Clock,
    account_cap: &AccountCap,
    ctx: &<b>mut</b> TxContext
): (u64, u64, bool, u64) \{
    // If limit bid order, check whether the price is lower than the lowest ask order by checking the min_leaf of asks Critbit Tree.
    // If so, assign the sequence id of the order <b>to</b> be next_bid_order_id and increment next_bid_order_id by 1.
    // Inject the new order <b>to</b> the bids Critbit Tree according <b>to</b> the price and order id.
    // Otherwise, find the price level from the asks Critbit Tree that is no greater than the input price.
    // Match the bid order against the asks Critbit Tree in the same way <b>as</b> a market order but up until the price level found in the previous step.
    // If the bid order is not completely filled, inject the remaining quantity <b>to</b> the bids Critbit Tree according <b>to</b> the input price and order id.
    // If limit ask order, vice versa.
    <b>assert</b>!(quantity &gt; 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <b>assert</b>!(price &gt; 0, <Link href="clob#0xdee9_clob_EInvalidPrice">EInvalidPrice</Link>);
    <b>assert</b>!(price % pool.tick_size == 0, <Link href="clob#0xdee9_clob_EInvalidPrice">EInvalidPrice</Link>);
    <b>assert</b>!(quantity % pool.lot_size == 0, <Link href="clob#0xdee9_clob_EInvalidQuantity">EInvalidQuantity</Link>);
    <b>assert</b>!(expire_timestamp &gt; <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>), <Link href="clob#0xdee9_clob_EInvalidExpireTimestamp">EInvalidExpireTimestamp</Link>);
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>let</b> base_quantity_filled;
    <b>let</b> quote_quantity_filled;

    <b>if</b> (is_bid) \{
        <b>let</b> quote_quantity_original = <Link href="custodian#0xdee9_custodian_account_available_balance">custodian::account_available_balance</Link>&lt;QuoteAsset&gt;(
            &pool.quote_custodian,
            user,
        );
        <b>let</b> quote_balance = <Link href="custodian#0xdee9_custodian_decrease_user_available_balance">custodian::decrease_user_available_balance</Link>&lt;QuoteAsset&gt;(
            &<b>mut</b> pool.quote_custodian,
            account_cap,
            quote_quantity_original,
        );
        <b>let</b> (base_balance_filled, quote_balance_left) = <Link href="clob#0xdee9_clob_match_bid">match_bid</Link>(
            pool,
            quantity,
            price,
            <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>),
            quote_balance,
        );
        base_quantity_filled = <Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&base_balance_filled);
        quote_quantity_filled = quote_quantity_original - <Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&quote_balance_left);

        <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;BaseAsset&gt;(
            &<b>mut</b> pool.base_custodian,
            user,
            base_balance_filled,
        );
        <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;QuoteAsset&gt;(
            &<b>mut</b> pool.quote_custodian,
            user,
            quote_balance_left,
        );
    } <b>else</b> \{
        <b>let</b> base_balance = <Link href="custodian#0xdee9_custodian_decrease_user_available_balance">custodian::decrease_user_available_balance</Link>&lt;BaseAsset&gt;(
            &<b>mut</b> pool.base_custodian,
            account_cap,
            quantity,
        );
        <b>let</b> (base_balance_left, quote_balance_filled) = <Link href="clob#0xdee9_clob_match_ask">match_ask</Link>(
            pool,
            price,
            <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>),
            base_balance,
        );

        base_quantity_filled = quantity - <Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&base_balance_left);
        quote_quantity_filled = <Link href="../iota-framework/balance#0x2_balance_value">balance::value</Link>(&quote_balance_filled);

        <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;BaseAsset&gt;(
            &<b>mut</b> pool.base_custodian,
            user,
            base_balance_left,
        );
        <Link href="custodian#0xdee9_custodian_increase_user_available_balance">custodian::increase_user_available_balance</Link>&lt;QuoteAsset&gt;(
            &<b>mut</b> pool.quote_custodian,
            user,
            quote_balance_filled,
        );
    };

    <b>let</b> order_id;
    <b>if</b> (restriction == <Link href="clob#0xdee9_clob_IMMEDIATE_OR_CANCEL">IMMEDIATE_OR_CANCEL</Link>) \{
        <b>return</b> (base_quantity_filled, quote_quantity_filled, <b>false</b>, 0)
    };
    <b>if</b> (restriction == <Link href="clob#0xdee9_clob_FILL_OR_KILL">FILL_OR_KILL</Link>) \{
        <b>assert</b>!(base_quantity_filled == quantity, <Link href="clob#0xdee9_clob_EOrderCannotBeFullyFilled">EOrderCannotBeFullyFilled</Link>);
        <b>return</b> (base_quantity_filled, quote_quantity_filled, <b>false</b>, 0)
    };
    <b>if</b> (restriction == <Link href="clob#0xdee9_clob_POST_OR_ABORT">POST_OR_ABORT</Link>) \{
        <b>assert</b>!(base_quantity_filled == 0, <Link href="clob#0xdee9_clob_EOrderCannotBeFullyPassive">EOrderCannotBeFullyPassive</Link>);
        order_id = <Link href="clob#0xdee9_clob_inject_limit_order">inject_limit_order</Link>(pool, price, quantity, is_bid, expire_timestamp, account_cap, ctx);
        <b>return</b> (base_quantity_filled, quote_quantity_filled, <b>true</b>, order_id)
    } <b>else</b> \{
        <b>assert</b>!(restriction == <Link href="clob#0xdee9_clob_NO_RESTRICTION">NO_RESTRICTION</Link>, <Link href="clob#0xdee9_clob_EInvalidRestriction">EInvalidRestriction</Link>);
        <b>if</b> (quantity &gt; base_quantity_filled) \{
            order_id = <Link href="clob#0xdee9_clob_inject_limit_order">inject_limit_order</Link>(
                pool,
                price,
                quantity - base_quantity_filled,
                is_bid,
                expire_timestamp,
                account_cap,
                ctx
            );
            <b>return</b> (base_quantity_filled, quote_quantity_filled, <b>true</b>, order_id)
        };
        <b>return</b> (base_quantity_filled, quote_quantity_filled, <b>false</b>, 0)
    }
}
</code></pre>



</details>

<Link id="0xdee9_clob_order_is_bid"></Link>

## Function `order_is_bid`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_order_is_bid">order_is_bid</Link>(order_id: u64): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_order_is_bid">order_is_bid</Link>(order_id: u64): bool \{
    <b>return</b> order_id &lt; <Link href="clob#0xdee9_clob_MIN_ASK_ORDER_ID">MIN_ASK_ORDER_ID</Link>
}
</code></pre>



</details>

<Link id="0xdee9_clob_emit_order_canceled"></Link>

## Function `emit_order_canceled`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link>, order: &<Link href="clob#0xdee9_clob_Order">clob::Order</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool_id: ID,
    order: &<Link href="clob#0xdee9_clob_Order">Order</Link>
) \{
    <Link href="../iota-framework/event#0x2_event_emit">event::emit</Link>(<Link href="clob#0xdee9_clob_OrderCanceled">OrderCanceled</Link>&lt;BaseAsset, QuoteAsset&gt; \{
        pool_id,
        order_id: order.order_id,
        is_bid: order.is_bid,
        owner: order.owner,
        base_asset_quantity_canceled: order.quantity,
        price: order.price
    })
}
</code></pre>



</details>

<Link id="0xdee9_clob_emit_order_filled"></Link>

## Function `emit_order_filled`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_emit_order_filled">emit_order_filled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link>, order: &<Link href="clob#0xdee9_clob_Order">clob::Order</Link>, base_asset_quantity_filled: u64, taker_commission: u64, maker_rebates: u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_emit_order_filled">emit_order_filled</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool_id: ID,
    order: &<Link href="clob#0xdee9_clob_Order">Order</Link>,
    base_asset_quantity_filled: u64,
    taker_commission: u64,
    maker_rebates: u64
) \{
    <Link href="../iota-framework/event#0x2_event_emit">event::emit</Link>(<Link href="clob#0xdee9_clob_OrderFilledV2">OrderFilledV2</Link>&lt;BaseAsset, QuoteAsset&gt; \{
        pool_id,
        order_id: order.order_id,
        is_bid: order.is_bid,
        owner: order.owner,
        total_quantity: order.quantity,
        base_asset_quantity_filled,
        // order.quantity = base_asset_quantity_filled + base_asset_quantity_remaining
        // This guarantees that the subtraction will not underflow
        base_asset_quantity_remaining: order.quantity - base_asset_quantity_filled,
        price: order.price,
        taker_commission,
        maker_rebates
    })
}
</code></pre>



</details>

<Link id="0xdee9_clob_cancel_order"></Link>

## Function `cancel_order`

Cancel and opening order.
Abort if order_id is invalid or if the order is not submitted by the transaction sender.


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_cancel_order">cancel_order</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, order_id: u64, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_cancel_order">cancel_order</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    order_id: u64,
    account_cap: &AccountCap
) \{
    // First check the highest bit of the order id <b>to</b> see whether it's bid or ask.
    // Then retrieve the price using the order id.
    // Using the price <b>to</b> retrieve the corresponding PriceLevel from the bids / asks Critbit Tree.
    // Retrieve and remove the order from open orders of the PriceLevel.
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>assert</b>!(contains(&pool.usr_open_orders, user), <Link href="clob#0xdee9_clob_EInvalidUser">EInvalidUser</Link>);
    <b>let</b> usr_open_orders = borrow_mut(&<b>mut</b> pool.usr_open_orders, user);
    <b>assert</b>!(<Link href="../iota-framework/linked_table#0x2_linked_table_contains">linked_table::contains</Link>(usr_open_orders, order_id), <Link href="clob#0xdee9_clob_EInvalidOrderId">EInvalidOrderId</Link>);
    <b>let</b> tick_price = *<Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(usr_open_orders, order_id);
    <b>let</b> is_bid = <Link href="clob#0xdee9_clob_order_is_bid">order_is_bid</Link>(order_id);
    <b>let</b> (tick_exists, tick_index) = find_leaf(
        <b>if</b> (is_bid) \{ &pool.bids } <b>else</b> \{ &pool.asks },
        tick_price);
    <b>assert</b>!(tick_exists, <Link href="clob#0xdee9_clob_EInvalidOrderId">EInvalidOrderId</Link>);
    <b>let</b> order = <Link href="clob#0xdee9_clob_remove_order">remove_order</Link>(
        <b>if</b> (is_bid) \{ &<b>mut</b> pool.bids } <b>else</b> \{ &<b>mut</b> pool.asks },
        usr_open_orders,
        tick_index,
        order_id,
        user
    );
    <b>if</b> (is_bid) \{
        <b>let</b> balance_locked = clob_math::mul(order.quantity, order.price);
        <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.quote_custodian, user, balance_locked);
    } <b>else</b> \{
        <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.base_custodian, user, order.quantity);
    };
    <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(*<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id), &order);
}
</code></pre>



</details>

<Link id="0xdee9_clob_remove_order"></Link>

## Function `remove_order`



<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_remove_order">remove_order</Link>(open_orders: &<b>mut</b> <Link href="critbit#0xdee9_critbit_CritbitTree">critbit::CritbitTree</Link>&lt;<Link href="clob#0xdee9_clob_TickLevel">clob::TickLevel</Link>&gt;, usr_open_orders: &<b>mut</b> <Link href="../iota-framework/linked_table#0x2_linked_table_LinkedTable">linked_table::LinkedTable</Link>&lt;u64, u64&gt;, tick_index: u64, order_id: u64, user: <Link href="../iota-framework/object#0x2_object_ID">object::ID</Link>): <Link href="clob#0xdee9_clob_Order">clob::Order</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_remove_order">remove_order</Link>(
    open_orders: &<b>mut</b> CritbitTree&lt;<Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>&gt;,
    usr_open_orders: &<b>mut</b> LinkedTable&lt;u64, u64&gt;,
    tick_index: u64,
    order_id: u64,
    user: ID,
): <Link href="clob#0xdee9_clob_Order">Order</Link> \{
    <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(usr_open_orders, order_id);
    <b>let</b> tick_level = borrow_leaf_by_index(open_orders, tick_index);
    <b>assert</b>!(<Link href="../iota-framework/linked_table#0x2_linked_table_contains">linked_table::contains</Link>(&tick_level.open_orders, order_id), <Link href="clob#0xdee9_clob_EInvalidOrderId">EInvalidOrderId</Link>);
    <b>let</b> mut_tick_level = borrow_mut_leaf_by_index(open_orders, tick_index);
    <b>let</b> order = <Link href="../iota-framework/linked_table#0x2_linked_table_remove">linked_table::remove</Link>(&<b>mut</b> mut_tick_level.open_orders, order_id);
    <b>assert</b>!(order.owner == user, <Link href="clob#0xdee9_clob_EUnauthorizedCancel">EUnauthorizedCancel</Link>);
    <b>if</b> (<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(&mut_tick_level.open_orders)) \{
        <Link href="clob#0xdee9_clob_destroy_empty_level">destroy_empty_level</Link>(remove_leaf_by_index(open_orders, tick_index));
    };
    order
}
</code></pre>



</details>

<Link id="0xdee9_clob_cancel_all_orders"></Link>

## Function `cancel_all_orders`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_cancel_all_orders">cancel_all_orders</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_cancel_all_orders">cancel_all_orders</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    account_cap: &AccountCap
) \{
    <b>let</b> pool_id = *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id);
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>assert</b>!(contains(&pool.usr_open_orders, user), <Link href="clob#0xdee9_clob_EInvalidUser">EInvalidUser</Link>);
    <b>let</b> usr_open_order_ids = <Link href="../iota-framework/table#0x2_table_borrow_mut">table::borrow_mut</Link>(&<b>mut</b> pool.usr_open_orders, user);
    <b>while</b> (!<Link href="../iota-framework/linked_table#0x2_linked_table_is_empty">linked_table::is_empty</Link>(usr_open_order_ids)) \{
        <b>let</b> order_id = *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(<Link href="../iota-framework/linked_table#0x2_linked_table_back">linked_table::back</Link>(usr_open_order_ids));
        <b>let</b> order_price = *<Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(usr_open_order_ids, order_id);
        <b>let</b> is_bid = <Link href="clob#0xdee9_clob_order_is_bid">order_is_bid</Link>(order_id);
        <b>let</b> open_orders =
            <b>if</b> (is_bid) \{ &<b>mut</b> pool.bids }
            <b>else</b> \{ &<b>mut</b> pool.asks };
        <b>let</b> (_, tick_index) = <Link href="critbit#0xdee9_critbit_find_leaf">critbit::find_leaf</Link>(open_orders, order_price);
        <b>let</b> order = <Link href="clob#0xdee9_clob_remove_order">remove_order</Link>(
            open_orders,
            usr_open_order_ids,
            tick_index,
            order_id,
            user
        );
        <b>if</b> (is_bid) \{
            <b>let</b> balance_locked = clob_math::mul(order.quantity, order.price);
            <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.quote_custodian, user, balance_locked);
        } <b>else</b> \{
            <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.base_custodian, user, order.quantity);
        };
        <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id, &order);
    };
}
</code></pre>



</details>

<Link id="0xdee9_clob_batch_cancel_order"></Link>

## Function `batch_cancel_order`

Batch cancel limit orders to save gas cost.
Abort if any of the order_ids are not submitted by the sender.
Skip any order_id that is invalid.
Note that this function can reduce gas cost even further if caller has multiple orders at the same price level,
and if orders with the same price are grouped together in the vector.
For example, if we have the following order_id to price mapping, \{0: 100., 1: 200., 2: 100., 3: 200.}.
Grouping order_ids like [0, 2, 1, 3] would make it the most gas efficient.


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_batch_cancel_order">batch_cancel_order</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, order_ids: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_batch_cancel_order">batch_cancel_order</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<b>mut</b> <Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    order_ids: <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;,
    account_cap: &AccountCap
) \{
    <b>let</b> pool_id = *<Link href="../iota-framework/object#0x2_object_uid_as_inner">object::uid_as_inner</Link>(&pool.id);
    // First group the order ids according <b>to</b> price level,
    // so that we don't have <b>to</b> retrieve the PriceLevel multiple times <b>if</b> there are orders at the same price level.
    // Iterate over each price level, retrieve the corresponding PriceLevel.
    // Iterate over the order ids that need <b>to</b> be canceled at that price level,
    // retrieve and remove the order from open orders of the PriceLevel.
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>assert</b>!(contains(&pool.usr_open_orders, user), 0);
    <b>let</b> <b>mut</b> tick_index: u64 = 0;
    <b>let</b> <b>mut</b> tick_price: u64 = 0;
    <b>let</b> n_order = <Link href="../move-stdlib/vector#0x1_vector_length">vector::length</Link>(&order_ids);
    <b>let</b> <b>mut</b> i_order = 0;
    <b>let</b> usr_open_orders = borrow_mut(&<b>mut</b> pool.usr_open_orders, user);
    <b>while</b> (i_order &lt; n_order) \{
        <b>let</b> order_id = *<Link href="../move-stdlib/vector#0x1_vector_borrow">vector::borrow</Link>(&order_ids, i_order);
        <b>assert</b>!(<Link href="../iota-framework/linked_table#0x2_linked_table_contains">linked_table::contains</Link>(usr_open_orders, order_id), <Link href="clob#0xdee9_clob_EInvalidOrderId">EInvalidOrderId</Link>);
        <b>let</b> new_tick_price = *<Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(usr_open_orders, order_id);
        <b>let</b> is_bid = <Link href="clob#0xdee9_clob_order_is_bid">order_is_bid</Link>(order_id);
        <b>if</b> (new_tick_price != tick_price) \{
            tick_price = new_tick_price;
            <b>let</b> (tick_exists, new_tick_index) = find_leaf(
                <b>if</b> (is_bid) \{ &pool.bids } <b>else</b> \{ &pool.asks },
                tick_price
            );
            <b>assert</b>!(tick_exists, <Link href="clob#0xdee9_clob_EInvalidTickPrice">EInvalidTickPrice</Link>);
            tick_index = new_tick_index;
        };
        <b>let</b> order = <Link href="clob#0xdee9_clob_remove_order">remove_order</Link>(
            <b>if</b> (is_bid) \{ &<b>mut</b> pool.bids } <b>else</b> \{ &<b>mut</b> pool.asks },
            usr_open_orders,
            tick_index,
            order_id,
            user
        );
        <b>if</b> (is_bid) \{
            <b>let</b> balance_locked = clob_math::mul(order.quantity, order.price);
            <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.quote_custodian, user, balance_locked);
        } <b>else</b> \{
            <Link href="custodian#0xdee9_custodian_unlock_balance">custodian::unlock_balance</Link>(&<b>mut</b> pool.base_custodian, user, order.quantity);
        };
        <Link href="clob#0xdee9_clob_emit_order_canceled">emit_order_canceled</Link>&lt;BaseAsset, QuoteAsset&gt;(pool_id, &order);
        i_order = i_order + 1;
    }
}
</code></pre>



</details>

<Link id="0xdee9_clob_list_open_orders"></Link>

## Function `list_open_orders`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_list_open_orders">list_open_orders</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="clob#0xdee9_clob_Order">clob::Order</Link>&gt;
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_list_open_orders">list_open_orders</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    account_cap: &AccountCap
): <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;<Link href="clob#0xdee9_clob_Order">Order</Link>&gt; \{
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>let</b> usr_open_order_ids = <Link href="../iota-framework/table#0x2_table_borrow">table::borrow</Link>(&pool.usr_open_orders, user);
    <b>let</b> <b>mut</b> open_orders = <Link href="../move-stdlib/vector#0x1_vector_empty">vector::empty</Link>&lt;<Link href="clob#0xdee9_clob_Order">Order</Link>&gt;();
    <b>let</b> <b>mut</b> order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_front">linked_table::front</Link>(usr_open_order_ids);
    <b>while</b> (!<Link href="../move-stdlib/option#0x1_option_is_none">option::is_none</Link>(order_id)) \{
        <b>let</b> order_price = *<Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(usr_open_order_ids, *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(order_id));
        <b>let</b> tick_level =
            <b>if</b> (<Link href="clob#0xdee9_clob_order_is_bid">order_is_bid</Link>(*<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(order_id))) borrow_leaf_by_key(&pool.bids, order_price)
            <b>else</b> borrow_leaf_by_key(&pool.asks, order_price);
        <b>let</b> order = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(&tick_level.open_orders, *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(order_id));
        <Link href="../move-stdlib/vector#0x1_vector_push_back">vector::push_back</Link>(&<b>mut</b> open_orders, <Link href="clob#0xdee9_clob_Order">Order</Link> \{
            order_id: order.order_id,
            price: order.price,
            quantity: order.quantity,
            is_bid: order.is_bid,
            owner: order.owner,
            expire_timestamp: order.expire_timestamp
        });
        order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_next">linked_table::next</Link>(usr_open_order_ids, *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(order_id));
    };
    open_orders
}
</code></pre>



</details>

<Link id="0xdee9_clob_account_balance"></Link>

## Function `account_balance`

query user balance inside custodian


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_account_balance">account_balance</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>): (u64, u64, u64, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_account_balance">account_balance</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    account_cap: &AccountCap
): (u64, u64, u64, u64) \{
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>let</b> (base_avail, base_locked) = <Link href="custodian#0xdee9_custodian_account_balance">custodian::account_balance</Link>(&pool.base_custodian, user);
    <b>let</b> (quote_avail, quote_locked) = <Link href="custodian#0xdee9_custodian_account_balance">custodian::account_balance</Link>(&pool.quote_custodian, user);
    (base_avail, base_locked, quote_avail, quote_locked)
}
</code></pre>



</details>

<Link id="0xdee9_clob_get_market_price"></Link>

## Function `get_market_price`

Query the market price of order book
returns (best_bid_price, best_ask_price)


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_market_price">get_market_price</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;): (u64, u64)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_market_price">get_market_price</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;
): (u64, u64)\{
    <b>let</b> (bid_price, _) = <Link href="critbit#0xdee9_critbit_max_leaf">critbit::max_leaf</Link>(&pool.bids);
    <b>let</b> (ask_price, _) = <Link href="critbit#0xdee9_critbit_min_leaf">critbit::min_leaf</Link>(&pool.asks);
    <b>return</b> (bid_price, ask_price)
}
</code></pre>



</details>

<Link id="0xdee9_clob_get_level2_book_status_bid_side"></Link>

## Function `get_level2_book_status_bid_side`

Enter a price range and return the level2 order depth of all valid prices within this price range in bid side
returns two vectors of u64
The previous is a list of all valid prices
The latter is the corresponding depth list


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_level2_book_status_bid_side">get_level2_book_status_bid_side</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, price_low: u64, price_high: u64, <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &<Link href="../iota-framework/clock#0x2_clock_Clock">clock::Clock</Link>): (<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_level2_book_status_bid_side">get_level2_book_status_bid_side</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    <b>mut</b> price_low: u64,
    <b>mut</b> price_high: u64,
    <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &Clock
): (<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;) \{
    <b>let</b> (price_low_, _) = <Link href="critbit#0xdee9_critbit_min_leaf">critbit::min_leaf</Link>(&pool.bids);
    <b>if</b> (price_low &lt; price_low_) price_low = price_low_;
    <b>let</b> (price_high_, _) = <Link href="critbit#0xdee9_critbit_max_leaf">critbit::max_leaf</Link>(&pool.bids);
    <b>if</b> (price_high &gt; price_high_) price_high = price_high_;
    price_low = <Link href="critbit#0xdee9_critbit_find_closest_key">critbit::find_closest_key</Link>(&pool.bids, price_low);
    price_high = <Link href="critbit#0xdee9_critbit_find_closest_key">critbit::find_closest_key</Link>(&pool.bids, price_high);
    <b>let</b> <b>mut</b> price_vec = <Link href="../move-stdlib/vector#0x1_vector_empty">vector::empty</Link>&lt;u64&gt;();
    <b>let</b> <b>mut</b> depth_vec = <Link href="../move-stdlib/vector#0x1_vector_empty">vector::empty</Link>&lt;u64&gt;();
    <b>if</b> (price_low == 0) \{ <b>return</b> (price_vec, depth_vec) };
    <b>while</b> (price_low &lt;= price_high) \{
        <b>let</b> depth = <Link href="clob#0xdee9_clob_get_level2_book_status">get_level2_book_status</Link>(
            &pool.bids,
            price_low,
            <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>)
        );
        <Link href="../move-stdlib/vector#0x1_vector_push_back">vector::push_back</Link>(&<b>mut</b> price_vec, price_low);
        <Link href="../move-stdlib/vector#0x1_vector_push_back">vector::push_back</Link>(&<b>mut</b> depth_vec, depth);
        <b>let</b> (next_price, _) = <Link href="critbit#0xdee9_critbit_next_leaf">critbit::next_leaf</Link>(&pool.bids, price_low);
        <b>if</b> (next_price == 0) \{ <b>break</b> }
        <b>else</b> \{ price_low = next_price };
    };
    (price_vec, depth_vec)
}
</code></pre>



</details>

<Link id="0xdee9_clob_get_level2_book_status_ask_side"></Link>

## Function `get_level2_book_status_ask_side`

Enter a price range and return the level2 order depth of all valid prices within this price range in ask side
returns two vectors of u64
The previous is a list of all valid prices
The latter is the corresponding depth list


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_level2_book_status_ask_side">get_level2_book_status_ask_side</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, price_low: u64, price_high: u64, <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &<Link href="../iota-framework/clock#0x2_clock_Clock">clock::Clock</Link>): (<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;)
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_level2_book_status_ask_side">get_level2_book_status_ask_side</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    <b>mut</b> price_low: u64,
    <b>mut</b> price_high: u64,
    <Link href="../iota-framework/clock#0x2_clock">clock</Link>: &Clock
): (<Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;, <Link href="../move-stdlib/vector#0x1_vector">vector</Link>&lt;u64&gt;) \{
    <b>let</b> (price_low_, _) = <Link href="critbit#0xdee9_critbit_min_leaf">critbit::min_leaf</Link>(&pool.asks);
    <b>if</b> (price_low &lt; price_low_) price_low = price_low_;
    <b>let</b> (price_high_, _) = <Link href="critbit#0xdee9_critbit_max_leaf">critbit::max_leaf</Link>(&pool.asks);
    <b>if</b> (price_high &gt; price_high_) price_high = price_high_;
    price_low = <Link href="critbit#0xdee9_critbit_find_closest_key">critbit::find_closest_key</Link>(&pool.asks, price_low);
    price_high = <Link href="critbit#0xdee9_critbit_find_closest_key">critbit::find_closest_key</Link>(&pool.asks, price_high);
    <b>let</b> <b>mut</b> price_vec = <Link href="../move-stdlib/vector#0x1_vector_empty">vector::empty</Link>&lt;u64&gt;();
    <b>let</b> <b>mut</b> depth_vec = <Link href="../move-stdlib/vector#0x1_vector_empty">vector::empty</Link>&lt;u64&gt;();
    <b>if</b> (price_low == 0) \{ <b>return</b> (price_vec, depth_vec) };
    <b>while</b> (price_low &lt;= price_high) \{
        <b>let</b> depth = <Link href="clob#0xdee9_clob_get_level2_book_status">get_level2_book_status</Link>(
            &pool.asks,
            price_low,
            <Link href="../iota-framework/clock#0x2_clock_timestamp_ms">clock::timestamp_ms</Link>(<Link href="../iota-framework/clock#0x2_clock">clock</Link>)
        );
        <Link href="../move-stdlib/vector#0x1_vector_push_back">vector::push_back</Link>(&<b>mut</b> price_vec, price_low);
        <Link href="../move-stdlib/vector#0x1_vector_push_back">vector::push_back</Link>(&<b>mut</b> depth_vec, depth);
        <b>let</b> (next_price, _) = <Link href="critbit#0xdee9_critbit_next_leaf">critbit::next_leaf</Link>(&pool.asks, price_low);
        <b>if</b> (next_price == 0) \{ <b>break</b> }
        <b>else</b> \{ price_low = next_price };
    };
    (price_vec, depth_vec)
}
</code></pre>



</details>

<Link id="0xdee9_clob_get_level2_book_status"></Link>

## Function `get_level2_book_status`

internal func to retrieve single depth of a tick price


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_get_level2_book_status">get_level2_book_status</Link>(open_orders: &<Link href="critbit#0xdee9_critbit_CritbitTree">critbit::CritbitTree</Link>&lt;<Link href="clob#0xdee9_clob_TickLevel">clob::TickLevel</Link>&gt;, price: u64, time_stamp: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>fun</b> <Link href="clob#0xdee9_clob_get_level2_book_status">get_level2_book_status</Link>(
    open_orders: &CritbitTree&lt;<Link href="clob#0xdee9_clob_TickLevel">TickLevel</Link>&gt;,
    price: u64,
    time_stamp: u64
): u64 \{
    <b>let</b> tick_level = <Link href="critbit#0xdee9_critbit_borrow_leaf_by_key">critbit::borrow_leaf_by_key</Link>(open_orders, price);
    <b>let</b> tick_open_orders = &tick_level.open_orders;
    <b>let</b> <b>mut</b> depth = 0;
    <b>let</b> <b>mut</b> order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_front">linked_table::front</Link>(tick_open_orders);
    <b>let</b> <b>mut</b> order: &<Link href="clob#0xdee9_clob_Order">Order</Link>;
    <b>while</b> (!<Link href="../move-stdlib/option#0x1_option_is_none">option::is_none</Link>(order_id)) \{
        order = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(tick_open_orders, *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(order_id));
        <b>if</b> (order.expire_timestamp &gt; time_stamp) depth = depth + order.quantity;
        order_id = <Link href="../iota-framework/linked_table#0x2_linked_table_next">linked_table::next</Link>(tick_open_orders, *<Link href="../move-stdlib/option#0x1_option_borrow">option::borrow</Link>(order_id));
    };
    depth
}
</code></pre>



</details>

<Link id="0xdee9_clob_get_order_status"></Link>

## Function `get_order_status`



<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_order_status">get_order_status</Link>&lt;BaseAsset, QuoteAsset&gt;(pool: &<Link href="clob#0xdee9_clob_Pool">clob::Pool</Link>&lt;BaseAsset, QuoteAsset&gt;, order_id: u64, account_cap: &<Link href="custodian#0xdee9_custodian_AccountCap">custodian::AccountCap</Link>): &<Link href="clob#0xdee9_clob_Order">clob::Order</Link>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>
<b>public</b> <b>fun</b> <Link href="clob#0xdee9_clob_get_order_status">get_order_status</Link>&lt;BaseAsset, QuoteAsset&gt;(
    pool: &<Link href="clob#0xdee9_clob_Pool">Pool</Link>&lt;BaseAsset, QuoteAsset&gt;,
    order_id: u64,
    account_cap: &AccountCap
): &<Link href="clob#0xdee9_clob_Order">Order</Link> \{
    <b>let</b> user = <Link href="../iota-framework/object#0x2_object_id">object::id</Link>(account_cap);
    <b>assert</b>!(<Link href="../iota-framework/table#0x2_table_contains">table::contains</Link>(&pool.usr_open_orders, user), <Link href="clob#0xdee9_clob_EInvalidUser">EInvalidUser</Link>);
    <b>let</b> usr_open_order_ids = <Link href="../iota-framework/table#0x2_table_borrow">table::borrow</Link>(&pool.usr_open_orders, user);
    <b>assert</b>!(<Link href="../iota-framework/linked_table#0x2_linked_table_contains">linked_table::contains</Link>(usr_open_order_ids, order_id), <Link href="clob#0xdee9_clob_EInvalidOrderId">EInvalidOrderId</Link>);
    <b>let</b> order_price = *<Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(usr_open_order_ids, order_id);
    <b>let</b> open_orders =
        <b>if</b> (order_id &lt; <Link href="clob#0xdee9_clob_MIN_ASK_ORDER_ID">MIN_ASK_ORDER_ID</Link>) \{ &pool.bids }
        <b>else</b> \{ &pool.asks };
    <b>let</b> tick_level = <Link href="critbit#0xdee9_critbit_borrow_leaf_by_key">critbit::borrow_leaf_by_key</Link>(open_orders, order_price);
    <b>let</b> tick_open_orders = &tick_level.open_orders;
    <b>let</b> order = <Link href="../iota-framework/linked_table#0x2_linked_table_borrow">linked_table::borrow</Link>(tick_open_orders, order_id);
    order
}
</code></pre>



</details>
